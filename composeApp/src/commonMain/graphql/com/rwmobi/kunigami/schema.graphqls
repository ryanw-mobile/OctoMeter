"""
A charge to the customer.
"""
type Charge implements TransactionType {
  id: ID

  postedDate: Date

  """
  The date time when the transaction is created.
  """
  createdAt: DateTime

  """
  Unique identifier of the account the transaction belongs to.
  """
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """
  Deprecated.
  """
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean

  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """
  Returns None if a statement is not linked with the transaction.
  """
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")

  isReversed: Boolean!

  """
  Returns True if the transaction is linked with a statement.
  """
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String

  """
  If this charge is for consumption of a good or service, this field will contain details of how much was consumed. Omitted in cases where the charge is not for consumption, or where consumption information is not available (e.g. for some older records).
  """
  consumption: Consumption

  """
  Whether the charge is for export electricity.
  """
  isExport: Boolean
}

"""
An enumeration.
"""
enum ConsumptionUnit {
  kWh

  MJ
}

type StatementType implements BillInterface {
  id: ID

  billType: BillTypeEnum

  fromDate: Date

  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.


          
  """
  temporaryUrl: String

  """
  The date the bill was sent to the customer.
  """
  issuedDate: Date

  """
  This field returns the closing balance of an issued statement.
  """
  closingBalance: Int

  """
  This field returns the opening balance of a statement.
  """
  openingBalance: Int

  """
  Whether the bill originated in Kraken or externally.
  """
  isExternalBill: Boolean

  """
  Transactions on the bill.
  """
  transactions(before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  """
  Email recipient user ID.
  """
  userId: Int

  """
  Email recipient address.
  """
  toAddress: String

  """
  The date the bill is due to be paid.
  """
  paymentDueDate: Date

  """
  The first day of consumption that this statement includes.
  """
  consumptionStartDate: Date

  """
  The last day of consumption that this statement includes.
  """
  consumptionEndDate: Date

  """
  How many charges have been reversed after the close date.
  """
  reversalsAfterClose: StatementReversalsAfterClose!

  """
  Current status of the associated statement.
  """
  status: AccountStatementStatus

  """
  Retrieve the held status of a account statement.
  """
  heldStatus: HeldStatus

  """
  The total amounts for all charges on the statement.
  """
  totalCharges: StatementTotalType

  """
  The total amounts for all credits on the statement.
  """
  totalCredits: StatementTotalType
}

"""
An enumeration.
"""
enum StatementReversalsAfterClose {
  """
  All charges have been reversed after the statement was closed.
  """
  ALL

  """
  Some charges have been reversed after the statement was closed.
  """
  SOME

  """
  No reversals after the statement was closed.
  """
  NONE

  """
  The statement has not been closed yet.
  """
  NOT_CLOSED
}

"""
An enumeration.
"""
enum AccountStatementStatus {
  OPEN

  CLOSED
}

type HeldStatus {
  """
  Whether a statement is currently held.
  """
  isHeld: Boolean

  """
  Reason for statement being held.
  """
  reason: String
}

type StatementTotalType {
  """
  The net total amount for the statement (in minor currency units).
  """
  netTotal: Int

  """
  The total amount of tax on the statement (in minor currency units).
  """
  taxTotal: Int

  """
  The gross total amount for the statement (in minor currency units).
  """
  grossTotal: Int
}

type PreKrakenBillType implements BillInterface {
  id: ID

  billType: BillTypeEnum

  fromDate: Date

  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.


          
  """
  temporaryUrl: String

  """
  The date the bill was sent to the customer.
  """
  issuedDate: Date

  """
  The params associated with the historical bill.
  """
  params: JSONString
}

type PeriodBasedDocumentType implements BillInterface {
  id: ID

  billType: BillTypeEnum

  fromDate: Date

  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.


          
  """
  temporaryUrl: String

  """
  The date the bill was sent to the customer.
  """
  issuedDate: Date

  """
  The unique identifier for the billing document. Note: a pending billing document will not have an identifier yet;
  and not all finalized billing documents will have an identifier assigned to them, in which case this will be null.
  """
  identifier: ID

  """
  The total amounts for all charges on the billing document.
  """
  totalCharges: StatementTotalType

  """
  The total amounts for all credits on the statement.
  """
  totalCredits: StatementTotalType
}

type InvoiceType implements BillInterface {
  id: ID

  billType: BillTypeEnum

  fromDate: Date

  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.


          
  """
  temporaryUrl: String

  """
  The date the bill was sent to the customer.
  """
  issuedDate: Date
}

"""
A payment from the customer to the energy supplier.
"""
type Payment implements TransactionType {
  id: ID

  postedDate: Date

  """
  The date time when the transaction is created.
  """
  createdAt: DateTime

  """
  Unique identifier of the account the transaction belongs to.
  """
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """
  Deprecated.
  """
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean

  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """
  Returns None if a statement is not linked with the transaction.
  """
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")

  isReversed: Boolean!

  """
  Returns True if the transaction is linked with a statement.
  """
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

"""
A refund to the customer from the energy supplier.
"""
type Refund implements TransactionType {
  id: ID

  postedDate: Date

  """
  The date time when the transaction is created.
  """
  createdAt: DateTime

  """
  Unique identifier of the account the transaction belongs to.
  """
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """
  Deprecated.
  """
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean

  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """
  Returns None if a statement is not linked with the transaction.
  """
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")

  isReversed: Boolean!

  """
  Returns True if the transaction is linked with a statement.
  """
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

type Consumption {
  startDate: Date

  endDate: Date

  quantity: Decimal

  unit: ConsumptionUnit

  usageCost: Int

  supplyCharge: Int
}

"""
The metadata input type for mutations.
"""
input MetadataInput {
  """
  An identifier for the associated object, e.g. account_number for the Account linked object type.
  """
  identifier: String!

  """
  The object that the metadata is associated with.
  """
  linkedObjectType: LinkedObjectType!

  """
  The key for the metadata.
  """
  key: String!

  """
  The metadata value which should be a valid JSON string.
  """
  value: JSONString!
}

enum LinkedObjectType {
  ACCOUNT

  ACCOUNT_USER
}

"""
A Loyalty Point ledger entry.
"""
type LoyaltyPointLedgerEntryType {
  id: ID!

  """
  The `LedgerEntryType`. Either CHARGE or CREDIT.
  """
  ledgerType: String

  """
  The value of the charge or credit.
  """
  value: String

  """
  Equal to the `balance_carried_forward` from the previous ledger entry or zero if this is the first one.
  """
  balanceBroughtForward: String

  """
  Equal to the `balance_brought_forward` plus or minus the value depending on the ledger_type.
  """
  balanceCarriedForward: String

  """
  The reason the entry was being added.
  """
  reasonCode: String

  """
  The date the points were added to the ledger.
  """
  postedAt: DateTime

  """
  The account number associated with the entry.
  """
  accountNumber: String
}

type InkConversation {
  id: ID!

  """
  The status of the conversation.
  """
  status: InkConversationStatus!

  """
  The contact channel identities associated with this conversation.
  """
  contactChannelIdentities: InkContactChannelIdentities!

  """
  The account users on the conversation.
  """
  accountUsers: [AccountUserType!]

  """
  Conversation events.
  """
  events(before: String, after: String, first: Int, last: Int): InkConversationEventsConnection!

  """
  The buckets the conversation is currently in.
  """
  buckets: [InkBucket!]
}

enum InkConversationStatus {
  OPEN

  OPEN_NEW

  OPEN_CUSTOMER_REPLIED

  OPEN_REMINDED

  SNOOZED

  CLOSED
}

type InkContactChannelIdentities {
  """
  The default contact for this conversation.
  """
  default: InkContactChannelIdentity

  """
  All contacts for this conversation.
  """
  all: [InkContactChannelIdentity!]!
}

type InkContactChannelIdentity {
  """
  The channel of the contact.
  """
  channel: InkCommunicationChannel!

  """
  The handle.
  """
  handle: String!

  """
  The name to display to the user.
  """
  displayName: String!
}

"""
An enumeration.
"""
enum InkCommunicationChannel {
  EMAIL

  SMS

  POST

  GENERIC_API

  WHATSAPP
}

type InkConversationEventsConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [InkConversationEventsEdge!]!
}

"""
A Relay edge containing a `InkConversationEvents` and its cursor.
"""
type InkConversationEventsEdge {
  """
  The item at the end of the edge
  """
  node: InkConversationEvent!

  """
  A cursor for use in pagination
  """
  cursor: String!
}

union InkConversationEvent = InkNewMessage

"""
This types is used for both the message-received and message-sent conversation events.
"""
type InkNewMessage implements InkConversationEventInterface {
  """
  The time the conversation event occurred.
  """
  occurredAt: DateTime!

  """
  The message.
  """
  message: InkMessage!
}

interface InkConversationEventInterface {
  """
  The time the conversation event occurred.
  """
  occurredAt: DateTime!
}

union InkMessage = InkEmail|InkSMS|InkLine|InkWhatsApp|InkPost|InkGenericMessage

"""
This type wraps around the `Message` type for emails.
"""
type InkEmail {
  """
  The direction of the email.
  """
  direction: InkMessageDirection!

  """
  The addresses that the message was sent to.
  """
  toHandles: [String!]

  """
  From email address.
  """
  fromHandle: String!

  """
  The delivery status of the message.
  """
  delivery: InkMessageDelivery!

  """
  The contact channel identity.
  """
  contactChannelIdentity: InkContactChannelIdentity!

  """
  The time the message was sent/received.
  """
  occurredAt: DateTime!

  """
  The email subject.
  """
  subject: String!

  """
  The content of the message.
  """
  displayContent: String!

  """
  Attachments on the message.
  """
  attachments: [InkMessageAttachment!]!

  """
  CC recipients on the message.
  """
  cc: [String!]!

  """
  Is this an message an email.
  """
  isChannelEmail: Boolean!

  """
  All Tags associated with a message.
  """
  tags: [InkTag!]!
}

enum InkMessageDirection {
  INBOUND

  OUTBOUND
}

type InkMessageDelivery {
  """
  Message delivery status.
  """
  status: InkMessageDeliveryStatus!
}

enum InkMessageDeliveryStatus {
  PENDING

  SENT

  DELIVERED

  FAILED

  OUTSIDE_REPLY_WINDOW
}

type InkMessageAttachment {
  """
  The filename.
  """
  filename: String!

  """
  The url for fetching the attachment.
  """
  fetchUrl: String

  """
  The size in bytes.
  """
  sizeInBytes: Int
}

type InkTag implements Node {
  """
  The ID of the object
  """
  id: ID!

  """
  Tag for a message.
  """
  name: String!
}

"""
This type wraps around the `Message` type for SMS.
"""
type InkSMS {
  """
  The direction of the message.
  """
  direction: InkMessageDirection!

  """
  The phone number the message was sent from.
  """
  fromHandle: String!

  """
  The phone number the message was sent to.
  """
  toHandle: String!

  """
  The delivery status.
  """
  delivery: InkMessageDelivery!

  """
  The contact channel identity.
  """
  contactChannelIdentity: InkContactChannelIdentity!

  """
  The time the message was sent/received at.
  """
  occurredAt: DateTime!

  """
  The content of the message.
  """
  displayContent: String!

  """
  Is this an SMS message.
  """
  isChannelSms: Boolean!

  """
  All Tags associated with a message.
  """
  tags: [InkTag!]!
}

"""
This type wraps around the `Message` type for LINE message.
"""
type InkLine {
  """
  The direction of the message.
  """
  direction: InkMessageDirection!

  """
  From LINE id.
  """
  fromHandle: String!

  """
  To LINE id.
  """
  toHandle: String!

  """
  The delivery status of the message.
  """
  delivery: InkMessageDelivery!

  """
  The contact channel identity.
  """
  contactChannelIdentity: InkContactChannelIdentity!

  """
  The time the message was sent/received.
  """
  occurredAt: DateTime!

  """
  The line message content.
  """
  lineMessage: LineMessage!

  """
  Is this a LINE message.
  """
  isChannelLine: Boolean!

  """
  Attachments on the LINE message.
  """
  attachments: [InkMessageAttachment!]!

  """
  All Tags associated with a message.
  """
  tags: [InkTag!]!
}

union LineMessage = LineTextMessage|LineStickerMessage|LineImageMessage

type LineTextMessage {
  """
  The display content.
  """
  displayContent: String!

  """
  The emojis in the message.
  """
  emojis: [LineEmoji!]
}

"""
A LINE specific emoji object.
refs: https://developers.line.biz/en/reference/messaging-api/#text-message
"""
type LineEmoji {
  """
  The location of the emoji in the message.
  """
  index: Int!

  """
  The length of the emoji string placeholder.
  """
  length: Int

  """
  The product id.
  """
  productId: String!

  """
  The emoji id.
  """
  emojiId: String!
}

type LineStickerMessage {
  """
  Sticker package id.
  """
  packageId: String!

  """
  Sticker id.
  """
  stickerId: String!

  """
  Sticker resource type.
  """
  resourceType: String!

  """
  Keywords describing the sticker.
  """
  keywords: [String!]!

  """
  Text used to customize some stickers.
  """
  text: String!
}

type LineImageMessage {
  id: ID!
}

"""
This type wraps around the `Message` type for WhatsApp message.
"""
type InkWhatsApp {
  """
  The direction of the message.
  """
  direction: InkMessageDirection!

  """
  From WhatsApp phone number.
  """
  fromHandle: String!

  """
  Whatsapp contact phone number.
  """
  toHandle: String!

  """
  Whatsapp message delivery status.
  """
  delivery: InkMessageDelivery!

  """
  Whatsapp message contact channel identity.
  """
  contactChannelIdentity: InkContactChannelIdentity!

  """
  Date when the conversation event was created.
  """
  occurredAt: DateTime!

  """
  The vendor id.
  """
  vendorId: String

  """
  Whatsapp message content.
  """
  whatsappContent: WhatsAppTextMessage!

  """
  Whether or not the message is a whatsapp message.
  """
  isChannelWhatsapp: Boolean!

  """
  All Tags associated with a message.
  """
  tags: [InkTag!]!
}

type WhatsAppTextMessage {
  """
  Whatsapp text message body.
  """
  body: String!
}

"""
This type wraps around the `Message` type for Post.
"""
type InkPost {
  """
  The from property id.
  """
  fromHandle: String!

  """
  The to property id.
  """
  toHandle: String!

  """
  The notes left when a message was uploaded.
  """
  displayContent: String!

  """
  The content of the message.
  """
  rawPlainTextContent: String!

  """
  Determine if the message is a post message.
  """
  isChannelPost: Boolean!

  """
  The contact channel identity.
  """
  contactChannelIdentity: InkContactChannelIdentity!
}

"""
This message type is used for messages that belong to contact
channels without a more granular message type.
"""
type InkGenericMessage implements Node {
  """
  The ID of the object
  """
  id: ID!

  """
  The direction of the message.
  """
  direction: InkMessageDirection!

  """
  The identity the message was sent from.
  """
  fromHandle: String!

  """
  The identity the message was sent to.
  """
  toHandle: String!

  """
  The delivery status.
  """
  delivery: InkMessageDelivery!

  """
  The contact channel identity.
  """
  contactChannelIdentity: InkContactChannelIdentity!

  """
  The time the message was sent/received at.
  """
  occurredAt: DateTime!

  """
  The content of the message.
  """
  displayContent: String!
}

type InkBucket implements Node {
  """
  The ID of the object
  """
  id: ID!

  """
  The ink bucket name.
  """
  name: String!

  """
  The icon code point.
  """
  icon: String
}

"""
A loyalty card.
"""
type LoyaltyCardType {
  id: ID!

  """
  The scheme of the loyalty card.
  """
  scheme: String

  """
  The number of the loyalty card.
  """
  number: String

  """
  The status of the loyalty card.
  """
  status: String
}

"""
Represents print batch details
"""
type PrintBatchType {
  id: ID!

  """
  The status of the print batch.
  """
  status: PrintBatchStatus

  """
  Messages in a print batch.
  """
  messages("Whether to filter to include or exclude high priority messages. If not supplied, no filtering will be performed." isHighPriority: Boolean = null, offset: Int, before: String, after: String, first: Int, last: Int): PrintMessageTypeConnection
}

"""
An enumeration.
"""
enum PrintBatchStatus {
  OPEN

  CLOSED

  PROCESSED
}

type PrintMessageTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [PrintMessageTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `PrintMessageType` and its cursor.
"""
type PrintMessageTypeEdge {
  """
  The item at the end of the edge
  """
  node: PrintMessageType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Information about what version of Kraken is being executed by this service.
"""
type KrakenVersionType {
  """
  The version number that is being executed.
  """
  number: String

  """
  The git commit SHA that is being executed.
  """
  SHA: String
}

type TermsAndConditionsType {
  name: String

  pdfUrl: String

  brandCode: String

  """
  The markdown text of the terms and conditions.
  """
  markdown: String

  """
  The html of the terms and conditions document rendered as a JSON string.
  """
  html: String

  version: String

  effectiveFrom: DateTime
}

type RateLimitInformation {
  """
  The maximum number of points the viewer gets for requests per hour.
  """
  limit: Int

  """
  The remaining points for the viewer in one hour time limit.
  """
  remainingPoints: Int

  """
  The points used so far in one hour time limit.
  """
  usedPoints: Int
}

type QueryComplexityOutputType {
  """
  The complexity of the query.
  """
  complexityValue: Int
}

"""
Information about the complexity of the query.
"""
input QueryComplexityInputType {
  """
  The query to calculate complexity for.
  """
  query: String!

  """
  Any variables to include for the query. Pagination variables should be included as they will affect the overall weight of the query.
  """
  variables: JSONString

  """
  The operation name of the query to calculate complexity for if more than one is provided.
  """
  operationName: String
}

type DepositAgreementOutput {
  depositKey: String

  depositAmount: Int

  acceptedAt: DateTime

  fulfilledAt: DateTime
}

"""
An enumeration.
"""
enum PaymentType {
  BPAY

  CARD

  DIRECT_DEBIT

  GMO_REFUND

  PAYMENT_SLIP
}

"""
A key-value pair (both Strings) which is passed in parameters to a backend action.
"""
input BackendScreenParamInputType {
  key: String!

  value: String!
}

"""
Represents a Leave Supplier process. Conceptually, it contains information related to supply points that are associated with a Leave Supplier journey.
"""
type LeaveSupplierProcessType implements AbstractSupplyPointProcessInterface {
  """
  The ID or the primary key of the lifecycle process.
  """
  id: ID

  """
  The status of the process.
  """
  status: LeaveSupplierProcessStatus

  """
  The supply points associated with the process.
  """
  supplyPoints(before: String, after: String, first: Int, last: Int): SupplyPointConnectionTypeConnection!
}

"""
Interface for all lifecycle journey processes that
inherit from AbstractSupplyPointProcess.
"""
interface AbstractSupplyPointProcessInterface {
  """
  The ID or the primary key of the lifecycle process.
  """
  id: ID

  """
  The status of the process.
  """
  status: LeaveSupplierProcessStatus

  """
  The supply points associated with the process.
  """
  supplyPoints(before: String, after: String, first: Int, last: Int): SupplyPointConnectionTypeConnection!
}

"""
The status of the LeaveSupplier process.
"""
enum LeaveSupplierProcessStatus {
  COMPLETED

  PARTIALLY_COMPLETED

  PENDING

  IN_PROGRESS

  STALLED

  CANCELLED

  PARTIALLY_CANCELLED

  REVERSED

  PARTIALLY_REVERSED

  FAILED

  ERRORED
}

type SupplyPointConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [SupplyPointConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `SupplyPointConnectionType` and its cursor.
"""
type SupplyPointConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: SupplyPointType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Represents a SupplyPoint.
"""
type SupplyPointType implements CommonSupplyPointInterface {
  """
  The ID of the supply point.
  """
  id: ID!

  """
  The market this supply point belongs to.
  """
  marketName: String!

  """
  The external identifier of the supply point.
  """
  externalIdentifier: String
}

interface CommonSupplyPointInterface {
  """
  The ID of the supply point.
  """
  id: ID!

  """
  The market this supply point belongs to.
  """
  marketName: String!

  """
  The external identifier of the supply point.
  """
  externalIdentifier: String
}

type LifecycleProcessesType {
  """
  List of LeaveSupplierProcess for an account.
  """
  leaveSupplierProcesses(before: String, after: String, first: Int, last: Int): LeaveSupplierProcessConnectionTypeConnection

  """
  List of JoinSupplierProcess for an account.
  """
  joinSupplierProcesses(before: String, after: String, first: Int, last: Int): JoinSupplierProcessConnectionTypeConnection

  """
  List of OccupyPropertyProcess for an account.
  """
  occupyPropertyProcesses(before: String, after: String, first: Int, last: Int): OccupyPropertyProcessConnectionTypeConnection

  """
  List of LeavePropertyProcess for an account.
  """
  leavePropertyProcesses(before: String, after: String, first: Int, last: Int): LeavePropertyProcessConnectionTypeConnection
}

type LeaveSupplierProcessConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [LeaveSupplierProcessConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `LeaveSupplierProcessConnectionType` and its cursor.
"""
type LeaveSupplierProcessConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: LeaveSupplierProcessType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type JoinSupplierProcessConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [JoinSupplierProcessConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `JoinSupplierProcessConnectionType` and its cursor.
"""
type JoinSupplierProcessConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: JoinSupplierProcessType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Represents a Join Supplier process.
"""
type JoinSupplierProcessType implements AbstractSupplyPointProcessInterface {
  """
  The ID or the primary key of the lifecycle process.
  """
  id: ID

  """
  The status of the process.
  """
  status: LeaveSupplierProcessStatus

  """
  The supply points associated with the process.
  """
  supplyPoints(before: String, after: String, first: Int, last: Int): SupplyPointConnectionTypeConnection!
}

type OccupyPropertyProcessConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [OccupyPropertyProcessConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `OccupyPropertyProcessConnectionType` and its cursor.
"""
type OccupyPropertyProcessConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: OccupyPropertyProcessType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Represents a Occupy Property process.
"""
type OccupyPropertyProcessType implements AbstractSupplyPointProcessInterface {
  """
  The ID or the primary key of the lifecycle process.
  """
  id: ID

  """
  The status of the process.
  """
  status: LeaveSupplierProcessStatus

  occupyAt: DateTime!

  """
  The supply points associated with the process.
  """
  supplyPoints(before: String, after: String, first: Int, last: Int): SupplyPointConnectionTypeConnection!
}

type LeavePropertyProcessConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [LeavePropertyProcessConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `LeavePropertyProcessConnectionType` and its cursor.
"""
type LeavePropertyProcessConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: LeavePropertyProcessType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Represents a Leave Property process.
"""
type LeavePropertyProcessType implements AbstractSupplyPointProcessInterface {
  """
  The ID or the primary key of the lifecycle process.
  """
  id: ID

  """
  The status of the process.
  """
  status: LeaveSupplierProcessStatus

  """
  The supply points associated with the process.
  """
  supplyPoints(before: String, after: String, first: Int, last: Int): SupplyPointConnectionTypeConnection!
}

type GoodsQuote {
  """
  ID of the quote.
  """
  id: Int

  """
  Code of the quote.
  """
  code: String

  """
  Total net amount of the quote in cents.
  """
  totalNetAmount: Int

  """
  Date and time when the quote was created.
  """
  quotedAt: DateTime

  """
  Products of this quote.
  """
  goodsQuotedProducts: [GoodsQuotedProduct]

  """
  Indicates whether or not the quote is expired.
  """
  hasQuoteExpired: Boolean
}

type GoodsProductConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [GoodsProductConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `GoodsProductConnectionType` and its cursor.
"""
type GoodsProductConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: GoodsProduct

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type GoodsProduct {
  """
  Product ID.
  """
  id: Int

  """
  Market of the product.
  """
  marketName: String

  """
  Type of the product.
  """
  productType: GoodsProductType

  """
  Product code.
  """
  code: String

  """
  Product internal name.
  """
  internalName: String

  """
  Product customer name.
  """
  customerName: String

  """
  Product notes.
  """
  notes: String

  """
  Product description.
  """
  description: String

  """
  Product available from.
  """
  availableFrom: Date

  """
  Product available to.
  """
  availableTo: Date

  """
  Price per unit.
  """
  pricePerUnit: Float

  """
  Gross price per unit.
  """
  grossPricePerUnit: Float

  """
  Currency.
  """
  currency: String
}

type GoodsProductType {
  """
  Product type code.
  """
  code: String

  """
  Product type name.
  """
  internalName: String
}

type GoodsPurchase {
  """
  Purchase code.
  """
  code: String

  """
  Ledger ID associated to the purchase.
  """
  ledgerId: String

  """
  Sale items in this purchase.
  """
  goodsSaleItems: [GoodsSaleItem]

  """
  Grants that apply in this purchase.
  """
  goodsGrants: [GoodsGrant]

  """
  Market parameters of the purchase.
  """
  marketParams: JSONString

  """
  Client parameters of the purchase.
  """
  clientParams: JSONString
}

type GoodsSaleItem {
  """
  Product code.
  """
  product: String

  """
  Number of units.
  """
  numberOfUnits: Int

  """
  Price per unit.
  """
  pricePerUnit: Float

  """
  Net amount.
  """
  netAmount: Float

  """
  Gross amount.
  """
  grossAmount: Float

  """
  Currency.
  """
  currency: String
}

type GoodsGrant {
  """
  Grant type.
  """
  type: String

  """
  Net amount.
  """
  netAmount: Float

  """
  Gross amount.
  """
  grossAmount: Float

  """
  Currency.
  """
  currency: String
}

"""
Energy mix data can include the latest carbon intensity index in a region.
"""
type EnergyMixDataType {
  """
  Current carbon intensity index.
  """
  carbonIntensityIndex: String
}

"""
Paginator of API exceptions.
"""
type APIExceptionConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [APIExceptionConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `APIExceptionConnectionType` and its cursor.
"""
type APIExceptionConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: APIExceptionType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type APIExceptionType {
  id: ID!

  """
  External identifier submitted by the API client to track this exception on their end.
  """
  externalIdentifier: String!

  createdAt: DateTime!

  """
  Free field for the API caller to categorise a channel. This could be (but not limited to) the client's team that calleded the API, the name of the 'flow' the call belongs to, etc.
  """
  channel: String!

  """
  Category associated with this exception.
  """
  category: APIExceptionCategories

  """
  The account number provided to the exception.
  """
  accountNumber: String

  """
  The user id provided to the exception.
  """
  userId: Int

  """
  The customer contact provided to the exception.
  """
  customerContact: String

  """
  The supply point identifier provided to the exception.
  """
  supplyPointIdentifier: String

  """
  The current resolution status for the API exception.
  """
  resolutionStatus: APIExceptionResolutionStatus!

  """
  The current resolution type for the API exception.
  """
  resolutionType: APIExceptionResolutionType!

  """
  The current priority for the API exception.
  """
  priority: APIExceptionPriority!

  """
  The API calls associated with this exception if any.
  """
  apiCalls: [APICallType]

  """
  The events associated with this exception if any.
  """
  events: [APIExceptionEventType]

  """
  Tags associated with this exception if any.
  """
  tags: [APIExceptionTags]

  """
  Notes associated with this exception if any.
  """
  notes: [APIExceptionNoteType]

  """
  The operations team assigned to this exception if any.
  """
  operationsTeam: OperationsTeamType

  """
  Storage for the API client to submit any contextual information.
  """
  context: JSONString

  """
  The key date associated with the exception, if available.
  """
  keyDate: Date

  """
  The user assigned to handle this exception if any.
  """
  assignedUser: AssignedUserType
}

"""
An enumeration.
"""
enum APIExceptionCategories {
  ACCOUNT

  UNKNOWN
}

"""
An enumeration.
"""
enum APIExceptionResolutionStatus {
  ASSIGNED

  CANCELLED

  IN_PROGRESS

  RESOLVED

  UNASSIGNED

  UNSUCCESSFUL

  WAITING_ON_THIRD_PARTY
}

"""
An enumeration.
"""
enum APIExceptionResolutionType {
  AUTOMATIC

  MANUAL

  UNASSIGNED
}

"""
An enumeration.
"""
enum APIExceptionPriority {
  LOW

  MEDIUM

  HIGH
}

type APICallType {
  id: ID!

  """
  The request's correlation id.
  """
  correlationId: String!

  """
  Free field for the API caller to categorise their own operation name. This field can be used to filter entries on the UI.
  """
  operationName: String!

  """
  Input data for the API call if any.
  """
  inputData: JSONString

  """
  The response from the API call if any.
  """
  response: JSONString

  """
  Storage for the API client to submit any contextual information.
  """
  context: JSONString

  createdAt: DateTime!
}

type APIExceptionEventType {
  id: ID!

  """
  The type of the event.
  """
  eventType: String!

  """
  The category of the event.
  """
  category: String!

  """
  A description of the event.
  """
  description: String

  """
  A JSON context to be provided with the event, if any.
  """
  context: JSONString

  createdAt: DateTime!
}

"""
An enumeration.
"""
enum APIExceptionTags {
  MOVE_IN

  MOVE_OUT

  PRODUCT_UPDATE
}

type APIExceptionNoteType {
  """
  The ID of the API Exception note.
  """
  id: ID!

  """
  The content of the API Exception note.
  """
  body: String!

  """
  Timestamp of when the API Exception note was created.
  """
  createdAt: DateTime!
}

type AssignedUserType {
  """
  The ID of the assigned user.
  """
  id: ID!

  """
  The username of the assigned user.
  """
  username: String!
}

input APIExceptionQueryInput {
  """
  The external identifier to filter for.
  """
  externalIdentifier: String

  """
  The resolution status to filter for.
  """
  resolutionStatus: APIExceptionResolutionStatus = null

  """
  The resolution type to filter for.
  """
  resolutionType: APIExceptionResolutionType = null

  """
  The channel to filter for.
  """
  channel: String

  """
  The priority to filter for.
  """
  priority: APIExceptionPriority = null

  """
  Tags to filter for.
  """
  tags: [APIExceptionTags]

  """
  The category to filter for.
  """
  category: APIExceptionCategories = null

  """
  The account number to filter for.
  """
  accountNumber: ID

  """
  The user ID to filter for.
  """
  userId: ID

  """
  The customer contact to filter for.
  """
  customerContact: String

  """
  The supply point identifier to filter for.
  """
  supplyPointIdentifier: ID
}

type CreditReasonType {
  """
  The credit reason code.
  """
  code: String

  """
  The credit reason display text.
  """
  display: String

  """
  Whether the credit reason is deprecated.
  """
  isDeprecated: Boolean

  """
  Whether the credit reason is sales tax exempt.
  """
  isTaxExempt: Boolean

  """
  Whether the credit reason is hidden.
  """
  isHidden: Boolean

  """
  The group the credit reason belongs to (if applicable).
  """
  group: String
}

type ChargeReasonType {
  """
  The charge reason code.
  """
  code: String

  """
  The charge reason display text.
  """
  display: String

  """
  Whether the charge reason is deprecated.
  """
  isDeprecated: Boolean

  """
  Whether the charge reason is sales tax exempt.
  """
  isTaxExempt: Boolean

  """
  Whether the charge reason is hidden.
  """
  isHidden: Boolean

  """
  The group the charge reason belongs to (if applicable).
  """
  group: String
}

"""
The account object can be one of several attached to a `Portfolio` (which usually has an `AccountUser` which is used to authenticate access to the `Portfolio`'s accounts). Typically a person has a single account attached to a portfolio and properties on the same account will appear on the same bill. Where separate bills are desired, multiple accounts  are created and added to the same portfolio of accounts.
"""
type AccountType implements AccountInterface {
  id: ID!

  """
  A code that uniquely identifies the account.
  """
  number: String

  """
  The current status of the account.
  """
  status: AccountStatus

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(activeOnDate: Date, active: Boolean, canCreatePayment: Boolean @deprecated(reason: "The 'canCreatePayment' field is deprecated.\n\nPlease use 'includeDormant' instead.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-12-06."), "If false, we remove the currently valid schedule if it has already fulfilled its purpose and will have no further impact on customer payments, along with any schedules which are not valid from today." includeDormant: Boolean = true, "The ledger to return transactions from." ledgerType: Int, "The ledger id to return the payment schedules from." ledgerId: ID, reason: PaymentScheduleReasonOptions, before: String, after: String, first: Int, last: Int): PaymentScheduleConnectionTypeConnection

  users: [AccountUserType!]!

  """
  The brand of the account.
  """
  brand: String

  """
  The current account balance.
  """
  balance("If this variable is set to true, the balance will be calculated based on the sum of balances on all ledgers configured to contribute to this account's balance. Otherwise, only the main ledger's balance will be fetched (legacy behaviour). If you are unsure, set this value to true." includeAllLedgers: Boolean = false): Int!

  """
  The current account overdue balance.
  """
  overdueBalance: Int

  """
  Unique reference number from a 3rd party enrolment.
  """
  urn: String

  """
  The billing name of the account.
  """
  billingName: String

  """
  The billing sub name of the account.
  """
  billingSubName: String

  """
  The billing email of the account.
  """
  billingEmail: String

  """
  The billing address of the account.
  """
  billingAddress: String

  billingAddressLine1: String

  billingAddressLine2: String

  billingAddressLine3: String

  billingAddressLine4: String

  billingAddressLine5: String

  billingAddressPostcode: String

  billingCountryCode: String

  billingDeliveryPointIdentifier: String

  """
  List of billing address lines.
  """
  splitBillingAddress: [String]

  """
  The billing address of this account, stored in the new
  libaddressinput-based format.

  Note that `name` and `organization` are very unlikely to be
  supplied here; the `billing_name` field on the account
  itself is generally used for that purpose instead.
  """
  address: RichAddressType

  """
  The portfolio this account is linked to.
  """
  portfolio: PortfolioType

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  """
  ledgers("The ledger to return" ledgerId: ID, "The ledger to return by its number" ledgerNumber: String): [LedgerType]

  """
  Metadata associated with the account.
  """
  metadata: [Metadata]

  """
  Whether the account can request a credit refund.
  """
  canRequestRefund: Boolean

  """
  Details about the eligibility status for requesting a refund.
  """
  requestRefundEligibility: RequestRefundEligibilityType

  """
  The payments made into an account from a payment instruction.
  """
  payments("**WARNING: Will be mandatory in future versions**\n\nThe ledger to return payments from." ledgerId: String, status: AccountPaymentStatusOptions, "Filter for payments that were taken for a particular reason." reason: PaymentReasonOptions, "Whether to include payment promises (of any kind: made, broken or fulfilled) or not. The default is to include them." includePromises: Boolean = true, before: String, after: String, first: Int, last: Int): AccountPaymentConnectionTypeConnection

  """
  The repayments that have been requested for this account.
  """
  repayments("Only return repayments whose status matches one of these statuses" statuses: [AccountRepaymentStatusOptions], before: String, after: String, first: Int, last: Int): AccountRepaymentConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast("The end date to retrieve forecasts for. This end date is inclusive." dateTo: Date!, "The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed." ledgerId: Int): [PaymentForecastType] @deprecated(reason: "The 'paymentForecast' field is deprecated.\n\nPlease use 'paginatedPaymentForecast' instead.\n\n- Marked as deprecated on 2024-01-03.\n- Will be removed on 2025-01-01.")

  """
  Paginated payment forecasts for an account. Starts from today's date (inclusive). The interface supports `last` but does not guarantee 'lastness'.
  """
  paginatedPaymentForecast("The end date to retrieve forecasts for. This end date is inclusive." dateTo: Date, "The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed." ledgerId: Int, before: String, after: String, first: Int, last: Int): PaymentForecastConnectionTypeConnection

  """
  The referrals created by this account.
  """
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """
  Number of referrals created by this account.
  """
  referralsCreated: Int

  """
  The rewards applied to this account.
  """
  rewards: [RewardType]

  """
  The referral schemes currently active for this account.
  """
  activeReferralSchemes: ReferralSchemeTypes

  """
  Fetch transactions that have taken place on the account.
  """
  transactions("Include only these specific transaction types in the result." transactionTypes: [TransactionTypeFilter] = [], "Exclude these specific transaction types from the result." transactionTypesExcluded: [TransactionTypeFilter] = [], "The ledger to return transactions from." ledgerId: Int, "In a multi-ledger scenario, include all ledgers' transactions if `true`. Analogously, if `false` and no `ledgerId` argument is present, the list of transactions defaults to the main ledger (legacy behaviour)." includeAllLedgers: Boolean, "\nOptional date representing the beginning of the postedDate range filter.\nThis date value is inclusive.\n" fromDate: Date, "\nOptional date representing the end of the postedDate range filter.\nThis date value is exclusive.\n" toDate: Date, "The order in which to return the transactions." orderBy: TransactionsOrderBy = POSTED_DATE_DESC, offset: Int, before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """
  Fetch annual statements for the account.
  """
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """
  Fetch issued bills (invoices/statements) for the account.
  """
  bills("Include bills without PDFs." includeBillsWithoutPDF: Boolean = false, "\nInclude open statements. This flag needs to be used along with\nincludeBillsWithoutPDF=false otherwise results will prove unexpected.\n" includeOpenStatements: Boolean = false, "Include held statements within the results." includeHeldStatements: Boolean = false, "Include pre-Kraken \/ historical statements within the results." includeHistoricStatements: Boolean = true, "Only include bills emailed to the current user's email." onlyCurrentEmail: Boolean = false, "Optional date representing the beginning of the search results. This date value is inclusive." fromDate: Date, "Optional date representing the end of the search results. This date value is exclusive." toDate: Date, "Optional date representing the beginning of the search results based on issued date. This date value is inclusive." issuedFromDate: Date, "Optional date representing the end of the search results based on issued date. This date value is exclusive." issuedToDate: Date, "The order in which to return the bills." orderBy: BillsOrderBy = FROM_DATE_DESC, offset: Int, before: String, after: String, first: Int, last: Int): BillConnectionTypeConnection

  """
  Information about the account's billing cycle.
  """
  billingOptions: BillingOptionsType

  """
  Fetch a specific issued bill (invoice/statement) for the account.
  """
  bill(id: ID!, billType: BillTypeEnum): BillInterface

  """
  The direct debit instructions of the account
  """
  directDebitInstructions("Filter the direct debit instructions by status" statuses: [DirectDebitInstructionStatus], before: String, after: String, first: Int, last: Int): DirectDebitInstructionConnectionTypeConnection

  """
  The account events that were recorded for the account.
  """
  events("Filter the account events by their type." eventTypes: [AccountEventType], before: String, after: String, first: Int, last: Int): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """
  The type of account.
  """
  accountType: AccountTypeChoices

  """
  The company type of a business account.
  """
  businessType: BusinessTypeOptions @deprecated(reason: "The 'businessType' field is deprecated.\n\nUse `business.businessType` instead\n\n- Marked as deprecated on 2022-03-09.\n- Will be removed on 2024-01-01.")

  """
  Business info related to a business account.
  """
  business: BusinessType

  """
  The method the account has specified they prefer we contact them
  """
  commsDeliveryPreference: CommsDeliveryPreference

  communicationDeliveryPreference: String @deprecated(reason: "The 'communicationDeliveryPreference' field is deprecated.\n\nUse `commsDeliveryPreference` instead\n\n- Marked as deprecated on 2022-05-27.\n- Will be removed on 2024-01-01.")

  """
  The document accessibility preference of the account.
  """
  documentAccessibility: DocumentAccessibilityChoices

  """
  Account references linked to this account.
  """
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  Files attached to this account.
  """
  paginatedFileAttachments("File attachment id." id: Int, "File attachment category." category: String, before: String, after: String, first: Int, last: Int): AccountFileAttachmentConnectionTypeConnection

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """
  The campaigns associated with an account.
  """
  campaigns: [AccountCampaignType]

  """
  True if there is an active Hardship Agreement for this account. False otherwise.
  """
  isInHardship: Boolean

  """
  List of active hardship agreements for the user when is_in_hardship is True.
  """
  activeHardshipAgreements: [HardshipAgreementType]

  """
  Notes for the account.
  """
  notes: [AccountNoteType]

  """
  Contribution agreements for account.
  """
  contributionAgreements: [ContributionAgreementType]

  """
  Assistance agreements for account.
  """
  assistanceAgreements: [AssistanceAgreementType]

  """
  Debt collection proceedings for account.
  """
  debtCollectionProceedings: [DebtCollectionProceedingType]

  """
  The datetime that the account was originally created.
  """
  createdAt: DateTime

  """
  The language that the account preferred for communications.
  """
  preferredLanguageForComms: String

  """
  Properties linked to the account now and in the future
  """
  properties("Returns properties that have an effective period that ends at or after the given activeFrom datetime." activeFrom: DateTime): [PropertyType]

  """
  Expected balance in a year's time
  """
  projectedBalance: Int

  """
  Whether the account's payment should be adjusted.
  """
  shouldReviewPayments: Boolean

  """
  Top up payment amount in pence that we recommend for an account.
  """
  recommendedBalanceAdjustment: Int

  """
  The electricity agreements belonging to the account
  """
  electricityAgreements(active: Boolean): [ElectricityAgreementType]

  """
  The gas agreements belonging to the account
  """
  gasAgreements(active: Boolean): [GasAgreementType]

  """
  Get details about warm home discount applications and records
  """
  warmHomeDiscount: WarmHomeDiscount

  """
  Whether the account is eligible to apply for Warm Home Discount as part of the Scottish Broader Group.
  """
  eligibilityForWarmHomeDiscount: WarmHomeDiscountEligibility

  """
  The postcode of the billing address.
  """
  billingPostcode: String

  """
  Whether the account is eligible for tariff renewal
  """
  canRenewTariff: Boolean

  """
  Only relevant for Kraken instances that support daily tracker tariffs. Returns null if not applicable. 
  """
  trackerTariffDailyPricing: TrackerTariffDailyPricing

  """
  Results of the latest review of the account's payments.
  """
  paymentAdequacy: PaymentAdequacyType

  """
  The interest of an account in procuring smart meters.
  """
  smets2Interest: SmartMeterInterestChoices

  """
  The reason why the account holder is not interested in having a smart meter installed.
  """
  smets2RefusalReason: SMETS2InterestReason

  """
  The green benefits achieved over the lifetime of an account.
  """
  greenAccomplishments: GreenAccomplishmentsType

  """
  Whether an account can change their payment schedule.
  """
  canChangePayments: Boolean

  """
  The number of days around a move out a final meter reading can be given for.
  """
  cotReadingWindowDays: Int

  """
  Whether an account can be withdrawn.
  """
  canBeWithdrawn: Boolean

  """
  The current estimated supply start day on an account.
  """
  currentEstimatedSsd: Date

  """
  The earliest possible supply start day on an account.
  """
  earliestPossibleSsd: Date

  """
  The latest possible supply start day on an account.
  """
  latestPossibleSsd: Date

  """
  The operations team that the account belongs to.
  """
  operationsTeam: OperationsTeamType

  """
  Whether on not the meter readings can be input via IVR.
  """
  canInputMeterReadingsViaIvr: Boolean

  """
  Whether or not the account has an active Dunning process.
  """
  hasActiveDunningProcess: Boolean

  """
  Whether or not the account has active collections proceedings.
  """
  hasActiveCollectionsProceedings: Boolean

  """
  Whether or not an account is eligible for an electricity reading incentive.
  """
  isEligibleForElectricityReadingIncentive: Boolean

  """
  Whether or not an account is eligible for a gas reading incentive.
  """
  isEligibleForGasReadingIncentive: Boolean

  """
  Whether or not the account is a part of a migration for which we want to switch supplier without customer actions.
  """
  isInBlockingMigration: Boolean
}

type WarmHomeDiscount {
  """
  Get the Warm Home Discount applications against this account. These are ordered to return the most recent first.
  """
  applications(before: String, after: String, first: Int, last: Int): WarmHomeDiscountApplicationConnection

  """
  Get the Warm Home Discount records attached to this account. These are ordered to return the most recent first.
  """
  records(before: String, after: String, first: Int, last: Int): WarmHomeDiscountRecordConnection
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type WarmHomeDiscountApplicationConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [WarmHomeDiscountApplicationEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `WarmHomeDiscountApplication` and its cursor.
"""
type WarmHomeDiscountApplicationEdge {
  """
  The item at the end of the edge
  """
  node: WarmHomeDiscountApplication

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Get details about a Warm Home Discount application.
"""
type WarmHomeDiscountApplication {
  """
  Which criteria was chosen for the Warm Home Discount application
  """
  qualifyingCriteria: QualifyingCriteriaOptions

  """
  Which component criteria was chosen for the Warm Home Discount application
  """
  qualifyingComponent: QualifyingComponentOptions

  yearEnding: Int!

  """
  The status of the Warm Home Discount application
  """
  status: Status

  """
  Reason for rejecting a Warm Home Discount application
  """
  rejectionReason: BroaderGroupRejectionReason

  """
  The tax year for which the application was made.
  """
  taxYear: String

  """
  The last date on which this application was updated.
  """
  updatedAt: Date
}

"""
An enumeration.
"""
enum QualifyingCriteriaOptions {
  """
  In receipt of the Savings Element of Pension Credit only
  """
  SAVINGS_ELEMENT_OF_PENSION_CREDIT

  """
  In receipt of Council Tax Reduction (excludes the 25% single persons discount)
  """
  COUNCIL_TAX_REDUCTION

  """
  In receipt of Income Support
  """
  INCOME_SUPPORT

  """
  In receipt of Income-based Job Seekers Allowance (JSA)
  """
  JOB_SEEKERS_ALLOWANCE

  """
  In receipt of Income-related Employment & Support Allowance (ESA)
  """
  EMPLOYMENT_AND_SUPPORT_ALLOWANCE

  """
  In receipt of Working Tax Credit with a total annual household income of 19,978 or less (before tax and National Insurance)
  """
  WORKING_TAX_CREDIT

  """
  In receipt of Housing Benefit with a total annual household income of 19,978 or less (before tax and National Insurance)
  """
  HOUSING_BENEFIT

  """
  In receipt of Child Tax Credit where the award statement shows a total annual household income of 19,978 or less (before tax and National Insurance)
  """
  CHILD_TAX_CREDIT

  """
  In receipt of universal credit, and has an earned income of between zero and 1,665 in at least one of the twelve preceding assessment periods
  """
  UNIVERSAL_CREDIT

  """
  A total annual household income of 19,978 or less (before tax and National Insurance)
  """
  LOW_INCOME_THRESHOLD
}

"""
    A list of all current and historic WHD qualifying component options.

    All label strings correspond to specific wording of the most recent scheme.
    
"""
enum QualifyingComponentOptions {
  """
  In receipt of Personal Independence Payments (PIP)
  """
  PERSONAL_INDEPENDENCE_PAYMENTS

  """
  In receipt of Disability Living Allowance (DLA), any disability premium (all rates) or disabled child element of Universal Credit
  """
  DISABILITY_BENEFITS

  """
  In receipt of any Income-related benefit which includes: Carers Premium and Carers Allowance (for someone within the household) OR Attendance Allowance (for applicant or their partner) OR Industrial Injuries Benefit
  """
  INCOME_RELATED_BENEFITS

  """
  Hold a Maternity Exemption Certificate (MATEX)
  """
  MATERNITY_EXEMPTION_CERTIFICATE

  """
  Are aged 62 and over (OR in receipt of any pensioner premium)
  """
  AGE_THRESHOLD

  """
  Have a medically dependant illness (disability or mobility issue)
  """
  HAS_DISABILITY

  """
  In receipt of Adult Disability Payment (ADP)
  """
  ADULT_DISABILITY_PAYMENT

  """
  Have a dependent child under 5 (dependent child who normally resides with the applicant)
  """
  DEPENDENT_CHILD_UNDER_FIVE

  """
  Have a dependent child aged 5  16 or under 18 if in full time education (dependent child who normally resides with the applicant)
  """
  DEPENDENT_CHILD_OVER_FIVE

  """
  In receipt of the limited capability for work element of Universal Credit
  """
  LIMITED_CAPABILITY_FOR_WORK

  """
  Hold a Medical Exemption Certificate (MEDEX)
  """
  MEDICAL_EXEMPTION_CERTIFICATE

  """
  Are exempt from prescription charges (only for customers in England) or hold a HC2 certificate
  """
  PRESCRIPTION_CHARGES_EXEMPTION

  """
  Hold a valid war pension NHS exemption certificate and the prescription is for your disability
  """
  WAR_PENSION_EXEMPTION_CERTIFICATE
}

"""
An enumeration.
"""
enum Status {
  """
  Pending
  """
  PENDING

  """
  Awaiting audit
  """
  AWAITING_AUDIT

  """
  Awaiting customer evidence
  """
  AWAITING_CUSTOMER_EVIDENCE

  """
  Approved
  """
  APPROVED

  """
  Rejected
  """
  REJECTED

  """
  Withdrawn
  """
  WITHDRAWN

  """
  Approved (customer service gesture)
  """
  APPROVED_CUSTOMER_SERVICE_GESTURE
}

"""
An enumeration.
"""
enum BroaderGroupRejectionReason {
  APPLICATIONS_NOT_OPEN

  ALREADY_RECEIVED_DISCOUNT

  HAS_OPEN_APPLICATION

  HAS_CORE_GROUP_DISCOUNT

  INSUFFICIENT_EVIDENCE_PROVIDED

  NO_LONGER_ON_SUPPLY

  DUPLICATE

  NOT_IN_SCOTLAND

  BUSINESS_ACCOUNT

  NON_DOMESTIC_METER_POINT
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type WarmHomeDiscountRecordConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [WarmHomeDiscountRecordEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `WarmHomeDiscountRecord` and its cursor.
"""
type WarmHomeDiscountRecordEdge {
  """
  The item at the end of the edge
  """
  node: WarmHomeDiscountRecord

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Get details about a Warm Home Discount record.
"""
type WarmHomeDiscountRecord {
  """
  Type of account receiving the discount. Either credit the account or payment via prepay cards
  """
  accountType: WhdAccountType

  yearEnding: Int!

  """
  Which criteria was chosen for the Warm Home Discount.
  """
  qualifyingCriteria: QualifyingCriteriaOptions

  """
  Which component criteria was chosen for the Warm Home Discount.
  """
  qualifyingComponent: QualifyingComponentOptions

  """
  Amount in pence that was credited to the account as a result of the discount.
  """
  credit: Int

  """
  The tax year for which the credit was given.
  """
  taxYear: String
}

"""
An enumeration.
"""
enum WhdAccountType {
  SMART_PREPAY

  TRADITIONAL_PREPAY

  CREDIT
}

type WarmHomeDiscountEligibility {
  """
  Is the customer eligible to apply for the Warm Home Discount as part of the Scottish Broader Group.
  """
  isEligible: Boolean

  """
  Reason why the customer is unable to apply.
  """
  rejectionReason: String
}

type TrackerTariffDailyPricing {
  """
  URL for tracker demo
  """
  demoUrl: String

  """
  Today's electricity costs (in pence)
  """
  electricity: Int

  """
  Today's gas costs (in pence)
  """
  gas: Int
}

type PaymentAdequacyType {
  """
  The suggested monthly payment amount in pence following the payment adequacy review.
  """
  suggestedDirectDebitAmount: Int
}

"""
An enumeration.
"""
enum SmartMeterInterestChoices {
  """
  We have captured that this account is interested in a SMETS2 meter. This does not mean they've booked an appointment.
  """
  INTERESTED

  """
  We have captured that this account could be interested in a SMETS2 meter in the future, so it is appropriate to follow up with them.
  """
  NOT_AT_THE_MOMENT

  """
  We have captured that this account is not interested in a SMETS2 meter. We should use this to avoid advertising SMETS2 meters to them, or contacting them about installing a SMETS2 meter.
  """
  NOT_INTERESTED
}

"""
An enumeration.
"""
enum SMETS2InterestReason {
  """
  Doesn't own own home.
  """
  SMETS2_INTEREST_REASON_DO_NOT_OWN_HOME

  """
  Sceptical of technology.
  """
  SMETS2_INTEREST_REASON_TECHNOLOGY_SCEPTICAL

  """
  Worried about security.
  """
  SMETS2_INTEREST_REASON_WORRIED_SECURITY

  """
  Worried about health & safety.
  """
  SMETS2_INTEREST_REASON_WORRIED_HEALTH_SAFETY

  """
  Negative publicity about smart meters.
  """
  SMETS2_INTEREST_REASON_NEGATIVE_PUBLICITY

  """
  Worried about energy usage cost increasing.
  """
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_USAGE_COST

  """
  Already has or is about to have a smart meter installed.
  """
  SMETS2_INTEREST_REASON_ALREADY_HAS_SMART_METER

  """
  About to move house.
  """
  SMETS2_INTEREST_REASON_HOUSE_MOVE_IMMINENT

  """
  About to switch supplier.
  """
  SMETS2_INTEREST_REASON_SWITCH_IMMINENT

  """
  More information about smart meters required.
  """
  SMETS2_INTEREST_REASON_MORE_INFORMATION_REQUIRED

  """
  Is a landlord.
  """
  SMETS2_INTEREST_REASON_IS_LANDLORD

  """
  Cannot see benefit.
  """
  SMETS2_INTEREST_REASON_CANNOT_SEE_BENEFIT

  """
  Wants to wait until it's compulsory.
  """
  SMETS2_INTEREST_REASON_WAIT_UNTIL_IT_IS_COMPULSORY

  """
  Has vulnerability.
  """
  SMETS2_INTEREST_REASON_VULNERABILITY

  """
  Worried about smart meters.
  """
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_SMART_METERS

  """
  Worried about installation.
  """
  SMETS2_INTEREST_REASON_WORRIED_ABOUT_INSTALLATION

  """
  Property rarely or never occupied.
  """
  SMETS2_INTEREST_REASON_PROPERTY_NOT_OCCUPIED

  """
  Cannot attend appointment.
  """
  SMETS2_INTEREST_REASON_CANNOT_ATTEND_APPOINTMENT
}

type GreenAccomplishmentsType {
  savedTrees: Int

  savedCo2InKgs: Int
}

"""
A single accout search hit
"""
type AccountSearchItemType {
  """
  The account found.
  """
  account: AccountType

  """
  How well the account matched the search terms.
  """
  score: Decimal
}

input AccountSearchInputType {
  """
  The account number eg. A-FF15AE70.
  """
  accountNumber: String

  """
  The portfolio number eg. P-A123B456.
  """
  portfolioNumber: String

  """
  URN Number.
  """
  urn: String

  """
  The Account User ID (not account number).
  """
  user: String

  """
  Internal account id (not account number).
  """
  account: String

  """
  Statements.
  """
  statements: String

  """
  Meter Serial Number.
  """
  meterSerialNumber: String

  """
  Location (Supply or Billing, full or partial, address or post code).
  """
  location: String

  """
  Account or Billing name.
  """
  billingName: String

  """
  Business name.
  """
  businessName: String

  """
  Business identifier or number.
  """
  businessNumber: String

  """
  Account Reference.
  """
  accountReferences: String

  """
  MPAN of property.
  """
  mpan: String

  """
  MPRN of property.
  """
  mprn: String

  """
  Telephone.
  """
  telephoneNumber: String
}

"""
The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-4619: Quote with given code not found.
- KT-CT-4624: Unable to accept the given product code.
- KT-CT-4626: No product selected for the given quote code.
- KT-CT-4719: No supply point found for identifier provided.
- KT-CT-4922: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InitiateProductSwitch {
  possibleErrors: [PossibleErrorType]

  """
  The selected product for a specific product switch.
  """
  productCode: String!

  """
  The date at which the product switch becomes effective.
  """
  switchDate: Date!
}

input InitiateProductSwitchInput {
  """
  Identification of the account that requesting the product switch.
  """
  accountNumber: String!

  """
  ID of the selected quoted product, obtain from quoting that supply point.
  """
  quotedProductId: ID!

  """
  The date at which the product switch becomes effective.
  """
  switchDate: Date!
}

"""
Create a Lead instance.

The possible errors that can be raised are:

- KT-CT-8901: Unable to create lead.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateNewLead {
  possibleErrors: [PossibleErrorType]

  """
  Lead created.
  """
  lead: NewLeadType
}

type NewLeadType {
  """
  ID of the lead.
  """
  id: Int

  """
  The source where the lead comes from.
  """
  source: String

  """
  Lead phone.
  """
  phone: String

  """
  Lead email.
  """
  email: String

  """
  Lead name.
  """
  name: String

  """
  To know if the lead is domestic or business.
  """
  leadType: String
}

input NewLeadInputType {
  """
  The source where the lead comes from.
  """
  source: String

  """
  Lead phone.
  """
  phone: String

  """
  Lead email.
  """
  email: String

  """
  Lead name.
  """
  name: String

  """
  To know if the lead is domestic or business.
  """
  leadType: String

  """
  The product the lead is interested in.
  """
  marketName: String
}

"""
Publish a trigger within the transactional messaging service.

The possible errors that can be raised are:

- KT-CT-9901: Invalid trigger type code.
- KT-CT-9902: Invalid trigger type params.
- KT-CT-9903: Trigger type cannot be published externally.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type PublishTransactionalMessagingTrigger {
  possibleErrors: [PossibleErrorType]

  """
  The trigger that has been published.
  """
  trigger: TriggerType
}

type TriggerType {
  """
  The ID of the trigger.
  """
  id: String!
}

input PublishTransactionalMessagingTriggerInput {
  """
  The code of the trigger type to be published.
  """
  triggerTypeCode: String!

  """
  The params of the trigger type, as a JSON string. These are defined in the Params class for a trigger type.
  """
  params: JSONString!
}

"""
The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-9601: Invalid data.
- KT-CT-9602: Unable to create contribution agreement.
- KT-CT-9605: Contribution amount cannot be 0 or negative.
- KT-CT-9606: Scheme is not accepting contributions at this time.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateContributionAgreement {
  possibleErrors: [PossibleErrorType]

  """
  The created contribution agreement.
  """
  contributionAgreement: ContributionAgreementType
}

input CreateContributionAgreementInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The code of the scheme to contribute to.
  """
  schemeCode: String!

  """
  The frequency of contributions.
  """
  interval: Interval!

  """
  The amount contributed per interval. Note, this is in the smallest domination that the currency supports. e.g. Pence, Cents, Yen, etc.
  """
  amount: Int!

  """
  The start datetime of the agreement.
  """
  activeFrom: DateTime!

  """
  The end datetime of the agreement, if any.
  """
  activeTo: DateTime
}

"""
The possible errors that can be raised are:

- KT-CT-9603: Unable to find contribution agreement.
- KT-CT-4123: Unauthorized.
- KT-CT-9604: Unable to end contribution agreement.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type EndContributionAgreement {
  possibleErrors: [PossibleErrorType]

  """
  The created contribution agreement.
  """
  contributionAgreement: ContributionAgreementType
}

input EndContributionAgreementInput {
  """
  The ID of the Contribution Agreement to end.
  """
  contributionAgreementId: ID!

  """
  The future end datetime of the agreement. If not given, terminate now.
  """
  endAt: DateTime
}

"""
Redeem Loyalty Points as account credit.

The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-9201: No Loyalty Point ledger found for the user.
- KT-CT-9202: Loyalty Points adapter not configured.
- KT-CT-9203: No ledger entries for the ledger.
- KT-CT-9205: Insufficient Loyalty Points.
- KT-CT-9206: Indivisible points.
- KT-CT-9204: Negative or zero points set.
- KT-CT-9208: Invalid posted at datetime.
- KT-CT-9209: Negative Loyalty Points balance.
- KT-CT-9210: Unhandled Loyalty Points exception.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RedeemLoyaltyPointsForAccountCredit {
  possibleErrors: [PossibleErrorType]

  """
  The number of OctoPoints that were redeemed.
  """
  pointsRedeemed: Int
}

"""
The input type for redeeming Loyalty Points.
"""
input RedeemLoyaltyPointsInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The number of Loyalty Points to redeem.
  """
  points: Int!
}

"""
Transfer Loyalty Points between users.

The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-9205: Insufficient Loyalty Points.
- KT-CT-9204: Negative or zero points set.
- KT-CT-9208: Invalid posted at datetime.
- KT-CT-9209: Negative Loyalty Points balance.
- KT-CT-9210: Unhandled Loyalty Points exception.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type TransferLoyaltyPointsBetweenUsers {
  possibleErrors: [PossibleErrorType]

  """
  The number of OctoPoints that were transferred.
  """
  pointsTransferred: Int
}

"""
The input type for transferring Loyalty Points.
"""
input TransferLoyaltyPointsBetweenUsersInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The account user receiving the points.
  """
  receivingUserId: String!

  """
  The number of Loyalty Points to transfer.
  """
  points: Int!
}

"""
Set the Loyalty Points user for the account.

The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-1111: Unauthorized.
- KT-CT-9210: Unhandled Loyalty Points exception.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetLoyaltyPointsUser {
  possibleErrors: [PossibleErrorType]

  """
  ID of the new Loyalty Points user.
  """
  newLoyaltyPointsUserId: String
}

"""
The input type for setting the Loyalty Points user.
"""
input SetLoyaltyPointsUserInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The account user receiving the points.
  """
  newLoyaltyPointsUserId: String!
}

"""
Use a referral code to create a referral and trigger a referral reward.

The possible errors that can be raised are:

- KT-CT-6723: Unauthorized.
- KT-CT-6710: Unable to create referral.
- KT-CT-6711: Accounts may not self-refer.
- KT-CT-6713: Referring and referred account brands do not match.
- KT-CT-6712: Invalid reference.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateReferral {
  possibleErrors: [PossibleErrorType]

  """
  The reward amount to be issued to the referred account, in smallest currency subunits.
  """
  referredAccountRewardAmount: Int
}

"""
Required information for creating a referral
"""
input CreateReferralInput {
  """
  The account number for the referred account.
  """
  accountNumber: String!

  """
  An email address, link or code, referencing the referring account.
  """
  reference: String!
}

"""
The possible errors that can be raised are:

- KT-CT-6723: Unauthorized.
- KT-CT-6724: Referral claim code not found.
- KT-CT-6725: Referral claim code redeeming error.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RedeemReferralClaimCode {
  possibleErrors: [PossibleErrorType]
}

"""
Required payload to redeem the benefit for partner reward referral scheme
"""
input RedeemReferralClaimCodeInput {
  """
  The account number for the referred account.
  """
  accountNumber: String!

  """
  Referral scheme claim code value.
  """
  code: String!
}

"""
Create a new portfolio.

The possible errors that can be raised are:

- KT-CT-9402: Received an invalid brandCode.
- KT-CT-9401: Received an invalid operationsTeamId.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreatePortfolio {
  possibleErrors: [PossibleErrorType]

  """
  The created portfolio.
  """
  portfolio: PortfolioType
}

input CreatePortfolioInput {
  """
  The brand to associate with this portfolio, if not provided the default brand will be used.
  """
  brandCode: String = "OCTOPUS_ENERGY"

  """
  The ID of the operations team to associate with this portfolio.If no team is provided, no team will be assigned to the portfolio.
  """
  operationsTeamId: ID

  """
  Whether collective bills should be issued for the portfolio's accounts. The default value is False.
  """
  collectiveBilling: Boolean = false
}

"""
Close the Open Print Batch if any.

The possible errors that can be raised are:

- KT-CT-9010: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CloseOpenPrintBatch {
  possibleErrors: [PossibleErrorType]

  printBatch: PrintBatchType
}

"""
Mark a closed print batch as Processed

The possible errors that can be raised are:

- KT-CT-9011: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type MarkPrintBatchAsProcessed {
  possibleErrors: [PossibleErrorType]

  printBatch: PrintBatchType
}

"""
Create a Loyalty Card for the given account user.

The possible errors that can be raised are:

- KT-CT-5412: No account user exists with the given id.
- KT-CT-8610: Invalid data.
- KT-CT-8611: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateOrUpdateLoyaltyCardMutation {
  possibleErrors: [PossibleErrorType]

  """
  Created or updated loyalty card.
  """
  loyaltyCard: LoyaltyCardType
}

input CreateOrUpdateLoyaltyCardInput {
  """
  The id of the account user.
  """
  accountUserId: String

  """
  The scheme of the loyalty card.
  """
  scheme: String

  """
  The number of the loyalty card.
  """
  number: String
}

union LinkUserToLineResponse = LineLinkRedirectResponse|LinkTokenNotFound|AlreadyLinkedError

"""
Link Successful. Complete link process with LINE.
"""
type LineLinkRedirectResponse {
  redirectUrl: String!
}

"""
Returned when no LineAccountLink record matching the parameters exists.
"""
type LinkTokenNotFound {
  """
  The type of error that occurred.
  """
  type: LineLinkErrorType!
}

enum LineLinkErrorType {
  NO_MATCHING_LINE_LINK

  ALREADY_LINKED
}

"""
Returned when an account already has a LINE account linked to it.
"""
type AlreadyLinkedError {
  """
  The type of error that occurred.
  """
  type: LineLinkErrorType!
}

"""
Link an AccountUser to a LINE account.
"""
input LinkUserToLineInput {
  linkToken: String!
}

union UnlinkUserFromLineResponse = LineUnlinkedResponse|LinkTokenNotFound|LineCommonError

type LineUnlinkedResponse {
  message: String!
}

"""
A base error type. Should be used for general application or lower level errors.
"""
type LineCommonError {
  """
  The error message to display to the user.
  """
  message: String!

  """
  The field that for which this error should be associated
  """
  field: String
}

"""
Termination was successfully initiated.
"""
type LeaveSupplierInstigated {
  """
  The ID of the newly created or existing leave supplier process.
  """
  leaveSupplierProcessId: ID!

  """
  The message to display to the user on termination initiation.
  """
  message: String!
}

input LeaveSupplierInput {
  """
  The Kraken account number.
  """
  accountNumber: String!

  """
  The requested last day of supply.
  """
  requestedSupplyEndDate: Date!

  marketData: LeaveSupplierMarketInputType
}

input LeaveSupplierMarketInputType {
  """
  A list of supply points for initiating a leave supplier journey.
  """
  supplyPointData: [_DefaultMarketTerminationInput]
}

"""
Default input required to initiate a LeaveSupplier journey for a given market.
This type should only be used when there are no configured markets while building
the LeaveSupplierMarketInputType.
"""
input _DefaultMarketTerminationInput {
  """
  The market supply point identification number.
  """
  supplyPointIdentifier: String!
}

"""
Output of a LeaveSupplier journey cancellation.
"""
type LeaveSupplierCancelled {
  """
  The message to display to the user on cancellation.
  """
  message: String!
}

"""
Input required to cancel a LeaveSupplier journey.
"""
input CancelLeaveSupplierInput {
  """
  The ID of the LeaveSupplier process to cancel.
  """
  leaveSupplierProcessId: ID!

  """
  The reason for the cancellation.
  """
  reason: String
}

type PrepareAccountResult {
  """
  Was a new account created.
  """
  isNewAccount: Boolean

  """
  The account number of the newly created account or the existing account to be re-used.
  """
  accountNumber: String

  """
  Was a new user created.
  """
  isNewUser: Boolean

  """
  The ID of the newly created or existing account user.
  """
  userId: ID
}

input PrepareAccountInput {
  """
  The type of account to create.
  """
  accountType: AccountTypeChoices = DOMESTIC

  """
  The brand of the created account.
  """
  brandCode: String!

  """
  The billing name.
  """
  billingName: String!

  """
  The billing address.
  """
  billingAddress: LifecycleAddressInput!

  """
  The customer's details.
  """
  customerDetails: CustomerDetailsInput!

  """
  Sales information.
  """
  salesInfo: SalesInformationInput!

  """
  The preferred supply start date.
  """
  preferredSsd: Date

  """
  The date of sale, defaults to today if not provided.
  """
  dateOfSale: Date

  """
  The chosen payment day.
  """
  chosenPaymentDay: Int
}

input LifecycleAddressInput {
  """
  Line 1 of address.
  """
  line1: String!

  """
  Postal code.
  """
  postalCode: String!

  """
  Country code.
  """
  countryCode: String

  """
  Line 2 of address.
  """
  line2: String = ""

  """
  Line 3 of address.
  """
  line3: String = ""

  """
  Line 4 of address.
  """
  line4: String = ""

  """
  Line 5 of address.
  """
  line5: String = ""
}

"""
Details about the customer.
"""
input CustomerDetailsInput {
  """
  Given name.
  """
  givenName: String!

  """
  Family name.
  """
  familyName: String!

  """
  The customer's title.
  """
  title: String

  """
  The customer's pronouns.
  """
  pronouns: String

  """
  Account email.
  """
  email: String

  """
  Account mobile phone number.
  """
  mobile: String

  """
  Account landline number.
  """
  landline: String

  """
  The customer's date of birth.
  """
  dateOfBirth: Date

  """
  The customer's communication preferences.
  """
  preferences: UpdateAccountUserCommsPreferencesInput = null
}

input UpdateAccountUserCommsPreferencesInput {
  isOptedInToClientMessages: Boolean

  isOptedInToOfferMessages: Boolean

  isOptedInToRecommendedMessages: Boolean

  isOptedInToUpdateMessages: Boolean

  isOptedInToThirdPartyMessages: Boolean

  emailFormat: EmailFormats

  isUsingInvertedEmailColours: Boolean

  fontSizeMultiplier: Float

  isOptedInMeterReadingConfirmations: Boolean

  isOptedInToSmsMessages: Boolean

  preferredHoldMusic: Songs
}

"""
Information about the sale to associate with the account.
"""
input SalesInformationInput {
  """
  Sales channel.
  """
  salesChannel: String!

  """
  Sales subchannel.
  """
  salesSubchannel: String

  """
  Unique reference number.
  """
  urn: String

  """
  Unique reference number.
  """
  affiliateSubdomain: String

  """
  Unique reference number.
  """
  affiliateParams: String
}

"""
Create an affiliate link for a new sales agent.

The possible errors that can be raised are:

- KT-CT-7711: Invalid data.
- KT-CT-7713: Invalid data.
- KT-CT-7714: Invalid data.
- KT-CT-7715: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAffiliateLink {
  possibleErrors: [PossibleErrorType]

  affiliateLink: AffiliateLinkType
}

input CreateAffiliateLinkInputType {
  """
  The organisation for whom to create the affiliate link for.
  """
  organisationId: ID!

  """
  Will be validated as follows:

  - should be at least two characters
  - should only contain (letters, numbers, and Hyphen)
  - should not contain bad words
  - should not contain any of the reserved words including:
   affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2
  """
  subdomain: String!

  contactName: String!

  contactEmail: String!
}

"""
Update an affiliate link of an existing sales agent.

The possible errors that can be raised are:

- KT-CT-7711: Invalid data.
- KT-CT-7713: Invalid data.
- KT-CT-7714: Invalid data.
- KT-CT-7715: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAffiliateLink {
  possibleErrors: [PossibleErrorType]

  affiliateLink: AffiliateLinkType
}

input UpdateAffiliateLinkInputType {
  """
  The id of the affiliate link that is going to be edited.
  """
  linkId: ID!

  """
  The organisation for whom to update the affiliate link for.
  """
  organisationId: ID

  """
  Will be validated as follows:

  - should be at least two characters
  - should only contain (letters, numbers, and Hyphen)
  - should not contain bad words
  - should not contain any of the reserved words including:
   affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2
  """
  subdomain: String

  contactName: String

  contactEmail: String

  isBusiness: Boolean

  landingUrl: String

  trainingStatus: String
}

"""
Create an affiliate organisation.

The possible errors that can be raised are:

- KT-CT-7716: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAffiliateOrganisation {
  possibleErrors: [PossibleErrorType]

  affiliateOrganisation: AffiliateOrganisationType
}

input CreateAffiliateOrganisationInputType {
  name: String!

  """
  Sales Channel
  """
  salesChannel: SalesChannelChoices!

  """
  Default Account Type
  """
  defaultAccountType: AccountTypeChoices!

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """
  Allow registration requests with customers without an email address.
  """
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """
  Allow performing tariff renewals via API.
  """
  canRenewTariffs: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""
Update an affiliate organisation.

The possible errors that can be raised are:

- KT-CT-7717: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAffiliateOrganisation {
  possibleErrors: [PossibleErrorType]

  affiliateOrganisation: AffiliateOrganisationType
}

input UpdateAffiliateOrganisationInputType {
  """
  The organisation that is going to be edited.
  """
  organisationId: ID!

  name: String

  """
  Sales Channel
  """
  salesChannel: SalesChannelChoices = null

  """
  Default Account Type
  """
  defaultAccountType: AccountTypeChoices = null

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """
  Allow registration requests with customers without an email address.
  """
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """
  Allow performing tariff renewals via API.
  """
  canRenewTariffs: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""
Create a session for an affiliate link.
"""
type CreateAffiliateSession {
  affiliateSession: AffiliateSessionType
}

"""
A tracked session for the affiliate link.
"""
type AffiliateSessionType {
  id: ID!

  ipAddress: String

  userAgent: String!

  queryParams: JSONString!

  link: AffiliateLinkType
}

input CreateAffiliateSessionInputType {
  """
  The affiliate link for whom to create the session for.
  """
  linkId: ID!

  """
  The IP Address of the user.
  """
  ipAddress: String

  """
  The HTTP user agent.
  """
  userAgent: String

  """
  Additional query parameters to attach to this session.
  """
  queryParams: JSONString

  """
  The quote share that led to this session.
  """
  quoteShareId: ID
}

"""
Validate whether a user's email is a valid email via the Kickbox API.
"""
type ValidateEmail {
  """
  Whether the email is valid or not.
  """
  isValid: Boolean
}

"""
Input required to validate email address via Kickbox
"""
input ValidateEmailInput {
  """
  The user's email address.
  """
  email: String!

  """
  Check if an email is already in use.
  """
  checkUniqueness: Boolean = false
}

"""
Validate whether a user's phone number is a valid phone number.
"""
type ValidatePhone {
  """
  Whether the phone number is valid or not.
  """
  isValid: Boolean
}

input ValidatePhoneNumberInput {
  """
  The user's phone number.
  """
  phoneNumber: String!
}

"""
Returns an Action to perform, e.g. a screen to load.

BackendScreenEvents are specific types of Action which trigger a mutation in the Kraken backend.
They return an action (any type), such as a ScreenActionType (which is then used to load the next screen).
Any action registered in the registry should really be an "event" with some side-effect in the backend.

The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-8002: No event found.
- KT-CT-8003: Event has no execute function.
- KT-CT-8004: Error executing event in the backend.
- KT-CT-8007: Incorrect or missing parameters for backend screen event.
- KT-GB-9310: Account ineligible for joining Octoplus.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type BackendScreenEvent {
  possibleErrors: [PossibleErrorType]

  """
  An action to perform.
  """
  action: ActionType
}

"""
Input for a backend action.
"""
input BackendScreenEventInput {
  """
  The ID of the action to perform.
  """
  eventId: ID!

  """
  List of key-value pairs (strings) to pass as parameters to the mutation.
  """
  params: [BackendScreenParamInputType]
}

"""
The possible errors that can be raised are:

- KT-CT-5514: Unable to submit feedback.
- KT-CT-5511: The feedback_id should be provided for feedback source.
- KT-CT-5512: The feedback doesn't match the account.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type SubmitCustomerFeedback {
  possibleErrors: [PossibleErrorType]

  customerFeedback: CustomerFeedbackType
}

type CustomerFeedbackType {
  id: ID!

  """
  The value attached to the source
  """
  rawScore: Int

  """
  The datetime the feedback was submitted
  """
  submittedAt: DateTime
}

input CustomerFeedbackInputType {
  answer: String

  issueResolved: Boolean!

  formId: Int!

  feedbackId: Int!

  accountNumber: String!
}

"""
Mutation for executing the repayment request use case.

The possible errors that can be raised are:

- KT-CT-1132: Unauthorized.
- KT-CT-3927: Invalid Amount.
- KT-CT-3928: Idempotency key used for another repayment request.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SubmitRepaymentRequest {
  possibleErrors: [PossibleErrorType]

  """
  The newly created repayment request.
  """
  repaymentRequest: RequestRepaymentOutputType
}

"""
Output for creating a repayment request.
"""
type RequestRepaymentOutputType {
  """
  The ID of the repayment request.
  """
  requestId: String

  """
  The current status of the repayment request.
  """
  status: RepaymentRequestStatus
}

input RequestRepaymentInputType {
  """
  The account number for the requested ledger's account.
  """
  accountNumber: String!

  """
  The ledger id from which the repayment will be requested.
  """
  ledgerId: String!

  """
  The amount to be repaid.
  """
  amountInMinorUnit: Int!

  """
  The method by which the money will be transferred to the customer.
  """
  method: RequestableRepaymentMethod = null

  """
  Unique constraint to prevent duplicate requests.
  """
  idempotencyKey: String!

  """
  The reason for the repayment.
  """
  reason: String
}

"""
An enumeration.
"""
enum RequestableRepaymentMethod {
  BANK_TRANSFER

  CHEQUE
}

"""
Cancel a repayment or refund request.

The possible errors that can be raised are:

- KT-CT-4231: Unauthorized.
- KT-CT-3930: The repayment or refund request does not exist.
- KT-CT-3931: This repayment or refund request cannot be cancelled.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type CancelRepaymentRequest {
  possibleErrors: [PossibleErrorType]

  """
  The cancelled repayment/refund request.
  """
  repaymentRequest: CancelRepaymentRequestOutputType
}

"""
Output from cancelling a repayment or refund request.
"""
type CancelRepaymentRequestOutputType {
  """
  The ID of the cancelled request.
  """
  requestId: String

  """
  The current status of the cancelled request.
  """
  status: RepaymentRequestStatus
}

input CancelRepaymentRequestInputType {
  """
  The id of the request to be cancelled.
  """
  requestId: String!
}

"""
Allow a repayment to be submitted.

The possible errors that can be raised are:

- KT-CT-3944: Account repayment does not exist.
- KT-CT-3945: Unable to allow a repayment to be submitted.
- KT-CT-3950: The provided reason text is too long.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type AllowRepaymentSubmission {
  possibleErrors: [PossibleErrorType]

  """
  The repayment ID.
  """
  repaymentId: ID

  """
  Resulting Repayment Intervention details.
  """
  repaymentIntervention: RepaymentInterventionType
}

type RepaymentInterventionType {
  """
  The repayment intervention outcome.
  """
  outcome: String

  """
  The repayment intervention reason.
  """
  reason: String
}

"""
Input fields for Repayment Intervention.
"""
input RepaymentInput {
  """
  The repayment ID.
  """
  repaymentId: ID!

  """
  The Repayment Intervention reason.
  """
  reason: String
}

"""
Block a repayment from being submitted.

The possible errors that can be raised are:

- KT-CT-3944: Account repayment does not exist.
- KT-CT-3946: Unable to block a repayment from being submitted.
- KT-CT-3950: The provided reason text is too long.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type BlockRepaymentSubmission {
  possibleErrors: [PossibleErrorType]

  """
  The repayment ID.
  """
  repaymentId: ID

  """
  Resulting Repayment Intervention details.
  """
  repaymentIntervention: RepaymentInterventionType
}

"""
The possible errors that can be raised are:

- KT-CT-3934: Repayment request already approved.
- KT-CT-3935: Repayment request cannot be paid.
- KT-CT-3959: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ApproveRepayment {
  possibleErrors: [PossibleErrorType]

  """
  The approved repayment.
  """
  repayment: AccountRepaymentType
}

input ApproveRepaymentInput {
  """
  The account number for the requested repayment.
  """
  accountNumber: ID!

  """
  The id of the account repayment to be approved.
  """
  repaymentId: ID!
}

"""
Collect deposit for the given account.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-5711: No collection is required.
- KT-CT-5712: Deposit agreement does not exist or has not been accepted.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CollectDeposit {
  possibleErrors: [PossibleErrorType]

  payment: CollectDepositOutput
}

type CollectDepositOutput {
  status: CollectDepositStatusChoices

  paymentDate: Date
}

enum CollectDepositStatusChoices {
  APPROVED

  CLEARED

  CANCELLED

  HELD_FOR_REVIEW

  FAILED

  PENDING

  REQUESTED

  SCHEDULED

  NONE
}

input CollectDepositInput {
  accountNumber: String!

  depositKey: String!

  idempotencyKey: String!
}

"""
Record the customer's acceptance of a deposit agreement.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type RecordDepositAgreementAccepted {
  possibleErrors: [PossibleErrorType]

  isRecorded: Boolean
}

input DepositAgreementInput {
  accountNumber: String!

  depositKey: String!
}

"""
Create a new deposit agreement for the account if it needs one.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateDepositAgreement {
  possibleErrors: [PossibleErrorType]

  depositAgreement: CreateDepositAgreementOutput
}

type CreateDepositAgreementOutput {
  depositRequired: Boolean

  depositAmount: Int
}

input CreateDepositAgreementInput {
  accountNumber: String!

  depositKey: String!

  reason: String!
}

"""
Initiate a standalone payment and return the client secret required to complete it.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-3943: Invalid ledger.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InitiateStandalonePayment {
  possibleErrors: [PossibleErrorType]

  payment: InitiateStandalonePaymentOutput
}

"""
Tokens required to collect and retrieve a standalone payment.
"""
type InitiateStandalonePaymentOutput {
  """
  The retrieval token for this standalone payment.
  """
  retrievalToken: String!

  """
  The secret used to collect the payment.
  """
  secretToken: String!
}

"""
Input fields for initiating a standalone payment.

The amount should always be provided in the minor unit of currency (e.g., pence not pounds,
cents not dollars, etc.).

A standalone payment can be made against a specific ledger (e.g., a debt ledger) by
providing the ledger id. Accounts have a default ledger that will be used if not provided.
"""
input InitiateStandalonePaymentInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The amount to be collected in the minor unit of currency.
  """
  amount: Int!

  """
  A description of the purpose of the payment.
  """
  description: String!

  """
  The method by which the payment is being collected.
  """
  collectionMethod: CollectionMethod = null

  """
  The id of the specific ledger against which this payment should be applied.
  """
  ledgerId: ID
}

enum CollectionMethod {
  CARD

  DIRECT_DEBIT
}

"""
Initiate a standalone payment and return the client secret required to complete it.

The possible errors that can be raised are:

- KT-CT-1128: Unauthorized.
- KT-CT-3822: Unauthorized.
- KT-CT-3943: Invalid ledger.
- KT-CT-3957: No collection method provided.
- KT-CT-3958: Provide either ledger ID or ledger number.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InitiateHostedStandalonePayment {
  possibleErrors: [PossibleErrorType]

  """
  The details required to refer to and complete a hosted payment.
  """
  payment: InitiateHostedStandalonePaymentOutput
}

"""
Tokens required to collect and retrieve a standalone payment.
"""
type InitiateHostedStandalonePaymentOutput {
  """
  The retrieval token for this standalone payment.
  """
  retrievalToken: String!

  """
  The url for the customer to complete the payment.
  """
  url: String!
}

"""
Input fields for initiating a hosted standalone payment.

The amount should always be provided in the minor unit of currency (e.g., pence not pounds,
cents not dollars, etc.).

A standalone payment can be made against a specific ledger (e.g., a debt ledger) by
providing the ledger id. Accounts have a default ledger that will be used if not provided.
"""
input InitiateHostedStandalonePaymentInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The amount to be collected in the minor unit of currency.
  """
  amount: Int!

  """
  A description of the purpose of the payment.
  """
  description: String!

  """
  The method by which the payment is being collected.
  """
  collectionMethod: CollectionMethod!

  """
  The number of the specific ledger against which this payment should be applied. Please provide either ledger number or ID.
  """
  ledgerNumber: String

  """
  The id of the specific ledger against which this payment should be applied. Please provide either ledger number or ID.
  """
  ledgerId: ID

  """
  The URL to redirect the user to after the action was completed successfuly.
  """
  returnUrlSuccess: String

  """
  The URL to redirect the user to after the action was completed but the payment is still being processed.
  """
  returnUrlPending: String

  """
  The URL to redirect the user to after the action resulted in a failure.
  """
  returnUrlFailure: String

  """
  The URL to redirect the user to after the action resulted in an error.
  """
  returnUrlError: String

  """
  The URL to redirect the user to after the action was cancelled.
  """
  returnUrlCancel: String

  """
  The URL to redirect the user to if the url is not longer valid.
  """
  returnUrlExpired: String
}

"""
Get the client secret needed to create a new payment instruction using an embedded form.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type GetEmbeddedSecretForNewPaymentInstruction {
  possibleErrors: [PossibleErrorType]

  secretKey: String
}

"""
The input for getting the client secret for an embedded new card payment method form.
"""
input GetEmbeddedSecretForNewPaymentInstructionInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The type of the new payment instruction.
  """
  instructionType: PaymentType!

  """
  **WARNING: Will be mandatory in future versions**

   The ledger ID.
  """
  ledgerId: String
}

"""
Store a new payment instruction created through the embedded process.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type StorePaymentInstruction {
  possibleErrors: [PossibleErrorType]

  """
  The stored payment instruction.
  """
  paymentInstruction: PaymentInstructionType
}

"""
The input for storing a new payment instruction created through the embedded process.
"""
input StorePaymentInstructionInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The type of the new payment instruction.
  """
  instructionType: PaymentType!

  """
  The datetime from which the instruction is vaild.
  """
  validFrom: DateTime!

  """
  The vendor's reference for this payment method.
  """
  vendorReference: String!

  """
  **WARNING: Will be mandatory in future versions**

   The ledger ID to which the instructions will be linked.
  """
  ledgerId: String
}

"""
Get external URL where the user can set up a payment instruction.

The possible errors that can be raised are:

- KT-CT-1128: Unauthorized.
- KT-CT-3822: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type GetHostedUrlForNewPaymentInstruction {
  possibleErrors: [PossibleErrorType]

  """
  URL at which payment instruction can be set up.
  """
  url: String
}

"""
The input needed for getting the external URL for setting up a payment instruction.
"""
input GetHostedUrlForNewPaymentInstructionInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The ledger number.
  """
  ledgerNumber: String!

  """
  The type of the new payment instruction.
  """
  instructionType: PaymentType!

  """
  The URL to redirect the user to after the action was completed successfuly.
  """
  returnUrlSuccess: String

  """
  The URL to redirect the user to after the action resulted in a failure.
  """
  returnUrlFailure: String

  """
  The URL to redirect the user to after the action resulted in an error.
  """
  returnUrlError: String

  """
  The URL to redirect the user to after the action was cancelled.
  """
  returnUrlCancel: String
}

"""
Invalidates a payment instruction.

The possible errors that can be raised are:

- KT-CT-3926: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InvalidatePaymentInstruction {
  possibleErrors: [PossibleErrorType]

  instruction: InvalidatePaymentInstructionOutput
}

"""
Output for invalidating an arbitrary payment instruction.
"""
type InvalidatePaymentInstructionOutput {
  id: Int
}

"""
Input for invalidating an arbitrary payment instruction.
"""
input InvalidatePaymentInstructionInput {
  accountNumber: String!

  """
  The id of the payment instruction to be invalidated.
  """
  id: String!
}

"""
The possible errors that can be raised are:

- KT-CT-3940: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type SetUpDirectDebitInstruction {
  possibleErrors: [PossibleErrorType]

  paymentInstruction: DirectDebitInstructionType
}

input SetUpDirectDebitInstructionInput {
  accountNumber: String!

  ledgerId: ID!

  validFrom: DateTime!

  bankDetails: BankDetailsInput!
}

input BankDetailsInput {
  accountHolder: String

  iban: String

  accountNumber: String

  bankCode: String

  branchCode: String

  accountType: String
}

"""
The possible errors that can be raised are:

- KT-CT-3932: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CollectPayment {
  possibleErrors: [PossibleErrorType]

  """
  Details about the collected payment. Note that we might not be able to collect the payment (e.g. if there is no usable payment instruction), in which case the status of the returned payment might be failed or cancelled.
  """
  payment: AccountPaymentType
}

input CollectPaymentInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The payment amount (in pence).
  """
  amount: Int!

  """
  The date to attempt to take the payment. Cannot be a date in the past. Payment will be collected on the requested date or as soon as possible after that date.
  """
  paymentDate: Date!

  """
  The reason a payment is being collected, for internal audit purposes
  """
  description: String!

  idempotencyKey: String!

  """
  The type of the payment instruction.
  """
  collectionMethod: PaymentType = null

  """
  The ID of the ledger on which to collect the payment.
  """
  ledgerId: ID!
}

"""
The possible errors that can be raised are:

- KT-CT-3924: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type AmendPayment {
  possibleErrors: [PossibleErrorType]

  payment: AccountPaymentType
}

input AmendPaymentInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The ID of the payment to amend.
  """
  paymentId: Int!

  """
  The new amount for the amended payment.
  """
  amount: Int!

  """
  The new date to collect the payment.
  """
  paymentDate: Date!

  """
  Reason for amending the payment.
  """
  reason: String
}

"""
The possible errors that can be raised are:

- KT-CT-3815: No active payment schedule found for this account.
- KT-CT-3941: Invalid data.
- KT-CT-3942: An unexpected error occurred.
- KT-CT-3947: An unexpected error occurred.
- KT-CT-3953: The payment schedule is not a balance triggered schedule.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAutoTopUpAmount {
  possibleErrors: [PossibleErrorType]

  """
  The new schedule created.
  """
  schedule: PaymentScheduleType
}

"""
Input type for updating the schedule auto top up amount for for an account. Requires an `account_number`, ledger_id and `payment_amount` to be provided.
"""
input UpdateAutoTopUpAmountInput {
  """
  Account number to update the schedule auto top up amount for.
  """
  accountNumber: String!

  """
  Specifies the ledger ID associated with the current schedule for updates.
  """
  ledgerId: Int!

  """
  The new auto-top-up amount for the payment schedule.
  """
  paymentAmount: Int!
}

"""
The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-3815: No active payment schedule found for this account.
- KT-CT-3822: Unauthorized.
- KT-CT-3923: Unauthorized.
- KT-CT-3941: Invalid data.
- KT-CT-3942: An unexpected error occurred.
- KT-CT-3947: An unexpected error occurred.
- KT-CT-3960: Invalid value for payment day.
- KT-CT-3961: Cannot update plan-associated payment schedule.
- KT-CT-3962: No new value provided to update payment schedule.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAccountPaymentSchedule {
  possibleErrors: [PossibleErrorType]

  """
  New payment schedule.
  """
  schedule: PaymentScheduleType!
}

"""
Input type for updating the payment schedule on a ledger. Requires an `account_number`, `ledger_id` and one of `payment_day` or `payment_amount` to be provided.
"""
input CreateAccountPaymentScheduleInput {
  """
  Number of the account for which to update the schedule.
  """
  accountNumber: String!

  """
  Number of the ledger associated with the current payment schedule.
  """
  ledgerNumber: String!

  """
  The new day of the month at which to take payment; ranges from 1 to 28.
  """
  paymentDay: Int

  """
  The new fixed payment amount.
  """
  paymentAmount: Int
}

"""
The possible errors that can be raised are:

- KT-CT-3924: Unauthorized.
- KT-CT-3954: Payment cancellation failed.
- KT-CT-3955: Payment cannot be cancelled.
- KT-CT-3956: Temporary error occurred.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CancelPayment {
  possibleErrors: [PossibleErrorType]

  """
  The cancelled payment.
  """
  payment: AccountPaymentType
}

input CancelPaymentInput {
  """
  The account number.
  """
  accountNumber: ID!

  """
  The ID of the payment to cancel.
  """
  paymentId: ID!

  """
  Reason for cancelling the payment.
  """
  reason: String
}

"""
The possible errors that can be raised are:

- KT-CT-3924: Unauthorized.
- KT-CT-3928: Idempotency key used for another repayment request.
- KT-CT-3929: The payment is not in a refundable state.
- KT-CT-3933: Refund amount greater than payment amount.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type RefundPayment {
  possibleErrors: [PossibleErrorType]

  """
  The repayment for the requested refund.
  """
  repayment: AccountRepaymentType
}

input RefundPaymentInput {
  """
  The account number.
  """
  accountNumber: ID!

  """
  The ID of the payment to refund.
  """
  paymentId: ID!

  """
  The amount to be repaid.
  """
  amountInMinorUnit: Int!

  """
  Unique constraint to prevent duplicate requests.
  """
  idempotencyKey: String!

  """
  Reason for refunding the payment.
  """
  reason: String!
}

type AssignInkBucketPayload {
  """
  The conversation that will be assigned to the bucket.
  """
  conversation: InkConversation!

  """
  The bucket that the conversation will be assigned to.
  """
  bucket: InkBucket!

  clientMutationId: String
}

input AssignInkBucketInput {
  """
  The relay id of the conversation that will be assigned to the bucket.
  """
  conversationRelayId: ID!

  """
  The name of the bucket to assign the conversation to.
  """
  bucketName: String!

  clientMutationId: String
}

type UpdateMessageTagsPayload {
  """
  Confirmed tags.
  """
  tags: [InkTag!]!

  clientMutationId: String
}

input UpdateMessageTagsInput {
  """
  The message to set the tags on.
  """
  messageRelayId: ID!

  """
  The tag names to set on the message.
  """
  tagNames: [String!]!

  """
  The tag code to set on the message.
  """
  taggerCode: String!

  """
  The tag version to set on the message.
  """
  taggerVersion: String!

  clientMutationId: String
}

"""
Register an Ink inbound message.
"""
type CreateInkInboundMessagePayload {
  """
  The Ink message that was created.
  """
  message: InkMessage!

  clientMutationId: String
}

input CreateInkInboundMessageInput {
  channel: InkCommunicationChannel!

  """
  An arbitrary, unique ID for this message.

  This must be unique for each message that is supplied
  using the same organisation; collisions between messages
  provided by different organisations are tolerated.

  Stored as vendor_id.
  """
  messageId: String!

  newMessage: InkMessageInput!

  """
  An optional vendor value to denote which system it originated from.

  If no vendor is passed, we will get the default generic vendor from
  the setting called INK_DEFAULT_GENERIC_MESSAGE_API_VENDOR.
  """
  vendor: String

  """
  An optional parameter where we can pass the generic message headers if it has one

  Email channel tries to get the value `conversation-relay-id` from this
  parameter
  """
  messageHeaders: JSONString

  """
  When the message occurred in the system of origin.
  """
  occurredAt: DateTime

  clientMutationId: String
}

"""
An Ink message used as an input.

This is intended to be morally equivalent to a tagged union; exactly
one of the properties provided here is expected to be provided.

At current, only the generic message type is provided, because only
the generic message type is currently supported as an input type.
This is intended to be a backwards-compatible extension point to
allow other message input types to be added in the future.
"""
input InkMessageInput {
  generic: InkGenericMessageInput

  email: InkEmailMessageInput

  post: InkPostMessageInput
}

"""
This type is used to create an generic message.
"""
input InkGenericMessageInput {
  """
  The content of the message, as plain text.
  """
  plainTextContent: String!

  """
  Message attachments.
  """
  attachments: [InkGenericMessageAttachmentInput!]

  """
  The identity the message was sent from.
  """
  fromHandle: String!

  """
  The identity the message was sent to.
  """
  toHandle: String!
}

input InkGenericMessageAttachmentInput {
  """
  The S3 key of the attachment.
  """
  s3Key: String!

  """
  The S3 bucket of the attachment.
  """
  s3Bucket: String!
}

"""
This type is used to create an inbound email.
"""
input InkEmailMessageInput {
  """
  The content of the message, as plain text.
  """
  plainTextContent: String!

  """
  Message attachments.
  """
  attachments: [InkGenericMessageAttachmentInput!]

  """
  The email subject/title.
  """
  subject: String!

  """
  The email address the message was sent from.
  """
  fromAddress: Email!

  """
  The email addresses the message was sent to.
  """
  toAddresses: [Email!]!

  """
  The carbon copy (cc) email addresses the message was sent to.
  """
  ccAddresses: [Email!]

  """
  The S3 bucket in which the original email is stored.
  """
  s3Bucket: String

  """
  The S3 key of the original email.
  """
  s3Key: String
}

scalar Email

"""
This type is used to create an inbound post.
"""
input InkPostMessageInput {
  """
  The content of the message, as plain text.
  """
  plainTextContent: String!

  """
  Message attachments.
  """
  attachments: [InkGenericMessageAttachmentInput!]

  """
  The account number that the letter was sent from.
  """
  accountNumber: String

  """
  Notes on the letter.
  """
  notes: String
}

"""
The possible errors that can be raised are:

- KT-CT-7620: Channel not supported.
- KT-CT-7618: Unable to process message.
- KT-CT-7624: Error when generating the presigned URL.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type GenerateInkPresignedUrl {
  possibleErrors: [PossibleErrorType]

  """
  A presigned URL for the user to upload to the quarantine bucket.
  """
  uploadUrl: String!

  """
  Presigned post fields; key, awsAccessKeyId, xAmzSecurityToken, policy, signature.
  """
  presignedPostFields: PresignedPostFields @deprecated(reason: "Replaced in favor of fields.")

  """
  The key for the item.
  """
  key: String!

  """
  Presigned post fields required to upload the file.
  """
  fields: JSONString!
}

"""
Fields returned by generate_presigned_post.
"""
type PresignedPostFields {
  """
  The S3 bucket key.
  """
  key: String!

  """
  The AWS access key ID.
  """
  awsAccessKeyId: String!

  """
  The AMZ security token.
  """
  xAmzSecurityToken: String!

  """
  The S3 policy.
  """
  policy: String!

  """
  AWS Signature Version 4 Authentication.
  """
  signature: String!
}

input GenerateInkPresignedUrlInput {
  """
  The channel of the contact.
  """
  channel: InkCommunicationChannel!

  """
  The name of the file.
  """
  filename: String!
}

"""
The possible errors that can be raised are:

- KT-CT-8202: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateGoodsQuote {
  possibleErrors: [PossibleErrorType]

  """
  Goods quote created for the customer.
  """
  goodsQuote: GoodsQuote
}

input CreateGoodsQuoteInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  Products to get a quote for.
  """
  productsToQuote: [ProductToQuoteInput]!

  """
  A JSON object containing client parameters to store on the quote.
  """
  clientParams: GenericScalar
}

"""
Represents a product and the quantity to quote for a customer.
"""
input ProductToQuoteInput {
  """
  ID of the product to quote.
  """
  productId: Int!

  """
  Number of units.
  """
  numberOfUnits: Int!

  """
  Price per unit in smallest sub-unit of the currency.
  """
  pricePerUnit: Int

  """
  Currency.
  """
  currency: String!
}

"""
The possible errors that can be raised are:

- KT-CT-8202: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateGoodsQuoteWithoutAccount {
  possibleErrors: [PossibleErrorType]

  """
  Goods quote created for the customer.
  """
  goodsQuote: GoodsQuote
}

input CreateGoodsQuoteWithoutAccountInput {
  """
  Customer profile.
  """
  customerProfile: CustomerProfileInput!

  """
  Products to get a quote for.
  """
  productsToQuote: [ProductToQuoteInput]!

  """
  A JSON object containing client parameters to store on the quote.
  """
  clientParams: GenericScalar
}

input CustomerProfileInput {
  """
  Customer's given name.
  """
  givenName: String!

  """
  Customer's family name.
  """
  familyName: String!

  """
  Customer's email.
  """
  email: String!

  """
  Customer's phone number.
  """
  phoneNumber: String!

  """
  Customer's postcode.
  """
  postcode: String!

  """
  Line 1 of customer's address.
  """
  addressLine1: String!

  """
  Line 2 of customer's address.
  """
  addressLine2: String

  """
  Line 3 of customer's address.
  """
  addressLine3: String

  """
  Line 4 of customer's address.
  """
  addressLine4: String

  """
  Line 5 of customer's address.
  """
  addressLine5: String
}

"""
The possible errors that can be raised are:

- KT-CT-8223: Unauthorized.
- KT-CT-8201: Received an invalid quoteId.
- KT-CT-8224: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type AcceptGoodsQuote {
  possibleErrors: [PossibleErrorType]

  """
  Goods purchase created.
  """
  goodsPurchase: GoodsPurchase
}

input AcceptGoodsQuoteInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  ID of the accepted quote.
  """
  quoteId: Int!

  """
  A JSON object containing client parameters to store on the quote.
  """
  clientParams: JSONString

  """
  A JSON object containing market parameters to store on the purchase.
  """
  marketParams: JSONString
}

"""
The possible errors that can be raised are:

- KT-CT-4122: Invalid email.
- KT-CT-8203: Received an invalid quote code.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type ShareGoodsQuote {
  possibleErrors: [PossibleErrorType]

  """
  Goods quote shared.
  """
  share: GoodsQuoteShare
}

type GoodsQuoteShare {
  """
  The ID of the quote share.
  """
  id: Int
}

input ShareGoodsQuoteInput {
  """
  The quote to share.
  """
  quoteCode: String!

  """
  The email to share the quote with.
  """
  email: String!
}

"""
The possible errors that can be raised are:

- KT-CT-8206: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateGoodsPurchase {
  possibleErrors: [PossibleErrorType]

  """
  Goods purchase created.
  """
  goodsPurchase: GoodsPurchase
}

input CreatePurchaseInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  Products being purchased.
  """
  saleItems: [ProductToPurchaseInput]!

  """
  A JSON object containing client parameters to store on the quote.
  """
  clientParams: JSONString

  """
  A JSON object containing client parameters to store on the purchase.
  """
  marketParams: JSONString
}

input ProductToPurchaseInput {
  """
  Products code to purchase.
  """
  productCode: String!

  """
  Number of units.
  """
  numberOfUnits: Int!
}

"""
The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type VerifyEmail {
  possibleErrors: [PossibleErrorType]

  """
  Whether the email is verified.
  """
  isVerified: Boolean
}

input VerifyEmailInput {
  """
  Token string that will be used to verify the email.
  """
  token: String!
}

"""
The possible errors that can be raised are:

- KT-CT-1401: Invalid data.
- KT-CT-1402: Unable to create account reminder.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAccountReminder {
  possibleErrors: [PossibleErrorType]

  """
  Account reminder.
  """
  accountReminder: AccountReminder
}

type AccountReminder {
  """
  The reminder type.
  """
  reminderType: AccountReminderTypes

  """
  Reminder content.
  """
  content: String

  """
  When the reminder is due.
  """
  dueAt: DateTime
}

"""
Contains reminder type choices for all territories.
"""
enum AccountReminderTypes {
  AD_HOC

  DUNNING_REMINDER

  WITHDRAWAL_RECEIVED

  CHURN_PREVENTION

  PLANNED_INTERRUPTION

  PLANNED_INTERRUPTION_MEDICAL_DEPENDENCY

  MOVE_IN_MOVE_OUT_MANUAL_PROCESS

  MOVE_IN_CES_LIFE_SUPPORT_REQUIRED

  MOVE_IN_DEFAULT_PAYMENT_SCHEDULE_FAILED

  CANCEL_MOVE_OUT_UNABLE_TO_REINSTATE_FUTURE_AGREEMENTS

  SMETS2_DATA_REQUEST_FOLLOWUP

  COS_GAIN

  COS_LOSS

  MOVE_IN

  MOVE_OUT

  AMPERAGE_CHANGE

  CUSTOMER_DETAILS_CHANGE

  BILLING

  INDUSTRY_CUSTOMER_TRANSFER_DELAYED

  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_REJECTED

  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_CANCELLED

  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_OBJECTED

  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_CONFLICTING_PERIOD

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTED

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_REJECTED

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_CANCELLED

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_MISSING_ACK

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_WITHDRAWAL_REJECTED

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_REJECTED

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_OBJECTION_WITHDRAWAL_REJECTED

  INDUSTRY_EXCEPTION_UNABLE_TO_PROCESS_ROLR

  INDUSTRY_EXCEPTION_CHANGE_OF_SUPPLIER_GAIN_COMPLETION_OVERDUE

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_COMPLETED

  INDUSTRY_EXCEPTION_CHANGE_REQUEST_CANCELLATION_FAILED

  INDUSTRY_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_REJECTED

  INDUSTRY_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE

  INDUSTRY_MANUAL_CUSTOMER_DETAILS_NOTIFICATION_REQUIRED

  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE

  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_MISSING_MANDATORY_FIELDS

  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_INVALID_BILLING_ADDRESS

  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_REQUEST_SPECIAL_REASON

  INDUSTRY_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_REJECTED

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_MULTIPLE_ACCOUNTS_MATCHES

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_MULTIPLE_LIFE_SUPPORT_CONTACT_MATCHES

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_FAILED_TO_SEND

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_UNKNOWN_CONTACT

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_INVALID_PHONE

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_INVALID_CONTACT_METHOD

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_RECEIVED_FROM_NON_REGISTRATION_OWNER

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_CONTAINS_UNEXPECTED_DATA

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_REJECTED

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_REJECTED

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_MISSING_BUSINESS_ACCEPTANCE

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_MISSING_BUSINESS_ACCEPTANCE

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_REQUEST_MISSING_LIFE_SUPPORT_NOTIFICATION

  INDUSTRY_EXCEPTION_LIFE_SUPPORT_CONTACT_USER_REMOVED_FROM_ACCOUNT

  INDUSTRY_MANUAL_ACTION_REQUIRED

  INDUSTRY_MANUAL_LIFE_SUPPORT_NOTIFICATION_REQUIRED

  INDUSTRY_VIC_DRO_MANUAL_LIFE_SUPPORT_EXTENSION_REQUEST

  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_SERVICE_ORDER_ALREADY_IN_PROGRESS

  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_UNABLE_TO_COPY_LAST_METER_READING

  INDUSTRY_EXCEPTION_HOUSE_MOVE_ENROLMENT_CANNOT_CALCULATE_MOVE_IN_READING

  INDUSTRY_EXCEPTION_METER_POINT_ENROLMENT_INCOMPLETE_COULD_NOT_SEND_SERVICE_ORDER

  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_INCOMPLETE_COULD_NOT_SEND_CHANGE_REQUEST

  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_NEXT_SCHEDULED_READ_DATE_PAST

  INDUSTRY_EXCEPTION_RELINKING_OCCURRED_DURING_SDR_SYNC

  INDUSTRY_SEND_LIFE_SUPPORT_DE_REGISTRATION_FORM

  INDUSTRY_LIFE_SUPPORT_MANUAL_BEST_ENDEAVOUR_REQUIRED

  INDUSTRY_LIFE_SUPPORT_REVIEW_DEREGISTRATION

  INDUSTRY_LIFE_SUPPORT_REVIEW_POST_DEREGISTRATION_COMMS

  INDUSTRY_LIFE_SUPPORT_REVIEW_POST_DEREGISTRATION

  INDUSTRY_LIFE_SUPPORT_CANCEL_DEREGISTRATION_FAILED

  INDUSTRY_LIFE_SUPPORT_REGISTRATION_FOLLOW_UP_REQUIRED

  INDUSTRY_LIFE_SUPPORT_REVIEW_AFTER_CANCELLED_MOVE_OUT_FOR_NEXT_ACCOUNT

  INDUSTRY_LIFE_SUPPORT_REVIEW_ATTEMPTED_CANCELLED_MOVE_OUT_FOR_NEXT_ACCOUNT

  INDUSTRY_UNABLE_TO_CREATE_RECORD

  INDUSTRY_CHANGE_OF_SUPPLIER_DOUBLE_GAIN

  INDUSTRY_METER_POINT_MISSING_CUSTOMER_CLASSIFICATION

  INDUSTRY_READINGS_NOT_SENT

  INDUSTRY_WARNING_MESSAGE_RECEIVED

  SERVICE_ORDER_ACKNOWLEDGEMENT_OVERDUE

  SERVICE_ORDER_INITIAL_RESPONSE_OVERDUE

  SERVICE_ORDER_NOT_COMPLETED

  SERVICE_ORDER_CANCELLATION_REQUEST_REJECTED

  SERVICE_ORDER_PARTIALLY_COMPLETED

  SERVICE_ORDER_UNABLE_TO_CHARGE

  SERVICE_ORDER_REQUEST_REJECTED

  SERVICE_ORDER_UNSOLICITED_RECEIVED

  SERVICE_ORDER_UNSOLICITED_RECEIVED_DEENERGISED_METER_POINT

  SERVICE_ORDER_FAILED

  SERVICE_ORDER_CANCELLATION_FAILED

  SERVICE_ORDER_OTHER_JOB_ENQUIRY_CODE

  SMARTFLEX_DEVICE_INTEGRATION_POSTPONED

  SPECIAL_READ_FAILED

  SPECIAL_READ_CANCELLATION_FAILED

  SPECIAL_READ_OUTSTANDING

  SPECIAL_READ_WITH_ESTIMATE_READ_RECEIVED

  NETWORK_TARIFF_ONE_WAY_NOTIFICATION

  METER_EXCHANGE_ONE_WAY_NOTIFICATION

  METER_FAULT_AND_ISSUE_ONE_WAY_NOTIFICATION_ACCEPTED

  METER_FAULT_AND_ISSUE_ONE_WAY_NOTIFICATION_REJECTED

  NOTICE_OF_METERING_WORKS_ONE_WAY_NOTIFICATION

  SMETS2_HEALTH_CHECK

  SMETS2_IHD_HEALTH_CHECK

  CUSTOMER_REPORTED_SMART_METER_ISSUES

  D0010_CREATION_FAILURE

  ACCOUNT_COOL_OFF

  D0052_CREATION_FAILURE

  D0205_CREATION_FAILURE

  PLANNED_INTERRUPTION_ONE_WAY_NOTIFICATION

  PLANNED_INTERRUPTION_ONE_WAY_NOTIFICATION_REJECTED

  PLANNED_INTERRUPTION_NOTIFICATION_SENT_TO_LIFE_SUPPORT_CUSTOMER

  FIELDWORKS_ALLOCATE_NMI_MARKET_PARTICIPANTS_NOT_SET

  FIELDWORKS_BULK_DEPLOYMENT_JOURNEY_AUTO_CANCELLED

  FIELDWORKS_METER_FAULT_JOURNEY_AUTO_CANCELLED

  FIELDWORKS_MULTIPLE_OPEN_JOURNEYS_FOR_METER_POINT

  FIELDWORKS_UPLOAD_ATTACHMENT_TO_JEMENA_PORTAL

  FIELDWORKS_OBTAIN_SUPPLY_ABOLISHMENT_APPROVAL

  FIELDWORKS_JOURNEY_CANCELLED_DUE_TO_LIFE_SUPPORT_REGISTRATION

  FIELDWORKS_METER_FAULT_RECEIVED

  FIELDWORKS_MIRN_DISCOVERY_FAILED

  FIELDWORKS_CHANGE_RETAILER_FAILED

  FIELDWORKS_SERVICE_ORDER_PARTIALLY_COMPLETED

  FIELDWORKS_SERVICE_ORDER_FAILED

  COS_GAIN_REL_RETRIEVAL_FAILURE

  INDUSTRY_EXCEPTION_UNABLE_TO_ENROL_METER_POINT_INVALID_NMI_METER_STATUS

  FIELDWORKS_JOURNEY_ATTACHMENTS

  FIELDWORKS_SERVICE_ORDER_ATTACHMENTS

  FIELDWORKS_SERVICE_ORDER_STATUS_UPDATED

  FIELDWORKS_SERVICE_ORDER_COMPLETED

  FIELDWORKS_SERVICE_ORDER_UNABLE_TO_ACCESS_WITH_CUSTOMER_CONSULTATION

  FIELDWORKS_METER_FAULT_NCOM_COMMS_FAILED

  FIELDWORKS_MOVE_OUT_CANCELLED_WHILE_SUPPLY_ABOLISHMENT_IN_PROGRESS

  FIELDWORKS_SUPPLY_PERIOD_DOES_NOT_EXIST_FOR_METERPOINT

  FIELDWORKS_METERPOINT_IS_NOT_ACTIVE

  FIELDWORKS_EXPECTED_METER_POINT_NOT_CREATED

  FIELDWORKS_NEW_CONNECTION_DATA_NOT_VALID

  FIELDWORKS_NEW_CONNECTION_COMPLETION_REVIEW

  FIELDWORKS_EXPECTED_METER_READ_NOT_RECEIVED

  FIELDWORKS_EXPECTED_NTCS_NOT_RECEIVED

  FIELDWORKS_CONTACT_SO_RECIPIENT_TO_UPDATE_THE_SO_DETAILS

  FIELDWORKS_INVESTIGATE_WHETHER_JOURNEY_NEEDS_CONTINUATION

  FIELDWORKS_ASSIGN_METERING_COORDINATOR_STEP_FAILED

  FIELDWORKS_ASSIGN_METERING_PROVIDER_STEP_FAILED

  FIELDWORKS_OBTAIN_CUSTOMER_APPROVAL_BEFORE_PROGRESSING

  FIELDWORKS_MANUALLY_COMPLETE_CUSTOMER_MOVE_IN

  FIELDWORKS_ACCOUNT_CREATED_WITH_NO_EMAIL_ADDRESS

  FIELDWORKS_MAINTAIN_REGISTER_BILLABLE_OVERRIDE_FOR_UNSOLICITED_METER_CHANGES

  AUS_EMBEDDED_WATER_READING_FAILURE

  AUS_EMBEDDED_WATER_ESTIMATION_REQUIRED_FOR_SKIPPED_READING

  AUS_VIC_SHAREDFUSE_NOTIFICATION

  AUS_INDUSTRY_CUSTOMER_OWN_READING_NOT_SENT

  JPN_SUPPLY_DETAILS_UPDATE_CONFIRMATION

  JPN_READINGS_NOT_RECEIVED

  JPN_FINAL_READING_OUTSIDE_AGREEMENT

  JPN_CONFIRMATION_OF_RELOCATION

  JPN_SHORT_TERM_MOVE_IN_REJECTION

  JPN_SUPPLY_POINT_FAILS_CAN_SUPPLY_CHECK

  JPN_CALL_FOR_DUNNING_CAMPAIGN

  JPN_CONFIRM_PAYMENT_FOR_DUNNING_CAMPAIGN

  NZ_SOLAR_METER_CHANGE

  NZ_DUNNING

  NZ_SWITCHING_WITHDRAWAL

  NZ_BILLING_QUERY

  NZ_VACANT_PROPERTY

  NZ_METERING_QUERY

  DUNNING_OUTBOUND_REMINDER_CALL

  DUNNING_BEST_ENDEAVOURS_CALL

  DUNNING_DISCONNECTION_OUTBOUND_REMINDER_CALL

  DUNNING_DISCONNECTION_DE_ENERGISATION_ASSESSMENT

  DUNNING_MANDATORY_NOTICE_EMAIL_FAILURE

  DUNNING_DISCONNECTION_MANDATORY_NOTICE_EMAIL_FAILURE

  DUNNING_VACANT_CONSUMPTION_DE_ENERGISATION_ASSESSMENT

  DUNNING_REMINDER_CALL

  DUNNING_REMINDER_DISCONNECTION_APPLICATION

  DUNNING_REMINDER_PAYMENT_MADE

  DUNNING_REMINDER_FUTURE_PAYMENT

  NON_ENERGY_PAYMENT_CALL_REMINDER

  PAYMENTS_FAILED_REPAYMENT

  PAYMENT_PLAN

  PAYMENT_PLAN_MISSED_INSTALMENT

  ACTIVATE_PAYMENT_CANCELLATION_STOPPED

  POST_HARDSHIP_CANCELLATION

  PAYMENT_PLAN_HARDSHIP_COMPLETION

  PAYMENT_PLAN_HARDSHIP_COMPLETION_WORKFLOW_CANCELLED

  HARDSHIP_GRADUATION_ASSESSMENT

  HARDSHIP_REMOVAL_ASSESSMENT

  PAYMENT_INSTRUCTION_FAILED

  HARDSHIP_NO_PAYMENT_PLAN

  DISCONNECTION_MANDATORY_NOTICE_EMAIL_FAILURE

  DISCONNECTION_MANDATORY_NOTICE_SMS_FAILURE

  INDUSTRY_EXCEPTION_STANDING_DATA_PROPERTIES_ADDRESS_FAILED_TO_UPDATE

  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_TERMINATE

  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_CREATE

  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_UPDATE

  MARKET_SUPPLY_EXCEPTION_MISSING_ACCOUNT_QUOTED_PRODUCT

  MARKET_SUPPLY_EXCEPTION_AGREEMENT_FAILED_TO_REVERSE_TERMINATION

  GAS_EXCEPTION_SITE_ACCESS_DETAILS_RECEIVED_FOR_NON_EXISTENT_METER

  GAS_EXCEPTION_CUSTOMER_DETAILS_NOTIFICATION_FAILED

  GAS_EXCEPTION_LIFE_SUPPORT_NOTIFICATION_FAILED

  GAS_EXCEPTION_SITE_ACCESS_DETAILS_NOTIFICATION_FAILED

  GAS_EXCEPTION_SITE_ADDRESS_DETAILS_NOTIFICATION_FAILED

  GAS_EXCEPTION_METER_DATA_VERIFY_REQUEST_FAILED

  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_OVERDUE

  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_NO_CHANGE_WITH_EXPLANATION

  GAS_EXCEPTION_METER_DATA_VERIFY_RESPONSE_WITHOUT_REVISED_READ

  GAS_NOTIFICATION_CHANGE_OF_SITE_ADDRESS

  INDUSTRY_EXCEPTION_NEXT_SCHEDULED_READ_DATE_TOO_FAR_IN_FUTURE

  GAS_EXCEPTION_CUSTOMER_TRANSFER_CANCELLED

  GAS_EXCEPTION_CUSTOMER_TRANSFER_REJECTED

  GAS_MANUAL_SERVICE_ORDER_REQUIRED_FOR_ENROLMENT

  GAS_READING_REMOVED_INSTALLED_RECEIVED

  GAS_UNKNOWN_CUSTOMER_CLASSIFICATION_CODE_RECEIVED

  BILLING_AMENDED_METER_READ_BASIC

  BILLING_AMENDED_METER_READ_GAS

  BILLING_AMENDED_METER_READ_INTERVAL_LEGACY

  BILLING_AMENDED_METER_READ_INTERVAL

  BILLING_AMENDED_METER_READ_PRE_MIGRATION

  BILLING_AMENDED_METER_READ_CES_ELEC_BASIC

  BILLING_AMENDED_METER_READ_CES_ELEC_INTERVAL

  BILLING_REGISTER_REPLACED_OR_REMOVED

  OBSOLETE_BILLING_AMENDED_STANDING_DATA_REGISTER_DELETED

  OBSOLETE_BILLING_AMENDED_STANDING_DATA_REGISTER_CHANGED

  BILLING_CUSTOMER_SELF_READ_RECEIVED

  BILLING_MISSING_READ

  SA_CONCESSION_STATEMENT_CLOSED

  BILLING_BACKDATED_CONCESSION_RECEIVED

  BILLING_BACKDATED_UMS_RECORD_RECEIVED

  BILLING_AMENDED_INTERVAL_DATA_RECEIVED_CAUSING_OVERCHARGE

  BILLING_QUOTED_NTC_DOES_NOT_ALIGN

  FINAL_BILLING_UNABLE_TO_BILL

  MANDATORY_COMMS_NOT_DELIVERED

  CONTRACT_COMMS_NOT_DELIVERED

  MOVE_IN_COMMS_NOT_DELIVERED

  SMART_PREPAY_TOP_UP_UTRN

  SMART_PREPAY_TOP_UP_MULTIPLE_ACTIVE_PROCESSES

  SMART_PREPAY_TOP_UP_FAILURE

  SMART_PREPAY_ADD_DEBT_FAILURE

  SMART_PREPAY_NEED_TO_ADJUST_DEBT

  SMART_METER_MODE_CHANGE_UNSUPPORTED

  HELD_STATEMENT

  AUTOMATED_BILLING_DISABLED

  SOLAR_EXPORT_CREDITS_EXCESS

  ASSIGNED_TO_CREDIT_TEAM

  WORKFLOW_STEP_FAILED

  WORKFLOW_STEP_ERRORED

  WORKFLOW_CANCELLATION_FAILED

  KMT

  SOLR_FINAL_BILL_REMINDER

  COS_GAIN_MIGRATION_ECOES_METER_MISMATCH

  ACCOUNT_MIGRATION_SYNC_XOSERVE_METER_MISMATCH

  SMART_CHANGE_OF_TENANCY_REQUEST_FAILED

  SMART_CHANGE_OF_TENANCY_IN_PROGRESS

  AGREEMENT_REVOKED

  UNSUPPORTED_PAYMENT_DAY

  UNSUPPORTED_FEATURE

  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_LOST_OR_LOSING

  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_RECEIVED_LIFE_SUPPORT_NOTIFICATION

  EMBEDDED_NETWORK_EXCEPTION_PARENT_METER_POINT_RECEIVED_DANGEROUS_LIFE_SUPPORT_NOTIFICATION

  EMBEDDED_NETWORK_EXCEPTION_DISTRIBUTOR_OWNED_PARENT_LIFE_SUPPORT_RECORD

  EMBEDDED_NETWORK_ALL_CHILD_LIFE_SUPPORT_RECORDS_ARE_DEREGISTERED

  SCHEDULED_BILLING_ADDRESS_UPDATE

  SCHEDULED_OCCUPIER_PACK_SEND

  PROPERTY_ADDRESS_NEEDS_UPDATE

  FRA_ACTIVATION_PROCESS_INCEPTION_CHECKS

  FRA_ACTIVATION_PROCESS_SCHEDULE_SITEWORKS

  FRA_ACTIVATION_PROCESS_GAS_PROVIDER_CHANGE_REQUEST

  FRA_ACTIVATION_PROCESS_PRM_ELIGIBILITY

  FRA_ACTIVATION_PROCESS_AWAITING_SWITCH_READINGS

  FRA_ELEC_ACTIVATION_PROCESS_WRONG_SWITCH_READINGS_FOR_PROVIDER_CALENDAR_TEMPORAL_CLASSES

  FRA_ACTIVATION_PROCESS_COMMANDER_SOUSCRIPTION

  FRA_ACTIVATION_PROCESS_AWAITING_SWITCH_IN_CONFIRMATION

  FRA_TERMINATION_REQUEST_ERRORED

  FRA_ENERGY_CHEQUE_UNKNOWN

  FRA_FSL

  COMMS_TO_BE_PRINTED

  FLOW_FILE_ERROR

  NEW_PSR_ADDED_TO_PREPAY_ACCOUNT

  PSR_IMPORT_COULD_NOT_IDENTIFY_ACCOUNT_USER

  MAIL_RETURNED

  MAIL_FAILED

  DUPLICATE_CARD_FINGERPRINTs

  WATER_METER_READING_ISSUE

  WATER_ACCOUNT_REVERSION

  DEU_SWICHTING_PROCESS_FAILED

  DEU_METER_READINGS
}

input CreateAccountReminderInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The reminder type.
  """
  reminderType: AccountReminderTypes!

  """
  Reminder content.
  """
  content: String!

  """
  When the reminder is due.
  """
  dueAt: DateTime!
}

"""
Create an account reference.

The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-8310: Invalid data.
- KT-CT-8311: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAccountReference {
  possibleErrors: [PossibleErrorType]

  accountReference: AccountReferenceType
}

"""
The input type for the account reference.
"""
input AccountReferenceInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The namespace for the reference.
  """
  namespace: String!

  """
  The reference value.
  """
  value: String!
}

"""
Update a reference for a particular account and namespace.

The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-8310: Invalid data.
- KT-CT-8311: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAccountReference {
  possibleErrors: [PossibleErrorType]

  accountReference: AccountReferenceType
}

"""
Delete a reference for a particular account and namespace.

The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-8310: Invalid data.
- KT-CT-8312: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type DeleteAccountReference {
  possibleErrors: [PossibleErrorType]

  accountReference: DeleteAccountReferenceType
}

type DeleteAccountReferenceType {
  """
  The namespace associated with the removed AccountReference
  """
  namespace: String!
}

input DeleteAccountReferenceInput {
  """
  The account number associated with the removed AccountReference.
  """
  accountNumber: String!

  """
  The namespace associated with the removed AccountReference
  """
  namespace: String!
}

"""
Create an external account event.

The possible errors that can be raised are:

- KT-CT-7123: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateExternalAccountEvent {
  possibleErrors: [PossibleErrorType]

  """
  The new event data.
  """
  event: ExternalAccountEvent
}

type ExternalAccountEvent {
  id: ID!

  eventType: String!

  category: String!

  subcategory: String!

  description: String

  content: JSONString
}

input CreateExternalAccountEventInput {
  """
  The number of the account that the event should be created for.
  """
  accountNumber: String!

  """
  The category of the event.
  """
  category: ExternalAccountEventCategory!

  """
  The subcategory of the event.
  """
  subcategory: ExternalAccountEventSubCategory

  """
  A human-readable description of the event.
  """
  description: String

  """
  An array of content data associated with the event.
  """
  content: [ExternalAccountEventContent]!
}

"""
Enum of allowable event type categories for external account events.
"""
enum ExternalAccountEventCategory {
  COMMUNICATIONS

  WEB

  MOBILE

  MESSAGING

  DEBT
}

"""
Enum of allowable event type subcategories for external account events.
"""
enum ExternalAccountEventSubCategory {
  TELEPHONE

  EMAIL

  SMS

  PRINT

  PUSH_NOTIFICATION

  SOCIAL_MEDIA

  FEEDBACK

  WHATSAPP

  CLICK_TO_CALL

  DUNNING
}

"""
A piece of content associated with an external account event.
"""
input ExternalAccountEventContent {
  """
  A human-readable description of the content.
  """
  description: String!

  """
  The content type of the content.
  """
  contentType: ExternalAccountEventContentType!

  """
  The value of the content.
  """
  value: String!
}

"""
Enum of allowable content types for external account events.

The content type field is used to determine how to display the content in the account event
description.
"""
enum ExternalAccountEventContentType {
  PLAINTEXT

  LINK

  HTML

  S3
}

"""
Add credits to an account.

The possible errors that can be raised are:

- KT-CT-5315: Invalid data.
- KT-CT-5314: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAccountCredit {
  possibleErrors: [PossibleErrorType]

  accountCredit: AccountCreditType
}

"""
The input type for the account credit.
"""
input CreateAccountCreditInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The net amount of the credit to be created.
  """
  netAmount: Int!

  """
  The gross amount of the credit to be created.
  """
  grossAmount: Int!

  """
  The sales tax amount of the credit to be created.
  """
  salesTaxAmount: Int!

  """
  Any extra data that will be associated with account credit.
  """
  metadata: JSONString

  """
  Optional short note about account credit.
  """
  note: String

  """
  The reason why the credit is added to the account.
  """
  reason: AccountCreditReasonType!
}

"""
The possible errors that can be raised are:

- KT-CT-5316: Invalid data.
- KT-CT-5311: The credit reason with the requested code is deprecated.
- KT-CT-5312: The credit reason with the requested code does not exist.
- KT-CT-5313: An error occurred whilst posting the credit.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type PostCredit {
  possibleErrors: [PossibleErrorType]

  """
  Posted account credit.
  """
  credit: Credit
}

input PostCreditInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The net amount of the credit to be posted. Amount should be posted in the smallest unit of currency.
  """
  netAmount: Int!

  """
  The tax amount of the credit to be posted. Amount should be posted in the smallest unit of currency.
  """
  taxAmount: Int!

  """
  Optional short note about the credit, to be displayed to the user.
  """
  displayNote: String

  """
  Optional short note about the credit, to be displayed to internal systems.
  """
  note: String

  """
  The reason why the credit is posted. This should be a valid credit reason code.
  """
  reason: String!

  """
  The ID of the ledger where the credit will be posted.
  """
  ledgerId: ID!
}

"""
Add charges to an account.

The possible errors that can be raised are:

- KT-CT-5211: The charge reason with the requested code is deprecated.
- KT-CT-5212: The charge reason with the requested code does not exist.
- KT-CT-5213: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAccountCharge {
  possibleErrors: [PossibleErrorType]

  accountCharge: AccountChargeType
}

"""
The input type for the account charge.
"""
input CreateAccountChargeInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The net amount of the charge to be added.
  """
  netAmount: Int @deprecated(reason: "The 'netAmount' field is deprecated.\n\nThe net amount will be calculated automatically by the gross amount.\n\n- Marked as deprecated on 2022-10-18.\n- Will be removed on 2024-01-01.")

  """
  The gross amount of the charge to be added.
  """
  grossAmount: Int!

  """
  The sales tax amount of the charge to be added.
  """
  salesTaxAmount: Int @deprecated(reason: "The 'salesTaxAmount' field is deprecated.\n\nThe sales tax amount will be calculated automatically by the gross amount.\n\n- Marked as deprecated on 2022-10-18.\n- Will be removed on 2024-01-01.")

  """
  The climate change levy amount of the charge to be added.
  """
  cclAmount: Int @deprecated(reason: "The 'cclAmount' field is deprecated.\n\nCCL amount should not be passed in by the API.\n\n- Marked as deprecated on 2022-10-18.\n- Will be removed on 2024-01-01.")

  """
  Any extra data that will be associated with account charge.
  """
  metadata: JSONString

  """
  Optional short note about account charge for internal use.
  """
  note: String

  """
  Optional short note about account charge for customer display.
  """
  displayNote: String

  """
  The reason why the charge is added to the account. This should be a valid charge reason code.
  """
  reason: String!
}

"""
Trigger balance transfer between accounts.

The possible errors that can be raised are:

- KT-CT-3822: Unauthorized.
- KT-CT-3823: Unauthorized.
- KT-CT-9701: Balance transfer to same account is not allowed.
- KT-CT-9702: Balance transfer is not support for debit account with Zero balance.
- KT-CT-9703: Balance transfer is not supported for debit account.
- KT-CT-9704: Balance transfer amount should be non-zero.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type TransferLedgerBalance {
  possibleErrors: [PossibleErrorType]

  """
  Balance transfer details.
  """
  balanceTransfer: AccountBalanceTransferType
}

type AccountBalanceTransferType {
  """
  Balance transfer ID.
  """
  id: ID

  """
  Debit details.
  """
  accountCharge: AccountChargeType

  """
  Credit details.
  """
  accountCredit: AccountCreditType

  """
  The reason for the balance transfer.
  """
  reason: String
}

input TransferLedgerBalanceInputType {
  """
  Account's ledger from which the requested amount is debited.
  """
  sourceAccountLedger: AccountLedgerInput!

  """
  Account's ledger to which the requested amount is credited.
  """
  targetAccountLedger: AccountLedgerInput!

  """
  The amount ( in lowest unit ) to transfer. If the amount is negative,the effect is reversed  (the source ledger's balance increases and the destination ledger's balance decreases).
  """
  amount: Int!

  """
  Optional short note about transfer reason.
  """
  note: String
}

input AccountLedgerInput {
  """
  The account number.
  """
  accountNumber: ID!

  """
  The ledger id for the account.
  """
  ledgerId: ID!
}

type FormSubmissionOuput {
  id: Int

  content: JSONString

  errors: [SerializerFieldErrorsType]
}

type SerializerFieldErrorsType {
  field: String

  errors: [ErrorTypeUnion!]
}

union ErrorTypeUnion = SerializerErrorType|SerializerFieldErrorsType

type SerializerErrorType {
  message: String

  code: String
}

input FormSubmissionInput {
  accountNumber: String!

  """
  Form type
  """
  formType: FormType = null

  """
  Form content
  """
  content: JSONString!
}

"""
An enumeration.
"""
enum FormType {
  """
  Covid-19 Financial Energy Assessment
  """
  COVID_19_FINANCIAL_ENERGY_ASSESSMENT

  """
  Covid-19 Gas Prices Financial Energy Assessment
  """
  COVID_19_GAS_PRICES_FINANCIAL_ENERGY_ASSESSMENT
}

type MasqueradeAuthentication {
  """
  A Kraken Token that can be used to authenticate to the API, masquerading as the desired user.
  """
  token: String

  """
  A list of any errors that occurred while running this mutation.
  """
  errors: [ErrorType]
}

"""
Mutation to generate a pre-signed token.

The pre-signed, expiring and opaque tokens will be swapped
for a limited scope JWT (Kraken Token).

The possible errors that can be raised are:

- KT-CT-1128: Unauthorized.
- KT-CT-1120: The Kraken Token has expired.
- KT-CT-1131: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type GeneratePreSignedToken {
  possibleErrors: [PossibleErrorType]

  token: String

  tokenExpiryDatetime: DateTime

  scope: PreSignedTokenScope
}

"""
    Choices class for the pre-signed expiring tokens.

    These choices must have a certain format:

    {ACTION-VERB}_{DEFINING-NOUN}

    They should start with an action verb. It should be a single word.
    The action verb enables the account user to do the thing (defining noun)
    that comes after the action verb. Together they represent a task.

    The defining noun could be longer than a single word.
    Preferably, it should be kept short and simple as much as possible.
    
"""
enum PreSignedTokenScope {
  """
  Scope that enables account user to submit meter readings.
  """
  SUBMIT_METER_READINGS

  """
  Scope that enables account user to submit customer feedback.
  """
  SUBMIT_CUSTOMER_FEEDBACK

  """
  Scope that enables account user to book smart meter appointments.
  """
  BOOK_SMART_METER_APPOINTMENTS

  """
  Edit Customer Marketing Preference
  """
  EDIT_CUSTOMER_MARKETING_PREFERENCE

  """
  Scope that enables account user to join campaigns.
  """
  JOIN_CAMPAIGNS

  """
  Scope that enables account user to join campaign events.
  """
  JOIN_CAMPAIGN_EVENTS

  """
  Scope that enables account user to visit campaign dashboard.
  """
  VIEW_CAMPAIGN_DASHBOARDS

  """
  Scope that enables account user to visit detailed property usage pages.
  """
  VIEW_DETAILED_USAGE

  """
  Scope that enables account user to redeem loyalty points
  """
  REDEEM_LOYALTY_POINTS

  """
  Scope that enables account user to generate a renewal quote and renew agreements.
  """
  MANAGE_ACCOUNT_RENEWALS

  """
  Scope that enables account user to checkout a quote (validate terms & conds and provide a payment detail).
  """
  CHECKOUT_QUOTE

  """
  Scope that enables account user to update their blackhole email address.
  """
  UPDATE_BLACKHOLE_EMAIL

  """
  Update Sensitive Customer Information
  """
  UPDATE_SENSITIVE_CUSTOMER_INFORMATION

  """
  Scope that enables account user to accept goods quotes and process goods purchases.
  """
  MANAGE_GOODS_PURCHASES

  """
  Scope that enables account user to report a property move-out.
  """
  REPORT_MOVE_OUT

  """
  Scope that enables account user to accept the terms and conditions for a product.
  """
  ACCEPT_TERMS_AND_CONDITIONS

  """
  Scope that enables account user to do a self-serve product switch through the Dashboard.
  """
  MANAGE_PRODUCT_SWITCH

  """
  Scope that enables account user to manage security deposit payments for business accounts.
  """
  MANAGE_BUSINESS_SECURITY_DEPOSIT
}

"""
Invalidate a previously issued expiring/pre-signed token.

This mutation can be used to invalidate the token itself.

To invalidate tokens issued to a particular user, use
InvalidatePreSignedTokensForUser mutation.

The possible errors that can be raised are:

- KT-CT-1129: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InvalidatePreSignedToken {
  possibleErrors: [PossibleErrorType]

  token: PreSignedToken
}

"""
A pre-signed, expiring and opaque tokens that can be swapped for a limited scope JWT (Kraken Token).
"""
type PreSignedToken {
  key: String!

  """
  The scope that the token will grant to the account user.
  """
  scope: ExpiringTokenScope!

  isValid: Boolean
}

"""
An enumeration.
"""
enum ExpiringTokenScope {
  """
  Scope that enables account user to submit meter readings.
  """
  SUBMIT_METER_READINGS

  """
  Scope that enables account user to submit customer feedback.
  """
  SUBMIT_CUSTOMER_FEEDBACK

  """
  Scope that enables account user to book smart meter appointments.
  """
  BOOK_SMART_METER_APPOINTMENTS

  """
  Edit Customer Marketing Preference
  """
  EDIT_CUSTOMER_MARKETING_PREFERENCE

  """
  Scope that enables account user to join campaigns.
  """
  JOIN_CAMPAIGNS

  """
  Scope that enables account user to join campaign events.
  """
  JOIN_CAMPAIGN_EVENTS

  """
  Scope that enables account user to visit campaign dashboard.
  """
  VIEW_CAMPAIGN_DASHBOARDS

  """
  Scope that enables account user to visit detailed property usage pages.
  """
  VIEW_DETAILED_USAGE

  """
  Scope that enables account user to redeem loyalty points
  """
  REDEEM_LOYALTY_POINTS

  """
  Scope that enables account user to generate a renewal quote and renew agreements.
  """
  MANAGE_ACCOUNT_RENEWALS

  """
  Scope that enables account user to checkout a quote (validate terms & conds and provide a payment detail).
  """
  CHECKOUT_QUOTE

  """
  Scope that enables account user to update their blackhole email address.
  """
  UPDATE_BLACKHOLE_EMAIL

  """
  Update Sensitive Customer Information
  """
  UPDATE_SENSITIVE_CUSTOMER_INFORMATION

  """
  Scope that enables account user to accept goods quotes and process goods purchases.
  """
  MANAGE_GOODS_PURCHASES

  """
  Scope that enables account user to report a property move-out.
  """
  REPORT_MOVE_OUT

  """
  Scope that enables account user to accept the terms and conditions for a product.
  """
  ACCEPT_TERMS_AND_CONDITIONS

  """
  Scope that enables account user to do a self-serve product switch through the Dashboard.
  """
  MANAGE_PRODUCT_SWITCH

  """
  Scope that enables account user to manage security deposit payments for business accounts.
  """
  MANAGE_BUSINESS_SECURITY_DEPOSIT
}

"""
Input type for the InvalidatePreSignedToken mutation.
"""
input InvalidatePreSignedTokenInput {
  token: String!
}

"""
Invalidate pre-signed tokens previously issued to a particular user.

This mutation can invalidate all pre-signed tokens issued to a
customer, or only tokens of a given scope.

The possible errors that can be raised are:

- KT-CT-1129: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InvalidatePreSignedTokensForUser {
  possibleErrors: [PossibleErrorType]

  tokens: [PreSignedToken]
}

"""
Input type for the InvalidatePreSignedTokensForUser mutation.
"""
input InvalidatePreSignedTokensForUserInput {
  """
  The email address of the user whose tokens should be invalidated.
  """
  email: String!

  """
  The scope of the token to invalidate.  If this argument is not specified, all pre-signed tokens issued to the user are invalidated.
  """
  scope: PreSignedTokenScope = null
}

type RequestPasswordResetOutputType {
  """
  The email that requested a password reset email.
  """
  email: String
}

"""
Input type for the RequestPasswordReset mutation.
"""
input RequestPasswordResetInput {
  """
  The email requesting a password reset email.
  """
  email: String!
}

type ResetPasswordMutationPayload {
  errors: [SerializerFieldErrorsType]

  clientMutationId: String
}

input ResetPasswordMutationInput {
  password: String!

  userId: String!

  token: String!

  clientMutationId: String
}

type ResetUserPasswordOutput {
  """
  True if the password update was successful, false otherwise.
  """
  passwordUpdated: Boolean

  """
  A list of which password validations the new password failed against if applicable.
  """
  failureReasons: [String]
}

input ResetUserPasswordInput {
  """
  The new password.
  """
  newPassword: String!

  """
  A base64 bytestring representing the user's unique id.
  """
  userId: String!

  """
  The token from the presigned url.
  """
  token: String!
}

"""
The unifying approach used to get a Kraken token (JWT: JSON Web Token) with
different types of input.

The currently supported inputs are:
- account user email/password combination
- account user API key
- organization live secret key
- pre-signed key
- refresh token

The possible errors that can be raised are:

- KT-CT-1135: Invalid data.
- KT-CT-1134: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type ObtainKrakenJSONWebToken {
  possibleErrors: [PossibleErrorType]

  """
  The Kraken Token.  Can be used in the `Authorization` header for subsequent calls to the API to access protected resources.
  """
  token: String!

  """
  The body payload of the Kraken Token.  The same information can be obtained by using JWT decoding tools on the value of the `token` field.
  """
  payload: GenericScalar!

  """
  A token that can be used in a subsequent call to `obtainKrakenToken` to get a new Kraken Token with the same access conditions after the previous one has expired.
  """
  refreshToken: String

  """
  A Unix timestamp representing the point in time at which the refresh token will expire.
  """
  refreshExpiresIn: Int
}

"""
The input type for obtaining a Kraken Token (JWT).
"""
input ObtainJSONWebTokenInput {
  """
  Email address of the account user. Use with 'password' field.
  """
  email: String

  """
  Password of the account user. Use with 'email' field.
  """
  password: String

  """
  API key of the account user. Use standalone, don't provide a second input field.
  """
  APIKey: String

  """
  Live secret key of an third-party organization. Use standalone, don't provide a second input field.
  """
  organizationSecretKey: String

  """
  Short-lived, temporary key (that's pre-signed). Use standalone, don't provide a second input field.
  """
  preSignedKey: String

  """
  The refresh token that can be used to extend the expiry claim of a Kraken token. Use standalone, don't provide a second input field.
  """
  refreshToken: String
}

type ForceReauthentication {
  """
  Reports whether the mutation applied successfully.  Should always be 'true'.
  """
  tokensInvalidated: Boolean!

  """
  The time at which forced reauthentication is effective.  Kraken and refresh tokens issued before this time will be invalid.
  """
  effectiveAt: DateTime!
}

"""
The input type for repudiating previously issued Kraken Tokens and refresh tokens.
"""
input ForceReauthenticationInput {
  """
  Also force third-party applications you have authorized to use your account to reauthenticate.
  """
  includeThirdParties: Boolean!
}

"""
Obtain a long-lived refresh token.

This mutation is limited to authorized third-party organizations only.

Account users can only generate short-lived refresh tokens.

The short-lived refresh tokens (for account users) can be obtained from
the 'refreshToken' field in 'obtainKrakenToken' mutation.

The possible errors that can be raised are:

- KT-CT-1120: The Kraken Token has expired.
- KT-CT-1121: Please use Kraken Token to issue long-lived refresh tokens.
- KT-CT-1132: Unauthorized.
- KT-CT-1122: Long-lived refresh tokens can only be issued for account users.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ObtainLongLivedRefreshToken {
  possibleErrors: [PossibleErrorType]

  refreshToken: String

  refreshExpiresIn: Int!
}

"""
The input type for obtaining a long-lived refresh token.
"""
input ObtainLongLivedRefreshTokenInput {
  """
  The Kraken Token that will be used to generate the long-lived refresh token.
  """
  krakenToken: String!
}

"""
Invalidate a previously issued refresh token.

This mutation can be used to invalidate the token itself.  To
invalidate tokens issued to a particular user, use
InvalidateRefreshTokensForUser.

The possible errors that can be raised are:

- KT-CT-1130: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InvalidateRefreshToken {
  possibleErrors: [PossibleErrorType]

  token: RefreshToken
}

"""
An opaque token that can be used to renew a Kraken Token.
"""
type RefreshToken {
  key: String!

  """
  The datetime when the token will expire.
  """
  expiryDt: DateTime!

  isValid: Boolean
}

"""
Input type for the InvalidateRefreshToken mutation.
"""
input InvalidateRefreshTokenInput {
  refreshToken: String!
}

"""
Invalidate refresh tokens previously issued to a particular user.

This mutation will invalidate all refresh tokens issued to a
customer.

The possible errors that can be raised are:

- KT-CT-1128: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type InvalidateRefreshTokensForUser {
  possibleErrors: [PossibleErrorType]

  tokens: [RefreshToken]
}

"""
Input type for the InvalidateRefreshTokensForUser mutation.
"""
input InvalidateRefreshTokensForUserInput {
  """
  The email address of the user whose tokens should be invalidated.
  """
  email: String!
}

"""
The possible errors that can be raised are:

- KT-CT-1145: Account/user details do not match.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type VerifyIdentity {
  possibleErrors: [PossibleErrorType]

  """
  An expiring token that can be used to request to update the user's email address.
  """
  token: String!
}

input VerifyIdentityInput {
  """
  The number of the account belonging to the user (e.g. A-12345678).
  """
  accountNumber: String!

  """
  The user's full name.
  """
  fullName: String!

  """
  The first line of the user's address (this could be the energy supply property address or the billing address on the account).
  """
  firstLineOfAddress: String!

  """
  The user's postcode (this could be the postcode of the energy supply property address or of the billing address on the account).
  """
  postcode: String!
}

"""
The possible errors that can be raised are:

- KT-CT-7801: Received an invalid operationsTeamId.
- KT-CT-7802: The external identifier already exists.
- KT-CT-7805: Too many tags associated with this API Exception.
- KT-CT-7806: Cannot create duplicate tags for the same API exception.
- KT-CT-7811: Received an invalid assignedUserId.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAPIException {
  possibleErrors: [PossibleErrorType]

  """
  The created APIException.
  """
  apiException: APIExceptionType
}

input CreateAPIExceptionInput {
  """
  External identifier mapping an entity on the client's database.
  """
  externalIdentifier: String!

  """
  The resolution status. Defaults to UNASSIGNED if not provided.
  """
  resolutionStatus: APIExceptionResolutionStatus = null

  """
  The resolution type. Defaults to UNASSIGNED if not provided.
  """
  resolutionType: APIExceptionResolutionType = null

  """
  The priority. Defaults to LOW if not provided.
  """
  priority: APIExceptionPriority = null

  """
  Contextual information about the exception, if any.
  """
  context: JSONString

  """
  The API client channel where the exception was triggered from.
  """
  channel: String!

  """
  The ID of the user assigned to handle this exception.If no user is provided, no user will be assigned to the exception.
  """
  assignedUserId: Int

  """
  The ID of an operations team to handle this exception. If no team is provided, no team will be assigned to the exception.
  """
  operationsTeamId: Int

  """
  Tags associated with this exception if any.
  """
  tags: [APIExceptionTags]

  """
  Category associated with this exception. Uses the default category if not provided.
  """
  category: APIExceptionCategories = UNKNOWN

  """
  The account number associated with the exception, if available.
  """
  accountNumber: ID

  """
  The user ID associated with the exception, if available.
  """
  userId: Int

  """
  The customer contact associated with the exception, if available.
  """
  customerContact: String

  """
  The supply point identifier associated with the exception, if available.
  """
  supplyPointIdentifier: String

  """
  The key date associated with the exception, if available.
  """
  keyDate: Date
}

"""
The possible errors that can be raised are:

- KT-CT-7804: No fields present in the input for updating the APIException.
- KT-CT-7803: Received an invalid apiExceptionId.
- KT-CT-7809: Update results in no changes to API Exception.
- KT-CT-7805: Too many tags associated with this API Exception.
- KT-CT-7806: Cannot create duplicate tags for the same API exception.
- KT-CT-7801: Received an invalid operationsTeamId.
- KT-CT-7811: Received an invalid assignedUserId.
- KT-CT-7812: Support user is inactive.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAPIException {
  possibleErrors: [PossibleErrorType]

  """
  The updated APIException.
  """
  apiException: APIExceptionType
}

input UpdateAPIExceptionInput {
  """
  The ID of the API Exception that will be updated.
  """
  id: Int!

  """
  The new resolution status. If none is provided, the field won't be updated.
  """
  resolutionStatus: APIExceptionResolutionStatus = null

  """
  The new resolution type. If none is provided, the field won't be updated.
  """
  resolutionType: APIExceptionResolutionType = null

  """
  The new priority. If none is provided, the field won't be updated.
  """
  priority: APIExceptionPriority = null

  """
  The new context. If none is provided, the field won't be updated. This will completely replace the existing context by the new one.
  """
  context: JSONString

  """
  The new category. If none is provided, the field won't be updated.
  """
  category: APIExceptionCategories = null

  """
  The updated list of tags. If none is provided, the field won't be updated.
  """
  tags: [APIExceptionTags]

  """
  The new key date. If none is provided, the field won't be updated.
  """
  keyDate: Date

  """
  The ID of the user assigned to handle this exception.If no user is provided, no user will be assigned to the exception.
  """
  assignedUserId: Int

  """
  The ID of an operations team to handle this exception. If no team is provided, no team will be assigned to the exception.
  """
  operationsTeamId: Int
}

"""
The possible errors that can be raised are:

- KT-CT-7803: Received an invalid apiExceptionId.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAPICall {
  possibleErrors: [PossibleErrorType]

  """
  The created APICall.
  """
  apiCall: APICallType
}

input CreateAPICallInput {
  """
  The correlation id header from the HTTP request.
  """
  correlationId: String!

  """
  The name of the operation associated with this call.
  """
  operationName: String!

  """
  The input data provided to the API, if any.
  """
  inputData: JSONString

  """
  The response returned by the API.
  """
  response: JSONString!

  """
  Any optional useful context involved in the API call.
  """
  context: JSONString

  """
  The ID of the associated API exception, if any.
  """
  apiExceptionId: Int
}

"""
The possible errors that can be raised are:

- KT-CT-7803: Received an invalid apiExceptionId.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAPIExceptionEvent {
  possibleErrors: [PossibleErrorType]

  """
  The created APIExceptionEvent.
  """
  apiExceptionEvent: APIExceptionEventType
}

input CreateAPIExceptionEventInput {
  """
  The event type.
  """
  eventType: String!

  """
  The event category.
  """
  category: String!

  """
  Any useful event description.
  """
  description: String!

  """
  Any optional useful context involved in the event.
  """
  context: JSONString

  """
  The ID of the associated API exception, if any.
  """
  apiExceptionId: Int
}

"""
The possible errors that can be raised are:

- KT-CT-7803: Received an invalid apiExceptionId.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAPIExceptionNote {
  possibleErrors: [PossibleErrorType]

  """
  The created APIExceptionNote.
  """
  apiException: APIExceptionType
}

input CreateAPIExceptionNoteInput {
  """
  The body of the note.
  """
  body: String!

  """
  The ID of the associated API exception.
  """
  apiExceptionId: ID!
}

"""
The possible errors that can be raised are:

- KT-CT-7807: Received an invalid apiExceptionNoteId.
- KT-CT-7808: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAPIExceptionNote {
  possibleErrors: [PossibleErrorType]

  """
  The updates APIExceptionNote.
  """
  apiException: APIExceptionType
}

input UpdateAPIExceptionNoteInput {
  """
  The body of the note.
  """
  body: String!

  """
  The ID of the API Exception note being updated.
  """
  apiExceptionNoteId: ID!
}

type UpdateAccountUserMutationPayload {
  givenName: String

  familyName: String

  pronouns: String

  mobile: String

  email: String

  dateOfBirth: Date

  landline: String

  errors: [ErrorType]

  clientMutationId: String
}

input UpdateAccountUserMutationInput {
  givenName: String

  familyName: String

  pronouns: String

  mobile: String

  email: String

  dateOfBirth: Date

  landline: String

  clientMutationId: String
}

"""
Update the account user comms preferences.
"""
type UpdateAccountUserCommsPreferencesMutationPayload {
  isOptedInToClientMessages: Boolean

  isOptedInToOfferMessages: Boolean

  isOptedInToRecommendedMessages: Boolean

  isOptedInToUpdateMessages: Boolean

  isOptedInToThirdPartyMessages: Boolean

  isOptedInMeterReadingConfirmations: Boolean

  isOptedInToSmsMessages: Boolean

  isUsingInvertedEmailColours: Boolean

  fontSizeMultiplier: Float

  emailFormat: String

  preferredHoldMusic: String

  errors: [ErrorType]

  commsPreferences: AccountUserCommsPreferences

  clientMutationId: String
}

input UpdateAccountUserCommsPreferencesMutationInput {
  isOptedInToClientMessages: Boolean

  isOptedInToOfferMessages: Boolean

  isOptedInToRecommendedMessages: Boolean

  isOptedInToUpdateMessages: Boolean

  isOptedInToThirdPartyMessages: Boolean

  isOptedInMeterReadingConfirmations: Boolean

  isOptedInToSmsMessages: Boolean

  isUsingInvertedEmailColours: Boolean

  fontSizeMultiplier: Float

  emailFormat: String

  preferredHoldMusic: String

  clientMutationId: String
}

"""
Update user's password.
"""
type UpdatePassword {
  """
   The currently authenticated user. 

   

  This field requires the `Authorization` header to be set. 

  """
  viewer: AccountUserType
}

input UpdatePasswordInput {
  """
  Old password
  """
  oldPassword: String!

  """
  New password
  """
  newPassword: String!

  """
  Confirm new password
  """
  newPasswordConfirmed: String!
}

"""
Regenerate the user's live secret key.
"""
type RegenerateSecretKey {
  """
   The currently authenticated user. 

   

  This field requires the `Authorization` header to be set. 

  """
  viewer: AccountUserType
}

"""
The possible errors that can be raised are:

- KT-CT-5413: Invalid data.
- KT-CT-5414: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateUserMutation {
  possibleErrors: [PossibleErrorType]

  viewer: AccountUserType
}

input UpdateUserInput {
  givenName: String

  familyName: String

  """
  How the user would like us to address them (e.g. 'she/her', 'they/them'). Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  pronouns: String

  email: String

  """
  Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  mobile: String

  dateOfBirth: Date

  """
  Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  landline: String

  """
  The user for whom to perform the update. This is only needed when using an Organisation role
  """
  userId: String

  """
  The user's title.
  """
  title: String
}

type RegisterPushNotificationBinding {
  pushNotificationBinding: PushNotificationBindingType
}

"""
Represents a pairing of a single app installation to an account user.
"""
type PushNotificationBindingType {
  id: ID!

  messages(offset: Int, before: String, after: String, first: Int, last: Int): PrintMessageTypeConnection!

  user: AccountUserType!

  token: String!

  application: NotifiableApplicationType!

  registeredAt: DateTime!

  expiresAt: DateTime!
}

"""
Represents an application that can receive push notifications.
"""
type NotifiableApplicationType {
  id: ID!

  """
  Human readable name for the app.
  """
  name: String!

  """
  Bundle ID or package name of the app.
  """
  bundleId: String!

  service: NotifiableApplicationService!

  externalProvider: NotifiableApplicationExternalProvider!

  """
  Project ID used in push notification delivery service. (Currently: AWS Pinpoint)
  """
  externalProjectId: String!

  description: String!

  pushNotificationBindings: [PushNotificationBindingType!]!
}

"""
An enumeration.
"""
enum NotifiableApplicationService {
  """
  Android (GCM)
  """
  GCM

  """
  iOS (APNs)
  """
  APNS

  """
  iOS Sandbox (APNs Sandbox)
  """
  APNS_SANDBOX
}

"""
An enumeration.
"""
enum NotifiableApplicationExternalProvider {
  """
  AWS Pinpoint
  """
  PINPOINT
}

input RegisterPushNotificationBindingInput {
  """
  Device push notification token.
  """
  token: String!

  """
  Register a push notification binding. A push notification binding connects an account user to a specific application running on a specific device through a 'registration token' (Android) or 'device token' (iOS). Using this binding we can send push notifications to the account user's devices.
  """
  bundleId: String!
}

"""
The possible errors that can be raised are:

- KT-CT-5411: Invalid token or no push notification binding found for the given account user.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type DeletePushNotificationBinding {
  possibleErrors: [PossibleErrorType]

  status: DeletePushNotificationBindingOutput
}

enum DeletePushNotificationBindingOutput {
  SUCCESSFUL

  FAILED
}

input DeletePushNotificationBindingInput {
  """
  Device push notification token.
  """
  token: String!
}

"""
Create metadata on an object.

The possible errors that can be raised are:

- KT-CT-8412: Invalid data.
- KT-CT-8414: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateMetadata {
  possibleErrors: [PossibleErrorType]

  metadata: Metadata
}

"""
Update existing metadata on an object.

The possible errors that can be raised are:

- KT-CT-8413: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateMetadata {
  possibleErrors: [PossibleErrorType]

  metadata: Metadata
}

type MeasurementType implements MeasurementInterface {
  source: String!

  """
  This type will return more granular data about the measurement.
  """
  metaData: MeasurementsMetadataOutput

  value: Decimal!

  unit: String!

  readAt: DateTime!
}

interface MeasurementInterface {
  source: String!

  """
  This type will return more granular data about the measurement.
  """
  metaData: MeasurementsMetadataOutput

  value: Decimal!

  unit: String!

  readAt: DateTime!
}

type MeasurementsMetadataOutput {
  """
  The source information relating to the parent measurement node.
  """
  typedSource: TypedSourceOutput @deprecated(reason: "The 'typedSource' type is deprecated.\n\n\nPlease use 'utilityFilters' and the corresponding filter output instead.\n\n\n- Marked as deprecated on 2024-06-17.\n- Will be removed on 2026-01-30.")

  """
  The source information relating to the parent measurement node.
  """
  utilityFilters: UtilityFiltersOutput

  """
  Statistics relating to the parent measurement node.
  """
  statistics: [StatisticOutput]
}

"""
Note this is deprecated and will be removed in the future.
Please use the `UtilityFiltersOutput` type instead.
"""
type TypedSourceOutput {
  utility: UtilityType

  sourceIdentifier: String

  readingFrequencyType: ReadingFrequencyType

  readingDirection: ReadingDirectionType

  readingQuality: ReadingQualityType
}

enum UtilityType {
  ELECTRICITY

  EMBEDDED_ELECTRICITY

  GAS
}

"""
The frequency of the reading.
"""
enum ReadingFrequencyType {
  """
  Interval Readings as provided, may be variable in length.
  """
  RAW_INTERVAL

  """
  Readings taken in every 5 minute intervals.
  """
  FIVE_MIN_INTERVAL

  """
  Readings taken in every 15 minute intervals.
  """
  FIFTEEN_MIN_INTERVAL

  """
  Readings taken in every 30 minute intervals.
  """
  THIRTY_MIN_INTERVAL

  HOUR_INTERVAL

  DAY_INTERVAL

  WEEK_INTERVAL

  MONTH_INTERVAL

  QUARTER_INTERVAL

  """
  Readings taken on a day to day basis.
  """
  DAILY

  """
  Readings taken at a point in time.
  """
  POINT_IN_TIME
}

"""
Reading direction is based on the utility generated or consumed by the customer.
"""
enum ReadingDirectionType {
  """
  Reading is based on the customer's usage of the utility.
  """
  CONSUMPTION

  """
  Reading is based on the utility generated by the customer.

  For example: This will return solar readings if a customer has solar panels installed at their location.
  """
  GENERATION
}

enum ReadingQualityType {
  ACTUAL

  ESTIMATE

  COMBINED
}

union UtilityFiltersOutput = ElectricityFiltersOutput|EmbeddedElectricityFiltersOutput|GasFiltersOutput

type ElectricityFiltersOutput {
  readingDirection: ReadingDirectionType

  registerId: String

  readingQuality: ReadingQualityType

  readingFrequencyType: ReadingFrequencyType

  marketSupplyPointId: String

  deviceId: String
}

type EmbeddedElectricityFiltersOutput {
  readingDirection: ReadingDirectionType

  registerId: String

  readingQuality: ReadingQualityType

  readingFrequencyType: ReadingFrequencyType

  marketSupplyPointId: String

  deviceId: String
}

"""
Filter measurements by gas parameters.
"""
type GasFiltersOutput {
  registerId: String

  readingFrequencyType: ReadingFrequencyType

  marketSupplyPointId: String

  deviceId: String
}

type StatisticOutput {
  """
  The type of statistic being measured for the parent node.
  """
  type: ReadingStatisticTypeEnum

  """
  Display label of the statistic for the parent node.
  """
  label: String

  """
  Description of the statistic for the parent node.
  """
  description: String

  """
  Monetary cost of the statistic (excluding tax), if applicable.
  """
  costExclTax: EstimatedMoneyType

  """
  Monetary cost of the statistic (including tax), if applicable.
  """
  costInclTax: EstimatedMoneyType

  """
  Consumption / generation value of the statistic, if applicable.
  """
  value: Decimal
}

"""
The type of statistic for the reading interval.
"""
enum ReadingStatisticTypeEnum {
  """
  The calculated cost of standing charges for the interval.
  """
  STANDING_CHARGE_COST

  """
  The calculated cost of consumption for the interval.
  """
  CONSUMPTION_COST

  """
  The calculated monetary value of generation for the interval
  """
  GENERATION_VALUE

  """
  The apportion cost of a time of use bucket for the interval.
  """
  TOU_BUCKET_COST

  """
  The estimated carbon cost of the interval.
  """
  CARBON_COST
}

type EstimatedMoneyType {
  """
              Monetary cost of the statistic. This is the smallest unit of currency,
              e.g. cents for USD or yen for JPY. Because electricity is priced as a commodity, we must
              account for fractional cents and this field must be a Decimal. Values from this field should
              likely not be used for accounting purposes.
          
  """
  estimatedAmount: Decimal!

  """
  Monetary currency of the statistic in ISO-4217 format.
  """
  costCurrency: String!

  """
  Net price per unit of the statistic if applicable.
  """
  pricePerUnit: PricePerUnit
}

type PricePerUnit {
  """
              Monetary value of a single unit of the measurement.
              This is the smallest unit of currency e.g. cents for USD or yen for JPY.
          
  """
  amount: Decimal!
}

type IntervalMeasurementType implements MeasurementInterface {
  source: String!

  """
  This type will return more granular data about the measurement.
  """
  metaData: MeasurementsMetadataOutput

  value: Decimal!

  unit: String!

  readAt: DateTime!

  startAt: DateTime!

  endAt: DateTime!

  durationInSeconds: Int!

  accumulation: Decimal
}

"""
Represents a property. Conceptually, it collects supply points under an address.
"""
type PropertyType implements PropertyInterface {
  id: String

  postcode: String!

  """
  The address of the property, formatted into a single string
  """
  address: String

  """
  Property rich address.
  """
  richAddress: PropertyRichAddressType

  """
  List of address lines.
  """
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """
  The embedded network this property belongs to, if any.
  """
  embeddedNetwork: EmbeddedNetworkType

  """
  Measurements at a property
  """
  measurements("Defaults to the far past which will return the oldest readings." startAt: DateTime = "0001-01-03T00:00:00-00:01:15", "Defaults to the far future which will return the most recent readings." endAt: DateTime = "9999-12-29T23:59:59.999999+00:00", "Earliest date to return measurements from." startOn: Date, "Latest date to return measurements for (inclusive)." endOn: Date, "Timezone to use for grouping. Defaults to Kraken localtime." timezone: String = "Europe\/London", "A source type to filter against sources." typedOnly: [TypedSourceInputType] = [{
    utility: ELECTRICITY
  }
  ] @deprecated(reason: "The 'typedOnly' field is deprecated.\n\n\nPlease use 'utilityFilters' instead.\n\n\n- Marked as deprecated on 2023-07-10.\n- Will be removed on 2026-01-30."), "Filters for each utility being measured" utilityFilters: [UtilityFiltersInput] = [], before: String, after: String, first: Int, last: Int): MeasurementConnection

  """
  Retrieve any smartmeter devices connected to the property.
  """
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]

  isChangeOfTenancyOngoing: Boolean

  """
  Indicates if the property meets smart meter install preconditions.
  """
  isSmets2InstallationAllowed: Boolean

  """
  Retrieve the details of an electricity meter-point.
  """
  electricityMeterPoints: [ElectricityMeterPointType]

  """
  Retrieve the details of a gas meter-point.
  """
  gasMeterPoints: [GasMeterPointType]

  """
  Likelihood that a smart meter at the given postcode will get a stable network connection.
  """
  wanCoverage: WANCoverageStrengths

  """
  Timeslots for which the property has the possibility to book a smart-meter installation.
  """
  availableSmets2InstallationTimeslots: [Smets2InstallationTimeslotType]
}

interface PropertyInterface {
  id: String

  """
  The address of the property, formatted into a single string
  """
  address: String

  """
  Property rich address.
  """
  richAddress: PropertyRichAddressType

  """
  List of address lines.
  """
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """
  The embedded network this property belongs to, if any.
  """
  embeddedNetwork: EmbeddedNetworkType

  """
  Measurements at a property
  """
  measurements("Defaults to the far past which will return the oldest readings." startAt: DateTime = "0001-01-03T00:00:00-00:01:15", "Defaults to the far future which will return the most recent readings." endAt: DateTime = "9999-12-29T23:59:59.999999+00:00", "Earliest date to return measurements from." startOn: Date, "Latest date to return measurements for (inclusive)." endOn: Date, "Timezone to use for grouping. Defaults to Kraken localtime." timezone: String = "Europe\/London", "A source type to filter against sources." typedOnly: [TypedSourceInputType] = [{
    utility: ELECTRICITY
  }
  ] @deprecated(reason: "The 'typedOnly' field is deprecated.\n\n\nPlease use 'utilityFilters' instead.\n\n\n- Marked as deprecated on 2023-07-10.\n- Will be removed on 2026-01-30."), "Filters for each utility being measured" utilityFilters: [UtilityFiltersInput] = [], before: String, after: String, first: Int, last: Int): MeasurementConnection
}

type PropertyRichAddressType {
  """
  A personal name.
  """
  name: String

  """
  The name of a business or organisation.
  """
  organization: String

  """
  The 'street address' component.

  This value can (and often will) contain newline characters
  when appropriate.

  In some cases, data may appear in this field instead of the
  below fields; e.g. a UK post town name may appear here
  instead of in the `dependent_locality` field. This happens
  when data has been migrated from a legacy format, and that
  format had insufficient metadata to determine the
  appropriate field.

  If `structured_street_address` is also set, the value of
  this field will be a string generated from that value.
  """
  streetAddress: String

  """
  The 'street address' component, in a structured format.

  This field stores the same value as `street_address`, but
  with more detail; for instance, instead of `123 Example
  Street` it might be `{'street_number': '123',
  'street_name': 'Example', 'street_type': 'Street'}`. In
  many cases this will be blank; we only use this field for
  Krakens where we need to supply this level of granularity
  to some third-party service, like a bulk mail provider.

  The exact structure of this value depends on the country _of
  the address_, which is not necessarily the same as the
  country this Kraken is configured to serve. For addresses
  outside of the countries listed below, this field will be
  left blank.

  ### `AU`: Australia

  The following keys may be present; all are optional. All
  keys have string values, and their meaning is the same as
  their aseXML counterparts. (Note that, unlike aseXML, all
  keys are provided at the top level, rather than being
  nested.)

  - `flat_or_unit_type`
  - `flat_or_unit_number`
  - `floor_or_level_type`
  - `floor_or_level_number`
  - `building_or_property_name`
  - `location_descriptor`
  - `lot_number`
  - `house_number_1`
  - `house_number_suffix_1`
  - `house_number_2`
  - `house_number_suffix_2`
  - `street_name`
  - `street_type`
  - `street_suffix`
  - `postal_delivery_type`
  - `postal_delivery_number_prefix`
  - `postal_delivery_number_value`
  - `postal_delivery_number_suffix`

  ### `JP`: Japan

  The following keys may be present; all are optional.
  If keys are empty, they may be omitted from the response entirely.

  - `chome`
  - `banchi`
  - `go`
  - `edaban`
  - `kana_building_name`
  - `kanji_building_name`
  - `building_number`
  - `room_number`
  - `address_code`
  - `physical_location_identifier`
  """
  structuredStreetAddress: GenericScalar

  """
  UK dependent localities, or neighbourhoods or boroughs in
  some other locations.
  """
  dependentLocality: String

  """
  City or town portion of an address, e.g. US city, AU
  suburb/town, IT comune, UK post town.
  """
  locality: String

  """
  Top-level administrative subdivision, e.g. US state, AU
  state/territory, IT region, JP prefecture.

  ### `AU`: Australia

  This must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,
  `NT`, `WA`. For addresses not within these locations, use
  the value that Australia Post uses, e.g. `ACT` for the
  Jervis Bay Territory or `WA` for Christmas Island.
  """
  administrativeArea: String

  """
  Postal code (ZIP code in the US).
  """
  postalCode: String

  """
  Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  """
  sortingCode: String

  """
  ISO 3166-1 alpha-2 code of the country this address belongs
  to, e.g. `AU`, `GB`.
  """
  country: String

  """
  Identifier used by the local postal service for this
  address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  US Zip-9 + Delivery Point.

  This is the value that gets encoded in the barcode printed
  on the envelope by large-volume bulk mail providers.
  """
  deliveryPointIdentifier: String
}

"""
An occupancy period for a property.
"""
type OccupancyPeriodType {
  id: ID

  """
  Date the occupancy period is effective from.
  """
  effectiveFrom: DateTime

  """
  Date the occupancy period is effective to.
  """
  effectiveTo: DateTime

  """
  Whether the account associated with the occupancy period is an occupier account type.
  """
  isOccupier: Boolean
}

type CoordinatesType {
  latitude: Float

  longitude: Float
}

"""
Represents an embedded network that holds multiple embedded properties.
"""
type EmbeddedNetworkType {
  id: ID!

  """
  A unique name/code for the network
  """
  name: String!

  """
  Get details about properties in an embedded network.
  """
  embeddedProperties: [EmbeddedPropertyType]
}

"""
Represents an embedded property in an embedded network.
"""
type EmbeddedPropertyType {
  id: ID!

  embeddedNetwork: EmbeddedNetworkType!

  """
  The id of the physical property related to this embedded property type.
  """
  propertyId: ID
}

"""
Pagination for measurements.
"""
type MeasurementConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [MeasurementEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `Measurement` and its cursor.
"""
type MeasurementEdge {
  """
  The item at the end of the edge
  """
  node: MeasurementInterface

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Provide a typed source to filter measurements.
If a typed_source and a raw source is given, preference is given to the raw source.
To get better results, make sure none of the input fields are empty.
"""
input TypedSourceInputType {
  utility: UtilityType = ELECTRICITY

  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL

  readingDirection: ReadingDirectionType = CONSUMPTION

  sourceIdentifier: String

  readingQuality: ReadingQualityType = COMBINED
}

"""
Filter measurements by the given utility parameters.
"""
input UtilityFiltersInput {
  electricityFilters: ElectricityFiltersInput = null

  gasFilters: GasFiltersInput = null
}

"""
Filter measurements by electricity parameters.
"""
input ElectricityFiltersInput {
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL

  marketSupplyPointId: String

  deviceId: String

  readingDirection: ReadingDirectionType = CONSUMPTION

  registerId: String

  readingQuality: ReadingQualityType = COMBINED
}

"""
Filter measurements by gas parameters.
"""
input GasFiltersInput {
  readingFrequencyType: ReadingFrequencyType = RAW_INTERVAL

  marketSupplyPointId: String

  deviceId: String

  registerId: String
}

"""
This is the network through which a set of SMETS2 devices communicates.
"""
type SmartMeterDeviceNetworkType {
  id: ID!

  """
  A list of devices attached to one network.
  """
  smartDevices("Filter the devices by status." statuses: [DeviceStatuses]): [SmartMeterDeviceType]
}

"""
A smart meter device.
"""
type SmartMeterDeviceType {
  id: ID!

  importElectricityMeter: ElectricityMeterType

  exportElectricityMeter: ElectricityMeterType

  gasMeter: GasMeterType

  deviceNetwork: SmartMeterDeviceNetworkType

  serialNumber: String!

  deviceId: String!

  type: DeviceType

  status: DeviceStatus!

  manufacturer: String!

  model: String!

  firmwareVersion: String!

  """
  The payment mode (e.g. credit or prepayment) that the device is currently operating in.
  """
  paymentMode: PaymentMode

  """
  The rate, in pence per week, that debt is being recovered from this device.
  """
  weeklyDebtRecoveryRateInPence: Int
}

"""
An electricity meter is a collection of registers which store readings. Eco7 meters are an example of a meter with multiple registers (for day and night).
"""
type ElectricityMeterType implements Meter & Node {
  id: ID!

  serialNumber: String!

  requiresAccess: Boolean

  isDigital: Boolean

  installationDate: Date

  lastInspectionDate: Date

  createdAt: DateTime!

  updatedAt: DateTime

  activeFrom: Date!

  activeTo: Date

  meterPoint: ElectricityMeterPointType!

  location: String

  currentRating: Int

  makeAndType: String

  meterType: ElectricityMeterMeterType

  certificationDate: Date

  certifiedUntil: Date

  retrievalMethod: String

  importMeter: ElectricityMeterType

  exportMeters(offset: Int, before: String, after: String, first: Int, last: Int): ElectricityMeterTypeConnection!

  prepayLedgers: PrepayLedgersType

  smartImportElectricityMeter: SmartMeterDeviceType

  smartExportElectricityMeter: SmartMeterDeviceType

  """
  The units of consumption for a smart meter.
  """
  consumptionUnits: String

  """
  Whether this meter requires a final change of tenancy (COT) reading.
  """
  requiresCotFinalReading: Boolean

  """
  The type of fuel this meter uses.
  """
  fuelType: String

  """
  Energy consumption recorded by the meter.
  """
  consumption("Earliest consumption reading to return. Must specify a timezone." startAt: DateTime!, "Aggregate consumption according to this grouping." grouping: ConsumptionGroupings!, "Timezone to use for grouping." timezone: String!, before: String, after: String, first: Int, last: Int): ConsumptionConnection

  """
  This lets us get around the fact that we already use the field id as a primary key. We will migrate the id field over to be this id eventually.
  """
  nodeId: ID!

  readings(before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection

  registers: [ElectricityMeterRegisterType]

  """
  Returns if the meter has and allows half hourly readings
  """
  hasAndAllowsHhReadings: Boolean

  smartDevices: [SmartMeterDeviceType]

  """
  Returns if the meter is a traditional prepay meter.
  """
  isTradPrepay: Boolean

  """
  Returns if the meter is ready for top up.
  """
  isReadyForTopup: Boolean
}

interface Meter {
  id: ID!

  serialNumber: String!

  """
  The units of consumption for a smart meter.
  """
  consumptionUnits: String

  """
  Whether this meter requires a final change of tenancy (COT) reading.
  """
  requiresCotFinalReading: Boolean

  """
  The type of fuel this meter uses.
  """
  fuelType: String

  """
  Energy consumption recorded by the meter.
  """
  consumption("Earliest consumption reading to return. Must specify a timezone." startAt: DateTime!, "Aggregate consumption according to this grouping." grouping: ConsumptionGroupings!, "Timezone to use for grouping." timezone: String!, before: String, after: String, first: Int, last: Int): ConsumptionConnection
}

"""
Pagination for energy consumption readings.
"""
type ConsumptionConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ConsumptionEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `Consumption` and its cursor.
"""
type ConsumptionEdge {
  """
  The item at the end of the edge
  """
  node: ConsumptionType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Energy consumption between two points in time.
"""
type ConsumptionType {
  value: Decimal

  startAt: DateTime

  endAt: DateTime
}

"""
An enumeration.
"""
enum ConsumptionGroupings {
  QUARTER_HOUR

  HALF_HOUR

  HOUR

  DAY

  WEEK

  MONTH

  QUARTER
}

"""
An electricity meterpoint is a collection of meters. Meters can be changed over time, so it is convenient to keep an invariant reference. Sometimes there are multiple active meters on a meterpoint at a time (eg ECO10), but expect that to be an edge case.
"""
type ElectricityMeterPointType implements MeterPointInterface {
  id: ID!

  supplyEndDate: Date

  mpan: String!

  """
  Standard settlement configuration
  """
  ssc: String!

  energisationStatus: String!

  dccServiceFlag: String!

  statusUpdatedAt: DateTime

  oldSupplierId: String

  newSupplierId: String

  smartStartDate: Date

  requiresEnrolment: Boolean!

  targetSsd: Date

  requiresWithdrawal: Boolean!

  hasOpenOpeningReadDispute: Boolean!

  hasOpenClosingReadDispute: Boolean!

  """
  The profile class of the electricity meter point.
  """
  profileClass: Int

  """
  Line loss factor class
  """
  llf: String

  """
  Meter timeswitch code
  """
  mtc: Int

  measurementClass: String!

  lastValidatedReadingDate: Date

  """
  Smart Metering System Operator
  """
  smsOperator: String!

  smsOperatorEffectiveFrom: Date

  ihdStatus: String!

  ihdEffectiveFrom: Date

  dccEffectiveFrom: Date

  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]

  status: String

  """
  Details of an ongoing enrolment process.
  """
  enrolment: EnrolmentType

  """
  The distribution network the grid supply point falls under
  """
  gspGroupId: String

  """
  A list of agents responsible for management of the meterpoint.
  """
  agentContracts("Filter the contracts by status." statuses: [AgentContractStatusType]): [ElectricityAgentContractType]

  """
  The ID of the meter point in Junifer.
  """
  juniferMeterPointId: Int @deprecated(reason: "The 'juniferMeterPointId' field is deprecated.\n\nIt is no longer populated.\n\n- Marked as deprecated on 2023-03-13.\n- Will be removed on 2023-09-13.")

  """
  A list of electricity agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  """
  agreements(validAfter: DateTime, includeInactive: Boolean, "Exclude agreements starting in the future." excludeFuture: Boolean): [ElectricityAgreementType]

  smartTariffOnboarding: SmartTariffOnboardingType

  """
  A list of unbilled electricity readings for the meterpoint.
  """
  unbilledReadings: [ElectricityMeterReadingType]

  """
  The current MPID for this meter point.
  """
  currentSupplierMpid: String
}

interface MeterPointInterface {
  status: String

  """
  Returns active meters by default, but can be filtered by meter id and active status.
  """
  meters(id: Int, includeInactive: Boolean): [Meter]

  """
  Details of an ongoing enrolment process.
  """
  enrolment: EnrolmentType
}

"""
Details of an ongoing enrolment process.
"""
type EnrolmentType {
  """
  Date the switch started.
  """
  switchStartDate: Date

  """
  Target date for supply to start.
  """
  supplyStartDate: Date

  """
  The last company to supply this meter point.
  """
  previousSupplier: String

  """
  The enrolment status on a meter point.
  """
  status: EnrolmentStatusOptions
}

"""
An enumeration.
"""
enum EnrolmentStatusOptions {
  """
  The previous supplier objects to the switch. The have not has cancelled the switch yet, but in 99% cases, they will cancel the switch.
  """
  OBJECTION_RECEIVED

  """
  The previous supplier cancelled the switch. This is a terminal state, and we will have to reapply before this can start again.
  """
  REGISTRATION_OBJECTED

  """
  The overseeing industry body has objected to the switch
  """
  REJECTED

  """
  The request to bring the meter point on supply has been withdrawn.
  """
  WITHDRAWN

  """
  The meterpoint has been created but the enrolment process has not started yet.
  """
  PRE_REGISTRATION

  """
  Enrolment has been requested. This is the default catch-all status, which is returned when no other defined process is happening.
  """
  REQUESTED

  """
  Enrolment has been completed.
  """
  COMPLETED

  """
  Enrolment has been disputed. This could be that the meter point details that have been provided have been disputed.
  """
  DISPUTED

  """
  Enrolment has been accepted by the industry, which means that it has all the information needed to switch supplier and if that information is correct (to it's knowledge)
  """
  ACCEPTED
}

"""
An organization who manages a given meterpoint.
"""
type ElectricityAgentContractType {
  contractType: ElectricityAgentContractContractType!

  effectiveFrom: Date!

  agentId: String

  contractStatus: AgentContractStatusType
}

"""
An enumeration.
"""
enum ElectricityAgentContractContractType {
  """
  Meter Operator
  """
  MOP

  """
  Data Aggregator
  """
  DA

  """
  Data Collector
  """
  DC

  """
  Advanced Metering Service
  """
  MSA

  """
  Smart Metering Service
  """
  MSS

  """
  Advanced Data Service
  """
  ADS

  """
  Smart Data Service
  """
  SDS

  """
  Unmetered Data Service
  """
  UMSDS

  """
  Unmetered Supplies Operator
  """
  UMSO
}

"""
An enumeration.
"""
enum AgentContractStatusType {
  """
  The contracts that have been accepted by the agent.
  """
  ACCEPTED

  """
  The contracts that have been rejected by the agent.
  """
  REJECTED

  """
  The contracts that have been requested by the supplier.
  """
  REQUESTED

  """
  The contracts for which termination has been requested by the supplier.
  """
  TERMINATION_REQUESTED

  """
  The contracts that have been terminated.
  """
  TERMINATED
}

type ElectricityAgreementType implements AgreementInterface {
  id: Int

  validFrom: DateTime

  validTo: DateTime

  agreedFrom: DateTime

  agreedTo: DateTime

  account: AccountType!

  meterPoint: ElectricityMeterPointType!

  tariff: ElectricityTariffType

  isRevoked: Boolean

  """
  A collection of charges and associated consumption data.
  """
  lineItems(startAt: DateTime!, "Aggregate line items according to this grouping. Note that this doesn't guarantee that the returned items will cover a particular length of time, as it will depend on how the items have been stored, whether the period had daylight savings time changes (and therefore potentially 25 hours) etc." grouping: LineItemGroupingOptions!, itemType: LineItemTypeOptions!, "Timezone used for grouping." timezone: String!, before: String, after: String, first: Int, last: Int): LineItemConnection

  """
  List of contracted unit rate uplifts applicable during this agreement's duration. This is only applicable to business accounts where we may pay commission to a third-party intermediary.
  """
  unitRateUplifts: [ElectricityContractUnitRateUplift]
}

interface AgreementInterface {
  id: Int

  validFrom: DateTime

  validTo: DateTime

  agreedFrom: DateTime

  agreedTo: DateTime

  isRevoked: Boolean
}

union ElectricityTariffType = StandardTariff|DayNightTariff|ThreeRateTariff|HalfHourlyTariff|PrepayTariff

type StandardTariff implements TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String

  unitRate: Float

  """
  Is EPG applied to the unit rate.
  """
  unitRateEpgApplied: Boolean

  preVatUnitRate: Float
}

interface TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String
}

type DayNightTariff implements TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String

  dayRate: Float

  """
  Is EPG applied to the unit rate.
  """
  dayRateEpgApplied: Boolean

  nightRate: Float

  """
  Is EPG applied to the unit rate.
  """
  nightRateEpgApplied: Boolean

  preVatDayRate: Float

  preVatNightRate: Float
}

type ThreeRateTariff implements TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String

  dayRate: Float

  """
  Is EPG applied to the unit rate.
  """
  dayRateEpgApplied: Boolean

  nightRate: Float

  """
  Is EPG applied to the unit rate.
  """
  nightRateEpgApplied: Boolean

  offPeakRate: Float

  """
  Is EPG applied to the unit rate.
  """
  offPeakRateEpgApplied: Boolean

  preVatDayRate: Float

  preVatNightRate: Float

  preVatOffPeakRate: Float
}

type HalfHourlyTariff implements TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String

  unitRates: [UnitRate]

  """
  Information on how agile unit rates have been calculated.
  """
  agileCalculationInfo: AgileCalculationInfo
}

type UnitRate {
  validFrom: DateTime

  validTo: DateTime

  """
  Price in pence (inc VAT).
  """
  value: Float

  """
  Price in pence (not including VAT).
  """
  preVatValue: Float
}

type AgileCalculationInfo {
  """
  The maximum value/cap for the unit rate.
  """
  priceCap: Float

  """
  The peak offset for the unit rate.
  """
  peakOffset: Float

  """
  The price multiplier/coefficient used to calculate the unit rate.
  """
  gspCoefficient: Float
}

type PrepayTariff implements TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String

  unitRate: Float

  preVatUnitRate: Float
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type LineItemConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [LineItemEdge]!
}

"""
A Relay edge containing a `LineItem` and its cursor.
"""
type LineItemEdge {
  """
  The item at the end of the edge
  """
  node: LineItemType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A record of spend on consumption between two points in time.
"""
type LineItemType {
  startAt: DateTime

  endAt: DateTime

  netAmount: Decimal

  numberOfUnits: Decimal

  itemType: String

  settlementUnit: String
}

"""
An enumeration.
"""
enum LineItemGroupingOptions {
  NONE

  HALF_HOUR

  HOUR

  DAY

  WEEK

  MONTH

  QUARTER
}

"""
An enumeration.
"""
enum LineItemTypeOptions {
  STANDING_CHARGE

  CONSUMPTION_CHARGE
}

type ElectricityContractUnitRateUplift {
  """
  When this contract is valid from.
  """
  validFrom: DateTime!

  """
  When this contract is valid until.
  """
  validTo: DateTime!

  """
  The amount to add to the unit rate when billing, in pence/kWh.
  """
  unitRateUplift: Decimal!
}

"""
The smart tariff onboarding process. Only relevant for Kraken instances that support half hourly tariffs. Returns null if not applicable.
"""
type SmartTariffOnboardingType {
  id: ID!

  latestStatus: SmartOnboardingEventType

  latestTermsStatus: SmartOnboardingTermsStatuses

  smartTariffCode: SmartOnboardingTariffCodes

  lastUpdated: String
}

"""
An enumeration.
"""
enum SmartOnboardingEventType {
  """
  Onboarding started.
  """
  STARTED

  """
  Onboarding completed.
  """
  COMPLETED

  """
  Onboarding cancelled.
  """
  CANCELLED

  """
  Note Added.
  """
  NOTE_ADDED

  """
  Email sent to book meter exchange.
  """
  METER_EXCHANGE_EMAIL_SENT

  """
  Meter exchange date agreed.
  """
  METER_EXCHANGE_BOOKED

  """
  Meter Installed.
  """
  METER_INSTALLED

  """
  Meter Readings Available.
  """
  METER_READINGS_AVAILABLE

  """
  Email sent to request terms acceptance.
  """
  TERMS_EMAIL_SENT

  """
  Customer accepted terms and conditions.
  """
  TERMS_ACCEPTED

  """
  Agreements Updated.
  """
  AGREEMENTS_UPDATED

  """
  Email sent to confirm tariff switch.
  """
  TARIFF_SWITCH_CONFIRMATION_EMAIL_SENT

  """
  Tariff Changed On Meter.
  """
  TARIFF_CHANGED_ON_METER

  """
  Unable To Proceed.
  """
  UNABLE_TO_PROCEED

  """
  Previous Agreement Billing Gap Filled.
  """
  PREVIOUS_AGREEMENT_BILLING_GAP_FILLED

  """
  Email to install Intelligent Octopus app installed.
  """
  INTELLIGENT_OCTOPUS_INSTALL_APP_EMAIL_SENT

  """
  Test dispatch in app complete.
  """
  INTELLIGENT_OCTOPUS_TEST_DISPATCH_COMPLETE

  """
  Documents Checked.
  """
  DOCUMENTS_CHECKED

  """
  FIT resolution.
  """
  FIT_RESOLUTION

  """
  Export MPAN applied for.
  """
  EXPORT_MPAN_APPLIED_FOR

  """
  Export MPAN created.
  """
  EXPORT_MPAN_CREATED

  """
  Export Mpan Not Found.
  """
  EXPORT_MPAN_NOT_FOUND

  """
  MTDs updated.
  """
  MTD_UPDATED

  """
  Export Enabled In Kraken.
  """
  EXPORT_ENABLED_IN_KRAKEN

  """
  Export Meter Reading Available.
  """
  EXPORT_METER_READING_AVAILABLE

  """
  Export MPAN is on supply.
  """
  EXPORT_MPAN_ON_SUPPLY

  """
  First Credit Applied.
  """
  FIRST_CREDIT_APPLIED
}

"""
An enumeration.
"""
enum SmartOnboardingTermsStatuses {
  """
  Customer acceptance of T&Cs required
  """
  TERMS_ACCEPTANCE_REQUIRED

  """
  Awaiting customer acceptance of T&Cs
  """
  TERMS_EMAIL_SENT

  """
  T&Cs accepted
  """
  TERMS_ACCEPTED
}

"""
An enumeration.
"""
enum SmartOnboardingTariffCodes {
  """
  Octopus Energy's Agile Octopus tariff
  """
  AGILE_OCTOPUS

  """
  Octopus Energy's Octopus Go tariff
  """
  OCTOPUS_GO

  """
  Octopus Energy's Octopus Go Faster tariff
  """
  OCTOPUS_GO_FASTER

  """
  Octopus Energy's Octopus Go Green tariff
  """
  OCTOPUS_GO_GREEN

  """
  Octopus Energy's Tesla Energy Plan import tariff
  """
  TESLA_IMPORT

  """
  Octopus Energy's Intelligent Octopus Go tariff
  """
  INTELLIGENT_OCTOPUS

  """
  Octopus Energy's Intelligent Octopus Flux tariff
  """
  INTELLIGENT_FLUX

  """
  Octopus Energy's Outgoing Fixed tariff
  """
  OUTGOING_FIXED

  """
  Octopus Energy's Octopus Agile tariff
  """
  OUTGOING_AGILE

  """
  Octopus Energy's Cosy Octopus tariff
  """
  COSY_OCTOPUS

  """
  Octopus Energy's Flux tariff
  """
  OCTOPUS_FLUX

  """
  Octopus Energy's Powerloop tariff
  """
  POWERLOOP
}

"""
A electricity meter reading. A reading can in fact contain multiple values for each register (for example for ECO7). They are collected under a common read_at datetime and have a common fuel type.
"""
type ElectricityMeterReadingType implements MeterReading {
  id: ID!

  readAt: DateTime

  readingSource: String

  registers: [RegisterReading]

  source: String
}

interface MeterReading {
  readAt: DateTime

  readingSource: String

  registers: [RegisterReading]

  source: String
}

type RegisterReading {
  identifier: String

  name: String

  value: String

  digits: Int

  isQuarantined: Boolean
}

"""
An enumeration.
"""
enum ElectricityMeterMeterType {
  """
  Check
  """
  CHECK

  """
  Half Hourly
  """
  H

  """
  Key
  """
  K

  """
  Lag
  """
  LAG_

  """
  Lead
  """
  LEAD_

  """
  Main
  """
  MAIN_

  """
  Non-Half Hourly
  """
  N

  """
  Non-remotely Configurable Automated Meter Reading
  """
  NCAMR

  """
  A meter that meets the definition of an ADM but is not compliant with any version of SMETS
  """
  NSS

  """
  Remotely Configurable Automated Meter Reading without remote enable/disable capability
  """
  RCAMR

  """
  Remotely Configurable Automated Meter Reading with remote enable/disable capability
  """
  RCAMY

  """
  Smartcard Prepayment
  """
  S

  """
  A meter that is compliant with the Smart Metering Equipment Technical Specifications 1 (SMETS1)
  """
  S1

  """
  A single element meter that is compliant with SMETS2
  """
  S2A

  """
  A twin element meter that is compliant with SMETS2
  """
  S2B

  """
  A polyphase meter that is compliant with SMETS2
  """
  S2C

  """
  A single element meter with one or more ALCS that is compliant with SMETS2
  """
  S2AD

  """
  A twin element meter with one or more ALCS that is compliant with SMETS2
  """
  S2BD

  """
  A polyphase meter with one or more ALCS that is compliant with SMETS2
  """
  S2CD

  """
  Single element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2ADE

  """
  A twin element meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2BDE

  """
  A polyphase meter with one or more ALCS and Boost Function that is compliant with SMETS2
  """
  S2CDE

  """
  Special
  """
  SPECL

  """
  Token
  """
  T

  """
  Single Element with APC that is compliant with SMETS2
  """
  A_2AF

  """
  Single Element with ALCS and APC that is compliant with SMETS2
  """
  A_2ADF

  """
  Single Element with Boost Function and APC that is compliant with SMETS2
  """
  A_2AEF

  """
  Single Element with ALCS, Boost Function and APC that is compliant with SMETS2
  """
  A_2ADEF

  """
  Twin Element  with APC that is compliant with SMETS2
  """
  A_2BF

  """
  Twin Element with ALCS and APC that is compliant with SMETS2
  """
  A_2BDF

  """
  Twin Element with Boost Function and APC that is compliant with SMETS2
  """
  A_2BEF

  """
  Twin Element with ALCS, Boost Function and APC that is compliant with SMETS2
  """
  A_2BDEF

  """
  Polyphase with APC that is compliant with SMETS2
  """
  A_2CF

  """
  Polyphase with ALCS and APC that is compliant with SMETS2
  """
  A_2CDF

  """
  Polyphase with Boost Function and APC that is compliant with SMETS2
  """
  A_2CEF

  """
  Polyphase with ALCS, Boost Function and APC that is compliant with SMETS2
  """
  A_2CDEF
}

type ElectricityMeterTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ElectricityMeterTypeEdge]!
}

"""
A Relay edge containing a `ElectricityMeterType` and its cursor.
"""
type ElectricityMeterTypeEdge {
  """
  The item at the end of the edge
  """
  node: ElectricityMeterType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
The ledgers associated to a prepayment meter. There are three types: a credit ledger for mirroring the meter's credit balance, a debt ledger for mirroring the meter's debt balance and payment ledger which is the inflight payments that we have not yet managed to resolve on the other two ledgers.
"""
type PrepayLedgersType {
  creditLedger: SupplementaryLedgerType

  debtLedger: SupplementaryLedgerType

  paymentLedger: PrepayPaymentLedgerType
}

"""
The in-flight payment ledger tracks the status of payments made to a prepay meter.
"""
type PrepayPaymentLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """
  The display name of the ledger.
  """
  name: String

  ledgerType: String

  """
  The current final balance of the ledger in pence.
  """
  currentBalance: Int

  paymentAdequacy: PaymentAdequacyDetailsType

  """
  Payments made to add credit to a smart prepay meter.
  """
  payments: [PrepayPaymentType]

  """
  Transfers of credit from the account ledger to a smart prepay meter.
  """
  creditTransfers: [PrepayCreditTransferType]
}

type PrepayPaymentType {
  id: ID!

  """
  Amount of payment in pence
  """
  amount: BigInt!

  """
  The date this payment is scheduled to be debited
  """
  paymentDate: Date!

  smartPrepayStatus: SmartPrepayPaymentStatusChoices @deprecated(reason: "The 'smartPrepayStatus' field is deprecated.\n\n\nPlease use the 'smartPrepayProcessStatus' type instead for a more granular status.\n\n\n- Marked as deprecated on 2023-09-05.\n- Will be removed on 2024-01-01.")

  smartPrepayProcessStatus: SmartPrepayProcessStatusChoices

  utrn: String!

  meter: Meter
}

enum SmartPrepayPaymentStatusChoices {
  UTRN_REQUESTED

  UTRN_RECEIVED

  ACCEPTED_BY_METER

  RESOLVED
}

enum SmartPrepayProcessStatusChoices {
  NOT_STARTED

  INITIATED

  PENDING

  COMPLETED

  FAILED

  UTRN_MUST_BE_APPLIED_MANUALLY
}

type PrepayCreditTransferType {
  id: ID!

  netAmount: BigInt!

  createdDate: Date!

  smartPrepayStatus: SmartPrepayPaymentStatusChoices @deprecated(reason: "The 'smartPrepayStatus' field is deprecated.\n\n\nPlease use the 'smartPrepayProcessStatus' type instead for a more granular status.\n\n\n- Marked as deprecated on 2023-09-05.\n- Will be removed on 2024-01-01.")

  smartPrepayProcessStatus: SmartPrepayProcessStatusChoices

  utrn: String
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type ElectricityMeterReadingConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ElectricityMeterReadingConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `ElectricityMeterReadingConnectionType` and its cursor.
"""
type ElectricityMeterReadingConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: ElectricityMeterReadingType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Electricity registers measure consumption.
"""
type ElectricityMeterRegisterType {
  id: ID!

  identifier: String

  digits: Int

  decimalPlaces: Int

  name: String

  expectedReadingRanges: [[Int]]

  timePatternRegime: String

  unitRateType: String

  eac: Decimal

  multiplier: Float
}

"""
A gas meter has a register which holds readings. We would expect this to be a one-to-one relationship between meter and register.
"""
type GasMeterType implements Meter & Node {
  id: ID!

  serialNumber: String!

  requiresAccess: Boolean

  isDigital: Boolean

  installationDate: Date

  lastInspectionDate: Date

  createdAt: DateTime!

  updatedAt: DateTime

  activeFrom: Date!

  activeTo: Date

  meterPoint: GasMeterPointType!

  manufacturerCode: String!

  modelName: String!

  manufacturedYear: Int

  meterType: String!

  imperial: Boolean

  units: Int!

  location: String!

  mechanism: GasMeterMechanism

  correction: Float

  locationDescription: String!

  readingFactor: Decimal

  instructions: String!

  pulseValue: Decimal

  linkCode: String!

  collarFitted: String!

  bypassFitted: String!

  measuringCapacity: Decimal

  status: GasMeterStatus

  operationalStatusDate: Date

  owner: String!

  currentMeterAssetManager: String!

  prepayLedgers: PrepayLedgersType

  smartGasMeter: SmartMeterDeviceType

  """
  The units of consumption for a smart meter.
  """
  consumptionUnits: String

  """
  Whether this meter requires a final change of tenancy (COT) reading.
  """
  requiresCotFinalReading: Boolean

  """
  The type of fuel this meter uses.
  """
  fuelType: String

  """
  Energy consumption recorded by the meter.
  """
  consumption("Earliest consumption reading to return. Must specify a timezone." startAt: DateTime!, "Aggregate consumption according to this grouping." grouping: ConsumptionGroupings!, "Timezone to use for grouping." timezone: String!, before: String, after: String, first: Int, last: Int): ConsumptionConnection

  """
  This lets us get around the fact that we already use the field id as a primary key. We will migrate the id field over to be this id eventually.
  """
  nodeId: ID!

  readings(before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection

  registers: [GasMeterRegisterType]

  """
  Returns if the meter has and allows half hourly readings
  """
  hasAndAllowsHhReadings: Boolean

  smartDevices: [SmartMeterDeviceType]

  """
  Returns if the meter is a traditional prepay meter.
  """
  isTradPrepay: Boolean

  """
  Returns if the meter is ready for top up.
  """
  isReadyForTopup: Boolean
}

"""
A gas meterpoint is a collection of meters. Meters are changed over time, so it is convenient to keep an invariant reference. We would not expect there to be multiple active meters at a time on a gas meterpoint.
"""
type GasMeterPointType implements MeterPointInterface {
  id: ID!

  supplyEndDate: Date

  mprn: String

  statusUpdatedAt: DateTime

  oldSupplierId: String

  newSupplierId: String

  smartStartDate: Date

  requiresEnrolment: Boolean!

  targetSsd: Date

  requiresWithdrawal: Boolean!

  hasOpenOpeningReadDispute: Boolean!

  hasOpenClosingReadDispute: Boolean!

  marketSectorCode: GasMeterPointMarketSectorCode

  marketCategory: GasMeterPointMarketCategory

  meterOwnershipType: GasMeterPointMeterOwnershipType

  confirmationReference: Int

  nominationType: String!

  supplyClass: Int!

  nominationShipperReference: String!

  """
  Industry status code
  """
  xoserveStatus: String

  exitCapacityChargeRate: Decimal

  ldzCapacityChargeRate: Decimal

  ldzCommodityChargeRate: Decimal

  ldzCustomerChargeRate: Decimal

  ntsExitCommodityChargeRate: Decimal

  mrfType: String!

  meterReadBatchFrequency: String!

  """
  SOQ fixed for year
  """
  formulaYearSmpSoq: Int

  """
  AQ fixed for year
  """
  formulaYearSmpAq: Int

  """
  Rolling SOQ
  """
  currentDmSoq: Int

  """
  Rolling SOQ
  """
  currentNdmSoq: Int

  exitZone: String!

  """
  Local distribution zone - Distribution charges are based upon this
  """
  ldz: String!

  supplyPointCategory: String!

  endUserCategory: Int

  eucIdentifier: String

  igtIdentifier: String!

  igtCheckedAt: DateTime

  meters(id: Int, includeInactive: Boolean): [GasMeterType]

  status: String

  """
  Details of an ongoing enrolment process.
  """
  enrolment: EnrolmentType

  """
  A list of agents responsible for management of the meterpoint.
  """
  agentContracts("Filter the contracts by status." statuses: [AgentContractStatusType]): [GasAgentContractType]

  """
  A list of gas agreements belonging to an account that is linked to the viewer. Filters out expired agreements by default.
  """
  agreements(validAfter: DateTime, includeInactive: Boolean, "Exclude agreements starting in the future." excludeFuture: Boolean): [GasAgreementType]

  """
  A list of unbilled gas readings for the meterpoint.
  """
  unbilledReadings: [GasMeterReadingType]

  """
  The current MPID for this meter point.
  """
  currentSupplierMpid: String
}

"""
An enumeration.
"""
enum GasMeterPointMarketSectorCode {
  """
  Domestic
  """
  D

  """
  Industrial
  """
  I
}

"""
An enumeration.
"""
enum GasMeterPointMarketCategory {
  """
  SSP
  """
  SSP

  """
  LSP
  """
  LSP
}

"""
An enumeration.
"""
enum GasMeterPointMeterOwnershipType {
  """
  Transporter
  """
  T

  """
  Supplier
  """
  S

  """
  Customer
  """
  C
}

"""
An organization who manages a given meterpoint.
"""
type GasAgentContractType {
  contractType: MamAgentContractContractType!

  agentId: String

  contractStatus: AgentContractStatusType

  effectiveFrom: Date
}

"""
An enumeration.
"""
enum MamAgentContractContractType {
  """
  Meter Asset Manager
  """
  MAM
}

type GasAgreementType implements AgreementInterface {
  id: Int

  validFrom: DateTime

  validTo: DateTime

  agreedFrom: DateTime

  agreedTo: DateTime

  account: AccountType!

  meterPoint: GasMeterPointType!

  tariff: GasTariffType

  isRevoked: Boolean

  """
  A collection of charges and associated consumption data.
  """
  lineItems(startAt: DateTime!, "Aggregate line items according to this grouping. Note that this doesn't guarantee that the returned items will cover a particular length of time, as it will depend on how the items have been stored, whether the period had daylight savings time changes (and therefore potentially 25 hours) etc." grouping: LineItemGroupingOptions!, itemType: LineItemTypeOptions!, "Timezone used for grouping." timezone: String!, before: String, after: String, first: Int, last: Int): LineItemConnection

  """
  List of contracted unit rate uplifts applicable during this agreement's duration. This is only applicable to business accounts where we may pay commission to a third-party intermediary.
  """
  unitRateUplifts: [GasContractUnitRateUplift]
}

type GasTariffType implements TariffType {
  id: ID

  displayName: String

  fullName: String

  description: String

  productCode: String

  standingCharge: Float

  preVatStandingCharge: Float

  """
  Describes a particular tariff by combining the product code, number of rates, available from date and GSP code.
  """
  tariffCode: String

  unitRate: Float

  """
  Is EPG applied to the unit rate.
  """
  unitRateEpgApplied: Boolean

  preVatUnitRate: Float
}

type GasContractUnitRateUplift {
  """
  When this contract is valid from.
  """
  validFrom: DateTime!

  """
  When this contract is valid until.
  """
  validTo: DateTime!

  """
  The amount to add to the unit rate when billing, in pence/kWh.
  """
  unitRateUplift: Decimal!
}

"""
A gas meter reading. The reading value is under the register collection to be consistent with electricity readings. We expect a single register and reading value for gas.
"""
type GasMeterReadingType implements MeterReading {
  id: ID!

  readAt: DateTime

  readingSource: String

  registers: [RegisterReading]

  source: String
}

"""
An enumeration.
"""
enum GasMeterMechanism {
  """
  Credit
  """
  CR

  """
  Electronic Token Meter
  """
  ET

  """
  Prepayment
  """
  PP

  """
  Mechanical Token Meter
  """
  MT

  """
  Coin Meter
  """
  CM

  """
  Thrift
  """
  TH

  """
  Non Compliant SMETS Smart Meter
  """
  NS

  """
  SMETS 1 compliant Smart Meter
  """
  S1

  """
  SMETS 2 compliant Smart Meter
  """
  S2

  """
  Unknown
  """
  U
}

"""
An enumeration.
"""
enum GasMeterStatus {
  """
  Live
  """
  LI

  """
  Faulty
  """
  FA

  """
  Inactive
  """
  IN

  """
  Cut off
  """
  CU

  """
  Clamped
  """
  CL

  """
  Capped
  """
  CA

  """
  Spin Cap
  """
  SP

  """
  Removed
  """
  RE

  """
  Other
  """
  OT

  """
  Unknown
  """
  UN

  """
  Not Installed
  """
  NI
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type GasMeterReadingConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [GasMeterReadingConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `GasMeterReadingConnectionType` and its cursor.
"""
type GasMeterReadingConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: GasMeterReadingType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Gas registers measure consumption.
"""
type GasMeterRegisterType {
  id: ID!

  identifier: String

  digits: Int

  decimalPlaces: Int

  name: String

  expectedReadingRanges: [[Int]]

  unitRateType: String
}

"""
An enumeration.
"""
enum DeviceType {
  """
  Electricity Smart Meter (ESME)
  """
  ESME

  """
  Gas Smart Meter (GSME)
  """
  GSME

  """
  Gas Proxy Function (GPF)
  """
  GPF

  """
  Communications Hub Function (CHF)
  """
  CHF

  """
  HAN Connected Auxiliary Load Control Switch (HCALCS)
  """
  HCALCS

  """
  Prepayment Interface Device (PPMID)
  """
  PPMID

  """
  In-House Display (IHD)
  """
  IHD

  """
  Consumer Access Device (CAD)
  """
  CAD

  """
  IHD or CAD (a type 2 device)
  """
  IHD_OR_CAD
}

"""
An enumeration.
"""
enum DeviceStatus {
  """
  Pending
  """
  PENDING

  """
  Whitelisted
  """
  WHITELISTED

  """
  Installed but not commissioned
  """
  INSTALLED_NOT_COMMISSIONED

  """
  Commissioned
  """
  COMMISSIONED

  """
  Decommissioned
  """
  DECOMMISSIONED

  """
  Withdrawn
  """
  WITHDRAWN

  """
  Suspended
  """
  SUSPENDED

  """
  In recovery
  """
  RECOVERY

  """
  Recovered
  """
  RECOVERED

  """
  Not Applicable
  """
  NOT_APPLICABLE
}

"""
    The mode used by a SMETS2 meter to charge for energy consumed.

    Energy consumption can either be paid for in advance (i.e. prepay / pay-as-you-go)
    or at some time later (i.e. credit).
    
"""
enum PaymentMode {
  """
  Prepayment.
  """
  PREPAY

  """
  Credit.
  """
  CREDIT
}

"""
An enumeration.
"""
enum DeviceStatuses {
  """
  Pending
  """
  PENDING

  """
  Device has been whitelisted
  """
  WHITELISTED

  """
  Installed but not commissioned
  """
  INSTALLED_NOT_COMMISSIONED

  """
  Device has been commissioned
  """
  COMMISSIONED

  """
  Device has been decommissioned
  """
  DECOMMISSIONED

  """
  Device has been withdrawn
  """
  WITHDRAWN

  """
  Decice suspended
  """
  SUSPENDED

  """
  Device is in recovery mode
  """
  RECOVERY

  """
  Device recovered
  """
  RECOVERED

  """
  Not applicable
  """
  NOT_APPLICABLE
}

"""
An enumeration.
"""
enum WANCoverageStrengths {
  """
  WAN coverage for this postcode is high quality.
  """
  HIGH

  """
  WAN coverage for this postcode is medium quality.
  """
  MEDIUM

  """
  WAN coverage for this postcode is low quality.
  """
  LOW
}

"""
A timeslot for which a property can make an appointment for installation of a smart-meter.
"""
type Smets2InstallationTimeslotType {
  appointmentDate: Date

  startTime: Time

  endTime: Time
}

type PropertySearchResult {
  """
  A score representing the degree of confidence for a match.
  """
  score: Decimal!

  """
  The matched property.
  """
  property: PropertyType!
}

"""
The possible errors that can be raised are:

- KT-CT-9403: Received an invalid portfolioId.
- KT-CT-9404: Received an invalid accountUserId.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreatePortfolioUserRole {
  possibleErrors: [PossibleErrorType]

  """
  The created role for a user in association with a portfolio.
  """
  portfolioUserRole: PortfolioUserRoleType
}

"""
The role a user has in association with one portfolio.
"""
type PortfolioUserRoleType {
  id: ID!

  user: AccountUserType!

  """
  The portfolio role.
  """
  role: PortfolioUserRoleEnum

  """
  Portfolio object.
  """
  portfolio: PortfolioType!
}

"""
User objects are the core of the authentication system. They typically represent a customer who manages a portfolio of one or more accounts.
"""
type AccountUserType {
  id: ID!

  """
  List of accounts that the user is linked to either via portfolio role or account role.
  """
  accounts("Optionally filter the user's accounts to only return those linked to portfolios on the specified brands." allowedBrandCodes: [BrandChoices], "Optionally restrict user accounts to only return those linked to portfolios on public facing brands." restrictToPublicFacingBrands: Boolean, "Optionally restrict user accounts to only return those with the specified account numbers." restrictToAccountNumbers: [String], "Optionally exclude accounts with any of the given account types." excludeAccountTypes: [AccountTypeChoices], "Optionally exclude accounts that have never had an agreement." excludeAccountsWithoutAgreements: Boolean): [AccountInterface]

  givenName: String!

  familyName: String!

  email: String!

  mobile: String!

  landline: String!

  title: String

  """
  The user's pronouns e.g. 'she/her', 'he/him', 'they/them'.
  """
  pronouns: String

  """
  Designates whether this user is deceased.
  """
  isDeceased: Boolean!

  """
  The user's secret key to access the Developer API.
  """
  liveSecretKey: String

  """
  List of portfolios that the user is linked to via their portfolio roles.
  """
  portfolios("Optionally filter the user's portfolios to only return those linked to specified brands." allowedBrandCodes: [BrandChoices], "Optionally restrict the user portfolios to only return those linked to public facing brands." restrictToPublicFacingBrands: Boolean, before: String, after: String, first: Int, last: Int): PortfolioConnectionTypeConnection

  """
  AccountUser's date of birth.
  """
  dateOfBirth: Date

  """
  List of details linked to this user.
  """
  details: [AccountUserDetailType]

  """
  We recommend you use fullName instead of this field.
  """
  displayName: String @deprecated(reason: "The 'displayName' field is deprecated.\n\nPlease use fullName instead of this field.\n\n- Marked as deprecated on 2019-12-11.\n- Will be removed on 2024-01-01.")

  """
  We recommend you use preferredName or fullName instead of this field.
  """
  firstName: String @deprecated(reason: "The 'firstName' field is deprecated.\n\nUse 'givenName' instead.\n\n- Marked as deprecated on 2020-09-23.\n- Will be removed on 2023-06-05.")

  """
  We recommend you use preferredName or fullName instead of this field.
  """
  lastName: String @deprecated(reason: "The 'lastName' field is deprecated.\n\nUse 'familyName' instead.\n\n- Marked as deprecated on 2020-09-23.\n- Will be removed on 2023-06-05.")

  """
  The user's full name.
  """
  fullName: String

  """
  The user's preferred name.
  """
  preferredName: String

  """
  We recommend you use portfolioIds instead of this field.
  """
  portfolioId: ID @deprecated(reason: "The 'portfolioId' field is deprecated.\n\nPlease use 'portfolioIds' instead.\n\n- Marked as deprecated on 2022-08-04.\n- Will be removed on 2024-01-01.")

  """
  List of portfolio ids that the user is linked to via their portfolio roles.
  """
  portfolioIds("Optionally filter the user's portfolios to only return those linked to specified brands." allowedBrandCodes: [BrandChoices], "Optionally restrict the user portfolios to only return those linked to public facing brands." restrictToPublicFacingBrands: Boolean): [ID]

  specialCircumstances: SpecialCircumstancesType

  preferences: AccountUserCommsPreferences

  """
  The user's landline phone number.
  """
  landlinePhoneNumber: String @deprecated(reason: "The 'landlinePhoneNumber' field is deprecated.\n\nUse 'landline' instead.\n\n- Marked as deprecated on 2021-03-22.\n- Will be removed on 2024-01-01.")

  """
  List of alternative phone numbers for the account user.
  """
  alternativePhoneNumbers: [String]

  """
  Whether there are family issues.
  """
  hasFamilyIssues: Boolean

  """
  True if user is linked to an account with an active hardship agreement.
  """
  isInHardship: Boolean

  """
  List of roles a user has for each account they're linked to.
  """
  accountUserRoles("Optionally filter the user's account roles to only return those linked to specific accounts." accountNumber: String): [AccountUserRoleType]

  """
  List of roles a user has for each portfolio they're linked to.
  """
  portfolioUserRoles("Optionally filter the portfolio's user roles to only return those linked to a specific portfolio." portfolioNumber: String, "Return the user portfolio roles for this account's portfolio." accountNumber: String): [PortfolioUserRoleType]

  """
  List of hold music options.
  """
  holdMusicChoices: [TrackOptionType]

  isOptedInToWof: Boolean
}

"""
An enumeration.
"""
enum BrandChoices {
  """
  Octopus Energy.
  """
  OCTOPUS_ENERGY

  """
  Affect Energy.
  """
  AFFECT_ENERGY

  """
  Bulb.
  """
  BULB

  """
  Coop Energy.
  """
  COOP_ENERGY

  """
  Ebico Living.
  """
  EBICO_LIVING

  """
  London Power.
  """
  LONDON_POWER
}

"""
Paginator of Operations Team
"""
type PortfolioConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [PortfolioConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `PortfolioConnectionType` and its cursor.
"""
type PortfolioConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: PortfolioType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type AccountUserDetailType {
  """
  The namespace for the property.
  """
  namespace: String

  """
  The property value.
  """
  value: String
}

"""
Information about the special circumstances that relate to a user.
"""
type SpecialCircumstancesType {
  """
  Whether the user has consented for their data to be given to the appropriate industry or regulatory bodies. We typically only ask for this once, so this field can be used to decide whether to ask the user for their initial consent.
  """
  isSharingConsentGiven: Boolean

  records: [SpecialCircumstanceRecordUnion]
}

union SpecialCircumstanceRecordUnion = SpecialCircumstanceRecordType|TemporarySpecialCircumstanceRecordType

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services.
"""
type SpecialCircumstanceRecordType {
  id: ID

  summary: String

  internalCode: String

  gasPSRCode: String

  electricityPSRCode: String
}

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services. These circumstances have an end date, after which they will not longer apply. Having young children is an example of this in the UK.
"""
type TemporarySpecialCircumstanceRecordType {
  id: ID

  summary: String

  internalCode: String

  gasPSRCode: String

  electricityPSRCode: String

  expiryDate: Date
}

"""
Information about the preferences set up for a user.
"""
type AccountUserCommsPreferences {
  """
  Whether a user has opted in to receive messages from the client or client group. For example, for Octopus Energy this describes whether a user is opted in to offers from Octopus Investments.
  """
  isOptedInToClientMessages: Boolean

  """
  Whether a user has opted in to receive messages offering discounts or other services not directly related to the services the client provides.
  """
  isOptedInToOfferMessages: Boolean

  """
  Whether a user has opted in to receive messages we recommend they read, but are not vital to the utilities the client provides. For example, these could be reminders that the client will take a payment.
  """
  isOptedInToRecommendedMessages: Boolean

  """
  Whether a user has opted in to receive messages updating them on client activities.
  """
  isOptedInToUpdateMessages: Boolean

  """
  Whether a user has opted in to receive messages from the client's preferred third parties.
  """
  isOptedInToThirdPartyMessages: Boolean

  """
  What format the user would like to receive their emails in.
  """
  emailFormat: EmailFormats

  """
  Whether a user has opted to have inverted colours in their emails. This is currently only relevant to the Octopus Energy brand, whose emails have a dark background by default.
  """
  isUsingInvertedEmailColours: Boolean

  """
  This setting allows the user to adjust the default font size of the communications sent to them.
  """
  fontSizeMultiplier: Float

  """
  Whether the user has opted in to receive meter reading confirmation emails.
  """
  isOptedInMeterReadingConfirmations: Boolean

  """
  Whether the user has opted in to receive SMS messages.
  """
  isOptedInToSmsMessages: Boolean

  """
  Song which will be used as hold music for the user.
  """
  preferredHoldMusic: Songs
}

"""
An enumeration.
"""
enum EmailFormats {
  TEXT

  HTML
}

"""
An enumeration.
"""
enum Songs {
  """
  .
  """
  NO_SONG_PREFERRED

  """
  Silence.
  """
  SONG_hold_music_4_33_silence

  """
  Relaxing: Holding Firm by Dan Phillipson.
  """
  SONG_hold_music_holding_firm

  """
  "Auf Wiedersehn Sweetheart" by Vera Lynn.
  """
  SONG_1938

  """
  "I Believe" by Frankie Laine.
  """
  SONG_1939

  """
  "Secret Love" by Doris Day.
  """
  SONG_1940

  """
  "Rose Marie" by Slim Whitman.
  """
  SONG_1941

  """
  "Ill Be Home" by Pat Boone.
  """
  SONG_1942

  """
  "Diana" by Paul Anka.
  """
  SONG_1943

  """
  "Jailhouse Rock" by Elvis Presley.
  """
  SONG_1944

  """
  "Living Doll" by Cliff Richard.
  """
  SONG_1945

  """
  "Its Now or Never" by Elvis Presley.
  """
  SONG_1946

  """
  "Wooden Heart" by Elvis Presley.
  """
  SONG_1947

  """
  "I Remember You" by Frank Ifield.
  """
  SONG_1948

  """
  "She Loves You" by The Beatles.
  """
  SONG_1949

  """
  "Cant Buy Me Love" by The Beatles.
  """
  SONG_1950

  """
  "Tears" by Ken Dodd.
  """
  SONG_1951

  """
  "Green, Green Grass of Home" by Tom Jones.
  """
  SONG_1952

  """
  "Release Me" by Engelbert Humperdinck.
  """
  SONG_1953

  """
  "Hey Jude" by The Beatles.
  """
  SONG_1954

  """
  "Sugar, Sugar" by The Archies.
  """
  SONG_1955

  """
  "The Wonder of You" by Elvis Presley.
  """
  SONG_1956

  """
  "My Sweet Lord" by George Harrison.
  """
  SONG_1957

  """
  "Amazing Grace" by The Royal Scots Dragoon Guards Band.
  """
  SONG_1958

  """
  "Tie a Yellow Ribbon Round the Ole Oak Tree" by Dawn.
  """
  SONG_1959

  """
  "Tiger Feet" by Mud.
  """
  SONG_1960

  """
  "Bye Bye Baby" by Bay City Rollers.
  """
  SONG_1961

  """
  "Save Your Kisses for Me" by Brotherhood of Man.
  """
  SONG_1962

  """
  "Mull of Kintyre" / "Girls School" by Wings.
  """
  SONG_1963

  """
  "Rivers of Babylon" / "Brown Girl in the Ring" by Boney M.
  """
  SONG_1964

  """
  "Bright Eyes" by Art Garfunkel.
  """
  SONG_1965

  """
  "Dont Stand So Close to Me" by The Police.
  """
  SONG_1966

  """
  "Dont You Want Me" by The Human League.
  """
  SONG_1967

  """
  "Come On Eileen" by Dexys Midnight Runners.
  """
  SONG_1968

  """
  "Karma Chameleon" by Culture Club.
  """
  SONG_1969

  """
  "I Just Called To Say I Love You" by Stevie Wonder.
  """
  SONG_1970

  """
  "The Power of Love" by Jennifer Rush.
  """
  SONG_1971

  """
  "Dont Leave Me This Way" by The Communards.
  """
  SONG_1972

  """
  "Never Gonna Give You Up" by Rick Astley.
  """
  SONG_1973

  """
  "The Only Way Is Up" by Yazz.
  """
  SONG_1974

  """
  "Ride On Time" by Black Box.
  """
  SONG_1975

  """
  "Unchained Melody" by The Righteous Brothers.
  """
  SONG_1976

  """
  "Everything I Do I Do It for You" by Bryan Adams.
  """
  SONG_1977

  """
  "I Will Always Love You" by Whitney Houston.
  """
  SONG_1978

  """
  "Id Do Anything for Love (But I Wont Do That)" by Meat Loaf.
  """
  SONG_1979

  """
  "Love Is All Around" by Wet Wet Wet.
  """
  SONG_1980

  """
  "Unchained Melody" by Robson & Jerome.
  """
  SONG_1981

  """
  "Killing Me Softly" by Fugees.
  """
  SONG_1982

  """
  "Candle in the Wind 1997" / "Something About the Way You Look Tonight" by Elton John.
  """
  SONG_1983

  """
  "Believe" by Cher.
  """
  SONG_1984

  """
  "...Baby One More Time" by Britney Spears.
  """
  SONG_1985

  """
  "Pure Shores" by All Saints.
  """
  SONG_1986

  """
  "It Wasnt Me" by Shaggy featuring Rikrok.
  """
  SONG_1987

  """
  "Anything Is Possible" / "Evergreen" by Will Young.
  """
  SONG_1988

  """
  "Where Is the Love?" by The Black Eyed Peas.
  """
  SONG_1989

  """
  "Call On Me" by Eric Prydz.
  """
  SONG_1990

  """
  "Is This the Way to Amarillo" by Tony Christie featuring Peter Kay.
  """
  SONG_1991

  """
  "Crazy" by Gnarls Barkley.
  """
  SONG_1992

  """
  "Bleeding Love" by Leona Lewis.
  """
  SONG_1993

  """
  "Hallelujah" by Alexandra Burke.
  """
  SONG_1994

  """
  "Poker Face" by Lady Gaga.
  """
  SONG_1995

  """
  "Just The Way You Are" by Bruno Mars.
  """
  SONG_1996

  """
  "Someone Like You" by Adele.
  """
  SONG_1997

  """
  "Somebody That I Used to Know" by Gotye featuring Kimbra.
  """
  SONG_1998

  """
  "Get Lucky" by Daft Punk.
  """
  SONG_1999

  """
  "Happy" by Pharrell Williams.
  """
  SONG_2000

  """
  "Uptown Funk" by Mark Ronson featuring Bruno Mars.
  """
  SONG_2001

  """
  "7 Years" by Lukas Graham.
  """
  SONG_2002

  """
  "Shape of You" by Ed Sheeran.
  """
  SONG_2003
}

"""
The role a user has in association with one account.
"""
type AccountUserRoleType {
  id: ID!

  user: AccountUserType!

  account: AccountType!

  """
  The account role.
  """
  role: AccountUserRoleEnum
}

"""
An enumeration.
"""
enum AccountUserRoleEnum {
  CARER

  TRACED

  LOYALTY_POINT_USER

  ADMIN
}

"""
Key value pair for the choice of tracks.
"""
type TrackOptionType {
  """
  The title of the track.
  """
  trackTitle: String

  """
  The value save for the user to indicate their choice of track.
  """
  trackCode: String
}

"""
An enumeration.
"""
enum PortfolioUserRoleEnum {
  CARER

  TRACED

  LOYALTY_POINT_USER

  ADMIN
}

input CreatePortfolioUserRoleInput {
  """
  The portfolio to associate the user with.
  """
  portfolioId: ID!

  """
  The user to associate with the portfolio.
  """
  accountUserId: ID!

  """
  The role to assign to the user. If not provided the default role will be used.
  """
  role: PortfolioUserRoleEnum = null
}

type TaskResult {
  """
  The status of the task.
  """
  status: TaskStatusEnum

  """
  The result of the task.
  """
  result: JSONString

  """
  The error message if the task failed.
  """
  error: String
}

"""
An enumeration.
"""
enum TaskStatusEnum {
  STARTED

  FAILED

  FINISHED
}

type AvailableSpinsType {
  """
  Spin information for an electricity agreement.
  """
  electricity: SupplyTypeSpecificSpinsType

  """
  Spin information for a gas agreement.
  """
  gas: SupplyTypeSpecificSpinsType
}

type SupplyTypeSpecificSpinsType {
  """
  The maximum number of spins per month, per fuel type.
  """
  maxSpinsPerMonth: Int

  """
  The number of spins remaining for this month, per fuel type.
  """
  remainingSpinsThisMonth: Int

  """
  The number of spins used this month, per fuel type.
  """
  usedSpinsThisMonth: Int
}

type WheelSegmentsType {
  """
  The integer values that make up the WoF segments.
  """
  segments: [Int]
}

"""
The possible errors that can be raised are:

- KT-CT-7011: Terms must be accepted.
- KT-CT-7023: Unauthorized.
- KT-CT-7010: The account does not have any available submissions.
- KT-CT-7012: Wheel of Fortune submission error.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SpinWheelOfFortune {
  possibleErrors: [PossibleErrorType]

  """
   The result of the Wheel of Fortune spin. 

   

  This field requires the `Authorization` header to be set. 

  """
  spinResult: WheelOfFortuneSpinResultType
}

type WheelOfFortuneSpinResultType {
  """
  The amount won in cents.
  """
  prizeAmount: Int
}

input WheelOfFortuneSpinInput {
  """
  The number of the account for which readings are submitted.
  """
  accountNumber: String!

  """
  The supply type that the spin should be registered for.
  """
  supplyType: SupplyType!

  """
  Indication whether the user has accepted the WoF terms and conditions.
  """
  termsAccepted: Boolean!
}

"""
An enumeration.
"""
enum SupplyType {
  ELECTRICITY

  GAS
}

"""
A greenness forecast entry for a single period of time.
"""
type GreennessForecastPeriod {
  """
  The start of the forecast period (inclusive).
  """
  validFrom: DateTime

  """
  The end of the forecast period (exclusive).
  """
  validTo: DateTime

  """
  The greenness score 0-100 (higher is greener).
  """
  greennessScore: Int

  """
  The greenness index LOW/MEDIUM/HIGH (higher is greener) to map to a localised value.
  """
  greennessIndex: GreennessForecastIndex

  """
  Indicates that this is one of the best periods in the forecast (there may be more than one). This may not consider the entire forecast and can be ignored or calculated client-side from the score.
  """
  highlightFlag: Boolean
}

"""
The greenness index LOW/MEDIUM/HIGH (higher is greener).
"""
enum GreennessForecastIndex {
  LOW

  MEDIUM

  HIGH
}

type CreateAccountFileAttachmentPayload {
  postRequest: UploadPostRequest

  clientMutationId: String
}

"""
Information that should be used in the POST request to the S3 API.

For more details please see [this](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/s3-presigned-urls.html#generating-a-presigned-url-to-upload-a-file).
"""
type UploadPostRequest {
  url: String!

  fields: JSONString!

  key: String!
}

input CreateAccountFileAttachmentInput {
  filename: String!

  accountNumber: String!

  category: Category!

  clientMutationId: String
}

"""
An enumeration.
"""
enum Category {
  FILE_ATTACHMENT_MCS_CERT

  FILE_ATTACHMENT_DNO_LETTER

  FILE_ATTACHMENT_FLEXI_ORB_CERT

  FILE_ATTACHMENT_HEAT_PUMP_HANDOVER_DOCUMENT
}

"""
The possible errors that can be raised are:

- KT-CT-8710: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type TriggerPostUploadOperations {
  possibleErrors: [PossibleErrorType]

  operationsTriggered: Boolean
}

type FanClubStatus {
  """
  The source for the discount, e.g. 'Fan 1' for a wind turbine in UK, or an ERCOT Load Zone for US.
  """
  discountSource: String!

  """
  The list of account numbers for the source and account user.
  """
  accountNumbers: [String]!

  """
  The list of property IDs for the source and account user.
  """
  propertyIds: [Int]!

  """
  The list of catchments that this discount source applies to.
  """
  catchments: [String]!

  """
  The details of Fan Club thresholds for the discount source.
  """
  thresholds: [Threshold]!

  """
  The current or 'live' status of discounts for this source.
  """
  current: DiscountData!

  """
  The historic discounts for this source.
  """
  historic: [DiscountData]!

  """
  The forecasted discount probabilities for this source.
  """
  forecast: DiscountForecast
}

type Threshold {
  """
  The power (kW) that must be surpassed to achieve the corresponding discount.
  """
  power: Decimal

  """
  The discount that is rewarded when the power crosses the corresponding threshold. Ranges from 0.0 - 1.0.
  """
  discount: Decimal

  """
  The wind speed (m/s) that corresponds to the power cut-off for this threshold.
  """
  windSpeed: Decimal
}

type DiscountData {
  """
  Timestamp for the discount.
  """
  startAt: DateTime!

  """
  The discount as a decimal between 0 and 1.
  """
  discount: Decimal!

  """
  This type will return additional market specific information.
      For example, some markets support wind direction, fan speed, wind speed, etc.
      while others do not.
  """
  metaData: FanClubMetadataOutput
}

type FanClubMetadataOutput {
  """
  The instantaneous turbine output power in kW.
  """
  power: Decimal

  """
  The wind speed in m/s.
  """
  windSpeed: Decimal

  """
  A decimal in degrees representing the direction from which the wind is blowing.
      360.0 degrees indicates the wind blows from the north.
      Read more here: https://confluence.ecmwf.int/pages/viewpage.action?pageId=133262398
  """
  windDirection: Decimal

  """
  The turbine's rotor speed in revolutions per minute.
  """
  rotorSpeed: Decimal

  """
  The total amount of electricity grid-wide from wind in megawatts.
  """
  windPowerOnGrid: Decimal

  """
  The total amount of electricity grid-wide from all sources in megawatts.
  """
  totalPowerOnGrid: Decimal

  """
  The proportion of electricity on the grid coming from wind. Ranges from 0.0 - 1.0.
  """
  windPowerProportion: Decimal
}

type DiscountForecast {
  """
  The start time that the ensemble forecast simulation.
  """
  baseTime: DateTime!

  """
  Discount forecast data-points.
  """
  data: [ForecastData]!
}

type ForecastData {
  """
  Timestamp for the data-point.
  """
  validTime: DateTime!

  """
  Projected discount based on ensemble forecast data.
  """
  projectedDiscount: Decimal!

  """
  The best guess for forecasted power (kW).
  """
  powerMedian: Decimal!

  """
  Lower confidence interval bound for forecasted power (kW).
  """
  powerLowerBound: Decimal!

  """
  Upper confidence interval bound for forecasted power (kW).
  """
  powerUpperBound: Decimal!
}

"""
Try to enroll an account onto Fan Club.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-CT-8104: Account already enrolled.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type EnrollFanClubAccount {
  possibleErrors: [PossibleErrorType]

  """
  Result of the Fan Club enrollment.
  """
  enrollmentOutput: EnrollFanClubAccountOutputType
}

type EnrollFanClubAccountOutputType {
  status: Eligibility
}

"""
An enumeration.
"""
enum Eligibility {
  ELIGIBLE

  BUSINESS_ACCOUNT

  NO_ACTIVE_AGREEMENTS

  HAS_SMART_TARIFF

  ONBOARDING_TO_SMART_TARIFF

  INVALID_CATCHMENT

  CAPPED_CATCHMENT

  NO_SMART_METER

  INCORRECT_READ_PERMISSION

  NO_RECENT_READING
}

"""
The input type for signing an account up to Fan Club.
"""
input JoinFanClubInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The list of valid catchment areas.
  """
  catchments: [String]!

  """
  The list of catchments that have exceeded the member cap.
  """
  cappedCatchments: [String]

  """
  User's email address.
  """
  email: String!
}

"""
Send a push notification of there being a high likelihood of getting a Fan Club discount.

The possible errors that can be raised are:

- KT-CT-8106: No catchments provided.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type FanClubDiscountNotification {
  possibleErrors: [PossibleErrorType]

  """
  Boolean indicating if Fan Club notifications were triggered.
  """
  success: Boolean!
}

"""
The input type for sending Fan Club push notifications for discounts.
"""
input FanClubDiscountNotificationInput {
  """
  The list of valid catchment areas.
  """
  catchments: [String]!

  """
  The start time of the likely Fan Club discount.
  """
  startAt: DateTime!

  """
  The end time of the likely Fan Club discount.
  """
  endAt: DateTime!
}

type ControllerStatus {
  """
  The status and telemetry information of a sensor.
  """
  sensors: [SensorStatus]

  """
  The status and telemetry information of a zone.
  """
  zones: [ZoneStatus]
}

type SensorStatus {
  """
  The code name for a sensor.
  """
  code: String

  """
  The connectivity/online status of a sensor.
  """
  connectivity: SensorConnectivity

  """
  The telemetry data of a sensor.
  """
  telemetry: SensorTelemetry
}

type SensorConnectivity {
  """
  Whether or not a sensor is currently online.
  """
  online: Boolean

  """
  Time at which the status was retrieved.
  """
  retrievedAt: DateTime
}

type SensorTelemetry {
  """
  Temperature recorded by a sensor in celsius.
  """
  temperatureInCelsius: Float

  """
  Percentage humidity recorded by the sensor.
  """
  humidityPercentage: Int

  """
  Signal strength of a sensor measured in dBm (Received Signal Strength Indicator).
  """
  rssi: Int

  """
  Deprecated.
  """
  rssiPercentage: Int @deprecated(reason: "The 'rssiPercentage' field is deprecated.\n\nUse rssi instead.\n\n- Marked as deprecated on 2023-05-17.\n- Will be removed on 2023-05-31.")

  """
  Voltage recorded by a sensor.
  """
  voltage: Float

  """
  Time at which the telemetry was retrieved.
  """
  retrievedAt: DateTime
}

type ZoneStatus {
  """
  The heat pump controller zone, i.e. WATER, ZONE_1, ZONE_2 or AUXILIARY.
  """
  zone: Zone

  """
  The telemetry data of a zone.
  """
  telemetry: ZoneTelemetry
}

"""
An enumeration.
"""
enum Zone {
  WATER

  ZONE_1

  ZONE_2

  AUXILIARY
}

type ZoneTelemetry {
  """
  Target temperature for a zone, in celsius.
  """
  setpointInCelsius: Float

  """
  Heating mode in zone.
  """
  mode: Mode

  """
  Whether relay is currently switched on (True) or off (False).
  """
  relaySwitchedOn: Boolean

  """
  Whether there is demand for heat (True) or not (False).
  """
  heatDemand: Boolean

  """
  Time at which the telemetry was retrieved.
  """
  retrievedAt: DateTime
}

"""
An enumeration.
"""
enum Mode {
  ON

  OFF

  AUTO

  BOOST
}

type ControllerAndZoneConfiguration {
  """
  Controller configuration.
  """
  controller: ControllerConfiguration

  """
  List of zones with their configuration and schedules.
  """
  zones: [ZoneInformation]

  """
  Controller configuration.
  """
  heatPump: HeatPumpConfiguration
}

type ControllerConfiguration {
  """
  Controller firmware options for ESP and EFR chips.
  """
  firmwareConfiguration: FirmwareConfiguration

  """
  Current state of the controller.
  """
  state: [State]

  """
  8 character password used to access the access point mode webpage.
  """
  accessPointPassword: String

  """
  Timezone the controller is in.
  """
  heatPumpTimezone: String

  """
  Whether or not the controller is currently connected.
  """
  connected: Boolean

  """
  When the controller was last reset.
  """
  lastReset: DateTime
}

type FirmwareConfiguration {
  """
  ESP32 firmware version (EFI System Partition).
  """
  esp32: String

  """
  EFR32 firmware version (Emergency Firmware Recovery).
  """
  efr32: String

  """
  The EUI of the controller being queried.
  """
  eui: String
}

"""
An enumeration.
"""
enum State {
  NORMAL_MODE

  EMERGENCY_MODE

  FAULT_MODE

  BLE_MODE

  AP_MODE

  SETUP

  FACTORY_RESTORE
}

type ZoneInformation {
  """
  Configuration for a zone.
  """
  configuration: ZoneConfiguration

  """
  The heating schedules being used by this zone.
  """
  schedules: [Schedule]
}

type ZoneConfiguration {
  """
  Code name of the zone.
  """
  code: Zone

  """
  What the zone is used for (heating, water etc).
  """
  zoneType: ZoneType

  """
  Enabled allows zone to heat when `callForHeat` is True.
  """
  enabled: Boolean

  """
  User determined name for a zone.
  """
  displayName: String

  """
  Primary sensor for the zone.
  """
  primarySensor: String

  """
  Current operation.
  """
  currentOperation: ZoneCurrentOperation

  """
  Previous operation.
  """
  previousOperation: ZonePreviousOperation

  """
  Whether the zone is calling for heat.
  """
  callForHeat: Boolean

  """
  Whether there is demand for heat (True) or not (False).
  """
  heatDemand: Boolean

  """
  Default mode, if the zone loses connection to the primary sensor.
  """
  emergency: Boolean

  """
  All associated sensors and ADCs.
  """
  sensors: [SensorConfiguration]
}

enum ZoneType {
  HEAT

  WATER

  AUX

  EXT

  DIV
}

type ZoneCurrentOperation {
  """
  Heating mode in zone.
  """
  mode: Mode

  """
  Target temperature for a zone, in celsius.
  """
  setpointInCelsius: Float

  """
  For zones which do not support setpoints, whether the operation was an ON or an OFF.
  """
  action: OperationAction

  """
  End time for the current operation.
  """
  end: DateTime
}

"""
Whether the action was a turn-on or a turn-off.
"""
enum OperationAction {
  ON

  OFF
}

type ZonePreviousOperation {
  """
  Heating mode in zone.
  """
  mode: Mode

  """
  Target temperature for a zone, in celsius.
  """
  setpointInCelsius: Float

  """
  For zones which do not support setpoints, whether the operation was an ON or an OFF.
  """
  action: OperationAction
}

union SensorConfiguration = ADCSensorConfiguration|ZigbeeSensorConfiguration

type ADCSensorConfiguration implements SensorConfigurationInterface {
  """
  Code name of the sensor.
  """
  code: String

  """
  User determined name for a sensor.
  """
  displayName: String

  """
  Sensor type (NTC).
  """
  type: SensorType

  """
  Whether or not a sensor is enabled.
  """
  enabled: Boolean
}

interface SensorConfigurationInterface {
  """
  Code name of the sensor.
  """
  code: String

  """
  User determined name for a sensor.
  """
  displayName: String
}

"""
An enumeration.
"""
enum SensorType {
  ZIGBEE

  NTC

  TSTAT
}

type ZigbeeSensorConfiguration implements SensorConfigurationInterface {
  """
  Code name of the sensor.
  """
  code: String

  """
  User determined name for a sensor.
  """
  displayName: String

  """
  Sensor type (Zigbee).
  """
  type: SensorType

  """
  Sensor ID.
  """
  id: ID

  """
  Sensor firmware version.
  """
  firmwareVersion: String

  """
  Whether or not boost is enabled for a sensor.
  """
  boostEnabled: Boolean
}

type Schedule {
  """
  A bitmask of the days this program is active for.
  """
  days: String

  """
  The settings which make up this schedule.
  """
  settings: [Setting]
}

type Setting {
  """
  The time this setting becomes active.
  """
  startTime: Time

  """
  Whether the setting turns the zone on or off, or changes its temperature.
  """
  action: String

  """
  Desired zone temperature (for zones which support setpoints).
  """
  setpointInCelsius: Float
}

type HeatPumpConfiguration {
  """
  The serial number of the heat pump.
  """
  serialNumber: String

  """
  The heat pump model (eg. COSY).
  """
  model: String

  """
  The hardware version.
  """
  hardwareVersion: String

  """
  Any fault codes present on the device.
  """
  faultCodes: [String]

  """
  The weather compensation settings currently in place.
  """
  weatherCompensation: WeatherCompensationConfiguration

  """
  The flow temperature set for heating.
  """
  heatingFlowTemperature: FlowTemperatureConfiguration

  """
  Whether the system has a manifold set up.
  """
  manifoldEnabled: Boolean

  """
  Whether the system has a hot water cylinder (tank) which is compatible with heat pumps.
  """
  hasHeatPumpCompatibleCylinder: Boolean

  """
  The maximum temperature which the hot water can be set to.
  """
  maxWaterSetpoint: Float

  """
  The minimum temperature which the hot water can be set to.
  """
  minWaterSetpoint: Float
}

type WeatherCompensationConfiguration {
  """
  Whether weather compensation is enabled or not.
  """
  enabled: Boolean!

  """
  The minimum and maximum temperatures which may be selected, dictated by the device.
  """
  allowableRange: TemperatureRange!

  """
  The min and max flow temperatures currently selected by the user.
  """
  currentRange: TemperatureRange!
}

type TemperatureRange {
  """
  The minimum allowable temperature in range.
  """
  minimum: Temperature

  """
  The maximum allowable temperature in range.
  """
  maximum: Temperature
}

"""
Describes the temperature of something that is relevant to the heating system.
"""
type Temperature {
  """
  The temperature measured.
  """
  value: Decimal

  """
  The units in which the temperature is being measured.
  """
  unit: TemperatureUnit!
}

"""
An enumeration.
"""
enum TemperatureUnit {
  DEGREES_CELSIUS
}

type FlowTemperatureConfiguration {
  """
  The minimum and maximum temperatures which may be selected, dictated by the device.
  """
  allowableRange: TemperatureRange!

  """
  The flow temperature currently selected by the user.
  """
  currentTemperature: Temperature!
}

type ControllerAtLocation {
  """
  The controller attached to the account.
  """
  controller: Controller!

  """
  The model of the heat pump.
  """
  heatPumpModel: String!

  """
  The location at which the device exists.
  """
  location: Location!

  """
  When the controller was provisioned (at this location for this account).
  """
  provisionedAt: DateTime
}

type Controller {
  """
  The EUID of the controller.
  """
  euid: String!
}

type Location {
  """
  The property ID of the location.
  """
  propertyId: ID!
}

"""
A container for some basic metrics relevant to the current state of the heating system.
"""
type LiveTelemetry {
  """
  When these measurements were taken.
  """
  readAt: DateTime!

  """
  The coefficient of performance at the time of measurement.
  """
  coefficientOfPerformance: Decimal

  """
  The power being drawn by the heat pump at a given time.
  """
  powerInput: Power!

  """
  The rate of heat flow from the heat pump at a given time.
  """
  heatOutput: Power!

  """
  The temperature outdoors.
  """
  outdoorTemperature: Temperature!
}

"""
Describes the power (not energy) being consumed (as electricity) or returned (as heat) by
the system at a given point in time.

Differs from `Energy` in that it describes the *rate* at which energy is being transferred at
a given point in time.
"""
type Power {
  """
  The amount of power (not energy) transmitted to or from the heat pump.
  """
  value: Decimal

  """
  The units in which the power is being measured.
  """
  unit: PowerUnit!
}

"""
An enumeration.
"""
enum PowerUnit {
  KILOWATT
}

"""
A container for some basic metrics to show how the heating system has performed over its lifetime.

Note that "its lifetime" may not be the actual life of the heat pump, but may have been reset
when it was last provisioned.
"""
type LifetimeTelemetry {
  """
  When these measurements were taken.
  """
  readAt: DateTime!

  """
  The average lifetime coefficient of performance up to the time of measurement.
  """
  seasonalCoefficientOfPerformance: Decimal

  """
  The electrical energy drawn by the heat pump over its lifetime.
  """
  energyInput: Energy!

  """
  The heat energy emitted by the heat pump over its lifetime.
  """
  heatOutput: Energy!
}

"""
Describes the energy (not power) consumed (as electricity) or returned (as heat) by the
system over a given span of time.

Differs from `Power` in that it describes the *total* amount of energy transferred during a
given time frame (not a single point in time).
"""
type Energy {
  """
  The amount of energy (not power) transmitted to or from the heat pump.
  """
  value: Decimal

  """
  The units in which the power is being measured.
  """
  unit: EnergyUnit!
}

"""
An enumeration.
"""
enum EnergyUnit {
  KILOWATT_HOUR
}

type HeatPumpPerformanceGroupingNode {
  """
  The start datetime of the node.
  """
  startAt: DateTime!

  """
  The end datetime of the node.
  """
  endAt: DateTime!

  """
  The field to show energy input.
  """
  energyInput: Energy

  """
  The field to show energy output.
  """
  energyOutput: Energy

  """
  The field to show outdoor temperature.
  """
  outdoorTemperature: Temperature
}

"""
The time interval that we report the performance for.
"""
enum PerformanceGrouping {
  LIVE

  DAY

  WEEK

  MONTH

  YEAR
}

type HeatPumpTimeRangedPerformance {
  """
  The coefficient of performance (COP) of the heat pump.
  """
  coefficientOfPerformance: Decimal

  """
  The field to show energy input.
  """
  energyInput: Energy!

  """
  The field to show energy output.
  """
  energyOutput: Energy!
}

"""
The possible errors that can be raised are:

- KT-CT-4332: Invalid data.
- KT-CT-4304: Error in preprovisioning step for Octopus Heat Pump.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RequestProvisioningClaimCertificate {
  possibleErrors: [PossibleErrorType]

  """
  The certificate and private key required to create a provisioning claim.
  """
  provisioningClaimBundle: ProvisioningClaimBundle
}

type ProvisioningClaimBundle {
  """
  The certificate which the controller will present to AWS IoT in order to validate its provisioning claim. It will contain the public key of the controller, and be signed by KF.
  """
  certificate: String

  """
  This is the private key which will be used by the controller to make the provisioning claim, encrypted with the public key of the controller.
  """
  encryptedPrivateKey: String

  """
  The AWS IoT endpoint hostname to connect to AWS APIs & services.
  """
  awsIotHostname: String
}

input ProvisioningClaimRequestParameters {
  """
  The EUID of the device we are trying to provision.
  """
  euid: String!

  """
  A string representing the number of whole milliseconds since the epoch.
  """
  timestamp: String!

  """
  The SHA256 hash of the EUID and timestamp.
  """
  nonce: String!

  """
  The signature of the nonce generated by the device's private key.
  """
  signature: String!
}

"""
Turn a heating controller zone ON/OFF, set it to AUTO or BOOST it.

The possible errors that can be raised are:

- KT-CT-4333: Invalid data.
- KT-CT-4306: Error setting mode for heat pump controller zone.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetZoneMode {
  possibleErrors: [PossibleErrorType]

  """
  Unique ID associated with a zone's mode operation.
  """
  transactionId: ID
}

input SetZoneModeParameters {
  """
  The heat pump controller zone, i.e. WATER, ZONE_1, ZONE_2 or AUXILIARY.
  """
  zone: Zone!

  """
  The zone mode, i.e. ON, OFF, AUTO or BOOST.
  """
  mode: Mode!

  """
  Target temperature for a zone in celsius.
  """
  setpointInCelsius: FloatSafeDecimal

  """
  Time at which boost should end.
  """
  endAt: DateTime
}

"""
A subclass of the Decimal type which can handle floating point values gracefully by
converting them to strings before trying to convert them to Decimals.

To see why this is valuable, consider the following python shell session where we construct
Decimal values from floats and strings in turn:

> initial_val = 20.6

> Decimal(initial_val)
  Decimal('20.60000000000000142108547152020037174224853515625')

> Decimal(str(initial_val))
  Decimal('20.6')


* NOTE ON EDGE CASES FOR HIGH PRECISION INPUTS *

Note that cpython itself only retains up to 17 digits of precision for a float, and
disregards the rest, so if your *input* is a really big float, then this won't do you much
good, because:

> str(float('1.11111111111111111111111111111111111111111111111'))
  '1.1111111111111112'

- whereas

> str(Decimal('1.11111111111111111111111111111111111111111111111'))
  '1.11111111111111111111111111111111111111111111111'

But that's not really the problem this class is trying to help with. It's to help with what
look like 'simple' numbers (like 20.2), which end up being converted to very long ones with a
slightly different value when converted to a decimal.
"""
scalar FloatSafeDecimal

"""
De-provision a heating controller device.

The possible errors that can be raised are:

- KT-CT-4307: Error deprovisioning an Octopus heat pump.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type DeprovisionHeatingController {
  possibleErrors: [PossibleErrorType]

  """
  The message to display to the user upon successful device de-provisioning.
  """
  message: String
}

"""
Set a heating controller zone's schedule(s).

The possible errors that can be raised are:

- KT-CT-4334: Invalid data.
- KT-CT-4308: Error setting schedule(s) for heat pump controller zone.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetZoneSchedules {
  possibleErrors: [PossibleErrorType]

  """
  Unique ID associated with adding schedule(s) for a zone.
  """
  transactionId: ID
}

input SetZoneSchedulesParameters {
  """
  The heat pump controller zone, i.e. WATER, ZONE_1, ZONE_2 or AUXILIARY.
  """
  zone: Zone!

  """
  The schedule(s) to be set for a specific zone.
  """
  schedules: [ZoneSchedule]!
}

input ZoneSchedule {
  """
  Days of the week a schedule should be active, Sunday through Saturday, in bitmask format,e.g. Sun, Tue, Wed => 1011000.
  """
  days: String!

  """
  Settings in a schedule for the selected day(s).
  """
  settings: [ScheduleSettings]!
}

input ScheduleSettings {
  """
  Time for when settings should be active, in `HH:MM` (24h) format .
  """
  time: Time!

  """
  Whether this setting turns the zone on or off, or changes its temperature.
  """
  action: String!

  """
  Desired zone temperature (for zones which support setpoints).
  """
  setpointInCelsius: FloatSafeDecimal
}

"""
Remove a sensor from a heating controller device.

The possible errors that can be raised are:

- KT-CT-4309: Error trying to remove sensor from heat pump controller.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RemoveSensor {
  possibleErrors: [PossibleErrorType]

  """
  Unique ID associated with removing a sensor from a heat pump controller.
  """
  transactionId: ID
}

"""
The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type UpdateSensorDisplayName {
  possibleErrors: [PossibleErrorType]

  """
  Unique ID associated with updating a sensor attribute.
  """
  transactionId: ID
}

"""
The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type UpdateWaterSetpoint {
  possibleErrors: [PossibleErrorType]

  """
  Unique ID associated with this operation.
  """
  transactionId: ID
}

"""
The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type BulkUpdateSensorDisplayName {
  possibleErrors: [PossibleErrorType]

  """
  A mapping of transaction ids for each sensor.
  """
  transactionIds: [SensorUpdateTransactionId]
}

"""
A mapping of sensor codes to transaction ids as returned from a successful KF request.
"""
type SensorUpdateTransactionId {
  """
  The code of the sensor which was updated.
  """
  sensorCode: String!

  """
  A UUID representing the update operation for this sensor.
  """
  transactionId: String!
}

"""
A mapping of sensor codes to the display names we would like those sensors to have.
"""
input SensorDisplayNameUpdate {
  """
  The code of the sensor you want to update.
  """
  sensorCode: String!

  """
  The new display name to set for this sensor.
  """
  newDisplayName: String!
}

"""
Reboot a heating controller.

The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
"""
type RebootHeatingController {
  possibleErrors: [PossibleErrorType]

  """
  The unique ID associated with this reboot operation.
  """
  transactionId: ID
}

"""
Set the primary sensor for a zone.

The primary sensor is the one which controls the heating for that zone. Other sensors merely
provide data, at least currently.

The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetZonePrimarySensor {
  possibleErrors: [PossibleErrorType]

  """
  The unique ID associated with this operation.
  """
  transactionId: ID
}

input SetZonePrimarySensorParameters {
  """
  The heat pump controller zone.
  """
  zone: Zone!

  """
  The code for the sensor we want to make primary, such as 'SENSOR01'.
  """
  sensorCode: String!
}

"""
The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type UpdateFlowTemperatureConfiguration {
  possibleErrors: [PossibleErrorType]

  """
  Unique ID associated with this operation.
  """
  transactionId: ID
}

input FlowTemperatureInput {
  """
  Whether weather compensation should be enabled or not.
  """
  useWeatherCompensation: Boolean!

  """
  The min and max temperatures for when weather compensation is enabled.
  """
  weatherCompensationValues: TemperatureRangeInput = null

  """
  Flow temperature if weather compensation is off.
  """
  flowTemperature: TemperatureInput = null
}

"""
An input type to represent a finite temperature range.
"""
input TemperatureRangeInput {
  """
  The minimum allowable temperature in range.
  """
  minimum: TemperatureInput!

  """
  The maximum allowable temperature in range.
  """
  maximum: TemperatureInput!
}

"""
Describes the temperature of something that is relevant to the heating system.
"""
input TemperatureInput {
  """
  The temperature measured.
  """
  value: Decimal!

  """
  The units in which the temperature is being measured.
  """
  unit: TemperatureUnit!
}

"""
Information about an inverter that has been registered with KrakenFlex.
"""
type SmartFlexInverter implements SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard

  """
  The make of the inverter.
  """
  make: String

  """
  The model of the inverter.
  """
  model: String

  """
  Telemetry data for the inverter.
  """
  telemetry: SmartFlexInverterTelemetry
}

"""
Telemetry data for a registered inverter.
"""
type SmartFlexInverterTelemetry {
  """
  Information about the inverter.
  """
  inverter: InverterTelemetry

  """
  Information about the battery.
  """
  battery: BatteryTelemetry

  """
  Information about the solar panels.
  """
  solar: SolarTelemetry

  """
  Information about the grid.
  """
  grid: GridTelemetry

  """
  Information about the site.
  """
  site: SiteTelemetry
}

type InverterTelemetry {
  """
  Whether the inverter is currently connected (online/offline).
  """
  connectionStatus: ConnectionStatus

  """
  The current power of the inverter in kW.
  """
  powerInKw: Decimal
}

"""
    Connection status of the device, provided as part of the telemetry data.
    
"""
enum ConnectionStatus {
  ONLINE

  OFFLINE
}

type BatteryTelemetry {
  """
  Whether the battery is currently connected (online/offline).
  """
  connectionStatus: ConnectionStatus

  """
  The current power of the battery in kW.
  """
  powerInKw: Decimal

  """
  The current state of charge (SoC) of the battery (percentage).
  """
  stateOfCharge: Decimal
}

type SolarTelemetry {
  """
  The current power of the solar panels in kW.
  """
  powerInKw: Decimal
}

type GridTelemetry {
  """
  The current power of the grid in kW.
  """
  powerInKw: Decimal
}

type SiteTelemetry {
  """
  The current consumption of the site in kW (i.e. sum of battery, solar and grid power).
  """
  consumptionInKw: Decimal

  """
  The current export of the site in kW (where 0 means no export).
  """
  exportInKw: Decimal
}

type SmartFlexHeatPump implements SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard

  """
  The make of the heat pump, e.g. Daikin.
  """
  make: String

  """
  The model of the heat pump, e.g. EDLA04E2V3.
  """
  model: String

  """
  The maximum power consumed by the heat pump in kilowatts.
  """
  powerInKw: NormalizedDecimal
}

"""
A subclass of the Decimal type that normalizes the value before converting it into a string.

For example, "4.000" will be converted to "4" and "4.100" will be converted to "4.1".
"""
scalar NormalizedDecimal

type HeatPumpDeviceType {
  krakenflexDeviceId: String

  """
  Always HEAT_PUMPS.
  """
  deviceType: KrakenFlexDeviceTypes @deprecated(reason: "The 'deviceType' field is deprecated.\n\nThe value is always 'HEAT_PUMPS' so this field is redundant.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-06.")

  """
  The third party that provides control of this heat pump.
  """
  provider: ProviderChoices

  params: HeatPumpParamsType
}

type HeatPumpParamsType {
  heatPumpId: ID
}

type HeatPumpStatusType {
  """
  Whether the heat pump is currently connected to the provider.
  """
  isConnected: Boolean

  climateControlStatus: ClimateControlDetailsType

  waterTemperatureStatus: WaterTemperatureDetailsType
}

type ClimateControlDetailsType {
  climateControlEnabled: Boolean

  """
  The target temperature of the room in Celsius
  """
  targetClimateControlTemperature: Decimal

  """
  The current temperature of the room in Celsius
  """
  currentClimateControlTemperature: Decimal
}

type WaterTemperatureDetailsType {
  waterTemperatureEnabled: Boolean

  """
  The current temperature of the hot water tank in Celsius
  """
  currentWaterTemperature: Decimal
}

type HeatPumpVariantsType {
  make: String

  models: [HeatPumpVariantModelsType]
}

type HeatPumpVariantModelsType {
  heatPumpId: ID

  model: String

  powerInKw: Decimal

  isDeprecated: Boolean
}

"""
The possible errors that can be raised are:

- KT-CT-4329: Invalid data.
- KT-CT-4346: Unable to set the room temperature.
- KT-CT-7223: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetRoomTemperature {
  possibleErrors: [PossibleErrorType]

  """
  The customer specific heat pump device details.
  """
  heatPumpDevice: HeatPumpDeviceType
}

input RoomTemperatureInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The temperature the room should be set to. The valid temperature range is between 12 and 30 degrees in increments of 0.5 degrees.
  """
  temperature: Float!
}

"""
The possible errors that can be raised are:

- KT-CT-4336: Unable to set hot water state.
- KT-CT-4301: Unable to find device for given account.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetHotWaterState {
  possibleErrors: [PossibleErrorType]

  """
  The customer specific heat pump device details.
  """
  heatPumpDevice: HeatPumpDeviceType
}

input HotWaterStateInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The state that the hot water device should be set to. A value of true indicates that the device should be turned on, and a value of false indicates it should be switched off. 
  """
  state: Boolean!
}

"""
The possible errors that can be raised are:

- KT-CT-4337: Unable to set climate control state.
- KT-CT-4301: Unable to find device for given account.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetClimateControlState {
  possibleErrors: [PossibleErrorType]

  """
  The customer specific heat pump device details.
  """
  heatPumpDevice: HeatPumpDeviceType
}

input ClimateControlStateInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The state that the climate control device should be set to. A value of true indicates that the device should be turned on, and a value of false indicates it should be switched off. 
  """
  state: Boolean!
}

"""
Register a heat pump.

The possible errors that can be raised are:

- KT-CT-4316: Unable to get provider details.
- KT-CT-4317: Unable to register device.
- KT-CT-4330: Invalid data.
- KT-CT-4331: Invalid data.
- KT-CT-4335: Another device registration is already in progress.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RegisterHeatPump {
  possibleErrors: [PossibleErrorType]

  """
  The customer specific heat pump device details.
  """
  heatPumpDevice: HeatPumpDeviceType
}

input RegisterHeatPumpInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The ID of the property the heat pump belongs to.
  """
  propertyId: Int

  """
  The make, model and power of the heat pump.
  """
  heatPump: HeatPumpInput!

  """
  The provider used to authenticate the device.
  """
  provider: ProviderChoices!

  """
  The authentication details required given the chosen provider.
  """
  authentication: AuthenticationInput!
}

input HeatPumpInput {
  """
  The heat pump variant ID.
  """
  heatPumpId: ID!
}

"""
Information about a vehicle that has been registered with Kraken Flex.
"""
type SmartFlexVehicle implements SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard

  """
  The make of the vehicle, e.g. Tesla.
  """
  make: String

  """
  The model of the vehicle, e.g. Model 3.
  """
  model: String

  """
  The user's preferences for charging this vehicle.
  """
  chargingPreferences: SmartFlexVehicleChargingPreferences
}

"""
The user's preferences for charging, e.g. target SoC (State of Charge).
"""
type SmartFlexVehicleChargingPreferences {
  """
  The time at which the target SoC should be achieved on a weekday.
  """
  weekdayTargetTime: Time!

  """
  The target SoC to achieve on a weekday (percentage).
  """
  weekdayTargetSoc: Int!

  """
  The time at which the target SoC should be achieved on a weekend.
  """
  weekendTargetTime: Time!

  """
  The target SoC to achieve on a weekend (percentage).
  """
  weekendTargetSoc: Int!

  """
  The minimum SoC (percentage).
  """
  minimumSoc: Int

  """
  The maximum SoC (percentage).
  """
  maximumSoc: Int
}

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

"""
Information about a charge point that has been registered with Kraken Flex.
"""
type SmartFlexChargePoint implements SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard

  """
  The make of the charge point, e.g. myenergi.
  """
  make: String

  """
  The model of the charge point, e.g. Zappi.
  """
  model: String

  """
  The user's preferences for charging using this charge point.
  """
  chargingPreferences: SmartFlexVehicleChargingPreferences
}

"""
The current status of a registered vehicle.
"""
type SmartFlexVehicleStatus implements SmartFlexDeviceStatusInterface {
  """
  The current status of the device.
  """
  current: SmartFlexDeviceLifecycleStatus

  """
  Whether control of the device is currently disabled.
  """
  isSuspended: Boolean

  """
  The current state of this SmartFlex device state machine.
  """
  currentState: SmartFlexDeviceState

  """
  Information about the limits for the SoC.
  """
  stateOfChargeLimit: StateOfChargeLimit

  """
  The reason for the most recent failed test dispatch (if any).
  """
  testDispatchFailureReason: TestDispatchAssessmentFailureReason
}

type StateOfChargeLimit {
  """
  Maximum level of charge allowed by the battery relative to its capacity (in percent).
  """
  upperSocLimit: Int

  """
  Time of the latest SoC limit reading.
  """
  timestamp: String

  """
  Whether or not target SoC exceeds upper SoC limit.
  """
  isLimitViolated: Boolean
}

"""
    The reason (if any) that we believe a test dispatch (test charge) did not succeed.
    
"""
enum TestDispatchAssessmentFailureReason {
  NONE

  UNKNOWN

  ASSESSMENTS_FAILED

  NOT_AT_HOME

  UNABLE_TO_COMMUNICATE

  DEVICE_DISCONNECTED

  SOC_LIMIT_REACHED

  ERROR
}

"""
The current status of a registered charge point.
"""
type SmartFlexChargePointStatus implements SmartFlexDeviceStatusInterface {
  """
  The current status of the device.
  """
  current: SmartFlexDeviceLifecycleStatus

  """
  Whether control of the device is currently disabled.
  """
  isSuspended: Boolean

  """
  The current state of this SmartFlex device state machine.
  """
  currentState: SmartFlexDeviceState

  """
  Information about the limits for the SoC.
  """
  stateOfChargeLimit: StateOfChargeLimit

  """
  The reason for the most recent failed test dispatch (if any).
  """
  testDispatchFailureReason: TestDispatchAssessmentFailureReason
}

type OCPPDetailsType {
  url: String

  username: String
}

type OCPPConnectionType {
  isConnected: Boolean
}

type VehicleChargingPreferencesType {
  weekdayTargetTime: String

  weekdayTargetSoc: Int

  weekendTargetTime: String

  weekendTargetSoc: Int

  """
  The minimum state of charge (soc) %, if available.
  """
  minimumSocPercentage: Int

  """
  The maximum state of charge (soc) %, if available.
  """
  maximumSocPercentage: Int
}

type KrakenFlexDeviceType {
  krakenflexDeviceId: String

  """
  The third party that provides control over this device.
  """
  provider: ProviderChoices

  vehicleMake: String

  vehicleModel: String

  vehicleBatterySizeInKwh: Decimal

  chargePointMake: String

  chargePointModel: String

  chargePointPowerInKw: Decimal

  status: String

  suspended: Boolean

  hasToken: Boolean

  createdAt: DateTime

  """
  Maximum state of charge (SoC) limit telemetry.
  """
  stateOfChargeLimit: StateOfChargeLimit

  """
  The reason for the most recent failed test dispatch (if any).
  """
  testDispatchFailureReason: TestDispatchAssessmentFailureReason
}

type UpsideDispatchType {
  """
  The start time of the dispatch.
  """
  start: DateTime!

  """
  The end time of the dispatch.
  """
  end: DateTime!

  """
  This field has been replaced by `start`.
  """
  startDt: String @deprecated(reason: "The 'start_dt' field is deprecated.\n\n`start` has replaced `start_dt` for improved typing.\n\n- Marked as deprecated on 2024-04-19.\n- Will be removed on 2025-01-01.")

  """
  This field has been replaced by `end`.
  """
  endDt: String @deprecated(reason: "The 'end_dt' field is deprecated.\n\n`end` has replaced `end_dt` for improved typing.\n\n- Marked as deprecated on 2024-04-19.\n- Will be removed on 2025-01-01.")

  """
  This field has been replaced by `delta`.
  """
  deltaKwh: Int @deprecated(reason: "The 'delta_kwh' field is deprecated.\n\n`delta` has replaced `deltaKwh` for increased precision.\n\n- Marked as deprecated on 2024-04-19.\n- Will be removed on 2025-01-01.")

  """
  Energy in kWh (import has a negative value).
  """
  delta: Decimal

  meta: UpsideDispatchMetaType
}

type UpsideDispatchMetaType {
  """
  Present for planned dispatches, otherwise `null`. Value can be `smart-charge`, `test-charge` or `bump-charge`.
  """
  source: String

  """
  Present for completed dispatches, otherwise `null`. The only relevant value is `AT_HOME` if present.
  """
  location: String
}

type CostOfChargeType {
  costOfChargeId: String

  krakenflexDeviceId: String

  reportDate: Date

  isSmartCharge: Boolean

  """
  Consumption in kWh.
  """
  totalConsumption: Float

  """
  Cost in pence (excl. tax).
  """
  totalCostExclTax: Float

  """
  Cost in pence (incl. tax).
  """
  totalCostInclTax: Float
}

"""
    The frequency of the cost of charge data to be shown in the consumer app.

    We are generating this data daily, weekly, monthly or annually, with the following
    aggregations:
    daily -> half-hourly aggregation
    weekly & monthly -> daily aggregations
    annually -> monthly aggregations
    
"""
enum DataFrequency {
  DAILY

  WEEKLY

  MONTHLY

  ANNUALLY
}

type ChargePointDevicesType {
  make: String

  models: [ChargePointModelsType]
}

type ChargePointModelsType {
  model: String

  powerInKw: [String]
}

type ChargePointVariantType {
  make: String

  models: [ChargePointVariantModelType]
}

type ChargePointVariantModelType {
  variantId: Int

  model: String

  powerInKw: Decimal

  """
  Supply amperage. Used in markets where customers are more familiar with amps than power output.
  """
  amperage: Int

  isIntegrationLive: Boolean
}

type ElectricVehicleType {
  make: String

  models: [ElectricVehicleModelType]
}

type ElectricVehicleModelType {
  vehicleId: Int

  model: String

  year: Int

  """
  This field is replacing `year`.
  """
  availableFrom: Int

  availableTo: Int

  batterySize: Decimal

  supportedProviders: [String]

  isIntegrationLive: Boolean
}

type EnodeLinkSessionType {
  linkState: String

  linkUrl: String
}

"""
    Available vendors supported by Enode.
    
"""
enum EnodeVendors {
  AUDI

  BMW

  CHEVROLET

  CITROEN

  CUPRA

  DS

  FIAT

  FORD

  HYUNDAI

  JAGUAR

  KIA

  MERCEDES

  MINI

  NISSAN

  OPEL

  PEUGEOT

  PORSCHE

  RENAULT

  SEAT

  SKODA

  TOYOTA

  VAUXHALL

  VOLKSWAGEN

  VOLVO
}

type UserVehiclesType {
  vehicleId: String

  information: VehicleInformationType
}

type VehicleInformationType {
  vin: String

  brand: String

  """
  The model name of the vehicle, if available (e.g. i3s 120).
  """
  model: String

  """
  The year of the vehicle model, if available.
  """
  year: Int

  """
  The (user chosen) display name of the vehicle, if available.
  """
  displayName: String
}

"""
Register a device via intelligent octopus.

Currently, this means an electric vehicle and charge point details.

The possible errors that can be raised are:

- KT-CT-4335: Another device registration is already in progress.
- KT-CT-4321: Serializer validation error.
- KT-CT-4314: Unable to get provider details.
- KT-CT-4351: Provider authentication error.
- KT-CT-4312: Unable to register device.
- KT-CT-4363: No capable devices found.
- KT-CT-4364: Multiple devices found.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RegisterDevice {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

input RegisterDeviceInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The unique vehicle ID of the electric vehicle.
  """
  vehicle: VehicleInput!

  """
  The charger details.
  """
  chargePoint: ChargePointInput!

  """
  The provider used to authenticate the device.
  """
  supportedProvider: ProviderChoices!

  """
  The authentication details required given the chosen provider.
  """
  authentication: AuthenticationInput

  """
  The ID of the property the electric vehicle belongs to.
  """
  propertyId: Int
}

input VehicleInput {
  """
  The unique electric vehicle id.
  """
  vehicleId: Int!
}

input ChargePointInput {
  """
  The charge point make.
  """
  make: String @deprecated(reason: "The 'make' field is deprecated.\n\nPlease use 'chargePointId' instead.\n\n- Marked as deprecated on 2021-12-23.\n- Will be removed on 2024-01-01.")

  """
  The charge point model.
  """
  model: String @deprecated(reason: "The 'model' field is deprecated.\n\nPlease use 'chargePointId' instead.\n\n- Marked as deprecated on 2021-12-23.\n- Will be removed on 2024-01-01.")

  """
  The charge point power (kW).
  """
  power: Decimal @deprecated(reason: "The 'power' field is deprecated.\n\nPlease use 'chargePointId' instead.\n\n- Marked as deprecated on 2021-12-23.\n- Will be removed on 2024-01-01.")

  """
  The unique charge point id.
  """
  chargePointId: ID
}

"""
Delete the connection details for a device registered for a given account number.

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4352: Unable to delete connection details.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type DeleteDeviceConnectionDetails {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

input AccountNumberInput {
  """
  Account number.
  """
  accountNumber: String!
}

"""
Re-authenticate a device. The authentication details provided must be for the
same device as was previously authenticated.

The possible errors that can be raised are:

- KT-CT-4313: Could not find KrakenFlex device.
- KT-CT-4314: Unable to get provider details.
- KT-CT-4315: Unable to re-authenticate device.
- KT-CT-4363: No capable devices found.
- KT-CT-4364: Multiple devices found.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type ReauthenticateDevice {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

input ReauthenticateDeviceInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The authentication details required for the currently authenticated device.
  """
  authentication: AuthenticationInput!

  """
  The most recently registered device of this type will be re-authenticated.
  """
  deviceType: KrakenFlexDeviceTypes!
}

"""
Allow customers to set/update their vehicle's charging preferences.

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4321: Serializer validation error.
- KT-CT-4353: An error occurred while trying to update your charging preferences.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetVehicleChargingPreferences {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

input VehicleChargingPreferencesInput {
  """
  Account number.
  """
  accountNumber: String!

  weekdayTargetTime: String!

  weekdayTargetSoc: Int!

  weekendTargetTime: String!

  weekendTargetSoc: Int!

  targetType: String
}

"""
Initiate a test charge of an electric vehicle (EV).

This is to ensure that the EV or EVSE (charge point) can be controlled remotely and successfully charged for a
short period.

If it is not possible to initiate a test charge, a KT-CT-4355 error will be returned. It may have a
`testChargeRefusalReasons` extension which lists the reasons why the test charge was refused. Possible reasons
include:

- `TC_DEVICE_LIVE` (device is already live)
- `TC_DEVICE_ONBOARDING_IN_PROGRESS` (test dispatch already in progress)
- `TC_DEVICE_RETIRED` (device is retired)
- `TC_DEVICE_SUSPENDED` (device is suspended)
- `TC_DEVICE_DISCONNECTED` (device is disconnected)
- `TC_DEVICE_AWAY_FROM_HOME` (device is away from home)
- `TC_DEVICE_NO_LOCATION_CONFIGURED` (device has no location configured)
- `TC_DEVICE_LOCATION_UNABLE_TO_IDENTIFY` (unable to identify device location)
- `TC_DEVICE_LOCATION_MISSING` (device location is missing)

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4355: Unable to trigger charge.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type PerformTestCharge {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

"""
Initiate a boost charge for an electric vehicle (EV).

This will start charging the EV and will not stop until the battery reaches 100% charged.

If it is not possible to initiate a boost charge, a KT-CT-4357 error will be returned.
It may have a `boostChargeRefusalReasons` extension which lists the reasons why the boost
charge was refused. Possible reasons include:

- `BC_DEVICE_NOT_YET_LIVE` (device is not yet live)
- `BC_DEVICE_RETIRED` (device is retired)
- `BC_DEVICE_SUSPENDED` (device is suspended)
- `BC_DEVICE_DISCONNECTED` (device is disconnected)
- `BC_DEVICE_NOT_AT_HOME` (device is not at home)
- `BC_BOOST_CHARGE_IN_PROGRESS` (boost charge already in progress)

The possible errors that can be raised are:

- KT-CT-4356: A boost charge cannot currently be performed.
- KT-CT-4357: Unable to trigger boost charge.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type PerformBoostCharge {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

"""
The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4354: Unable to cancel boost charge.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type DeleteBoostCharge {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

input DeleteBoostChargeInput {
  """
  Account number.
  """
  accountNumber: String!
}

"""
Suspend control of a device while away from home, e.g. on holiday.

This is to prevent charging during that period.

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4358: Unable to suspend device control.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SuspendDeviceControl {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

"""
Resume control of a device after having been away from home.

This is so that the device can be charged again according to the set preferences.

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4359: Unable to resume device control.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type ResumeDeviceControl {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

"""
Open Charge Point Protocol (OCPP) authentication.

Take the given OCPP authentication details and trigger OCPP authentication.

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4310: Unable to register OCPP authentication details.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type OCPPAuthentication {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: KrakenFlexDeviceType
}

input OCPPAuthenticationInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The OCPP authentication details.
  """
  details: String!
}

"""
Information about a device that has been registered for Smart Flex.
"""
type SmartFlexDevice implements SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard
}

"""
Information about an alert relevant to a device registered for Smart Flex.
"""
type SmartFlexDeviceAlert implements SmartFlexDeviceAlertInterface {
  """
  A device alert message.
  """
  message: String

  """
  When a device alert message is published.
  """
  publishedAt: DateTime
}

"""
Information about the current status of a device registered for Smart Flex.
"""
type SmartFlexDeviceStatus implements SmartFlexDeviceStatusInterface {
  """
  The current status of the device.
  """
  current: SmartFlexDeviceLifecycleStatus

  """
  Whether control of the device is currently disabled.
  """
  isSuspended: Boolean

  """
  The current state of this SmartFlex device state machine.
  """
  currentState: SmartFlexDeviceState
}

type ProviderAuthDetailsType {
  """
  OAuth 2.0 URI for the provider.
  """
  oauthUri: String!
}

"""
An enumeration.
"""
enum ClientType {
  APP

  WEB
}

type AccountIoEligibility {
  """
  Whether account is eligible to register devices with Intelligent Octopus or not.
  """
  isEligibleForIo: Boolean
}

"""
Details of a public key that can be added to devices for end-to-end authentication or encryption.

E.g. for Tesla the user visits a URL and the name can be used to show what the key is called.
https://github.com/teslamotors/vehicle-command#distributing-your-public-key
"""
type ProviderVirtualKeyDetailsType {
  """
  Friendly human-readable name for the virtual key.
  """
  virtualKeyName: String!

  """
  URI for the virtual key.
  """
  virtualKeyUri: String!
}

"""
De-authenticate a registered device.

The possible errors that can be raised are:

- KT-CT-4301: Unable to find device for given account.
- KT-CT-4350: Unable to de-authenticate device.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type DeauthenticateDevice {
  possibleErrors: [PossibleErrorType]

  krakenflexDevice: DeviceDetailsType
}

type DeviceDetailsType {
  krakenflexDeviceId: String

  """
  The third party that provides control over this device.
  """
  provider: ProviderChoices

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes
}

input DeAuthenticationInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The most recently registered device of this type will be de-authenticated.
  """
  deviceType: KrakenFlexDeviceTypes = null
}

"""
Register a device for smart controlling.

Where device refers to batteries, electric vehicles, heat pumps or thermostats.

The possible errors that can be raised are:

- KT-CT-4324: Device already registered error.
- KT-CT-4321: Serializer validation error.
- KT-CT-4312: Unable to register device.
- KT-CT-4363: No capable devices found.
- KT-CT-4364: Multiple devices found.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type DeviceRegistration {
  possibleErrors: [PossibleErrorType]

  """
  Device ID(s) of the registered device(s).
  """
  registeredDeviceIds: [String]
}

input DeviceRegistrationInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The ID of the property the device belongs to.
  """
  propertyId: Int!

  """
  The device type to be registered - batteries, electric vehicles, heat pumps or thermostats.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The provider used to authenticate the device.
  """
  provider: ProviderChoices!

  """
  The device type specific details required for registering a device.
  """
  deviceDetails: DeviceDetailsInput

  """
  The authentication details required given the chosen provider.
  """
  authentication: AuthenticationInput
}

input DeviceDetailsInput {
  """
  Unique device variant id.
  """
  deviceVariantId: ID

  """
  Auxiliary device variant id.
  """
  auxDeviceVariantId: ID
}

input AuthenticationInput {
  """
  SSO access token for the chosen provider authentication.
  """
  accessToken: String

  """
  Provider code from user login used for SSO.
  """
  authorizationCode: String

  """
  SSO refresh token for the chosen provider authentication.
  """
  refreshToken: String

  """
  SSO token expiry for the provider's authentication (integer in seconds).
  """
  expiresIn: Int

  """
  State from user login used for SSO.
  """
  state: String

  """
  ID of the device in the external provider system.
  """
  providerDeviceId: String

  """
  Full redirect URI (including all query string parameters) from the result of an OAuth 2.0 flow.
  """
  redirectUri: String
}

"""
Complete the registration of a device.

The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-4322: Unable to complete registration error.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ThirdPartyCompleteDeviceRegistration {
  possibleErrors: [PossibleErrorType]

  """
  The response showing account validity and optional tariff information.
  """
  success: ThirdPartyCompleteDeviceRegistrationType
}

type ThirdPartyCompleteDeviceRegistrationType {
  """
  If the account is valid.
  """
  isAccountValid: Boolean!

  """
  If a switch to the required tariff is in progress.
  """
  isTariffSwitchInProgress: Boolean!

  """
  The tariff the account is on, if the switch is complete.
  """
  tariff: ThirdPartyTariffsType
}

type ThirdPartyTariffsType {
  """
  Tariff rates of the charging location.
  """
  tariffs: [ThirdPartyTariffType]!

  """
  Tariff intervals of the charging location.
  """
  tariffIntervals: [ThirdPartyTariffIntervalType]!
}

type ThirdPartyTariffType {
  """
  Currency according to the ISO 4217 standard.
  """
  currency: String!

  """
  Price per kWh in the given currency.
  """
  price: Decimal!

  """
  The type of tariff this is (e.g. peak or offPeak).
  """
  type: String!
}

type ThirdPartyTariffIntervalType {
  """
  Local 24hr start time of the tariff interval (format hh:mm).
  """
  startTime: String!

  """
  Local 24hr end time of the tariff interval (format hh:mm).
  """
  endTime: String!

  """
  Day(s) of the week of the tariff interval.
  """
  daysOfWeek: [String]!

  """
  The type of tariff this is (e.g. peak or offPeak).
  """
  tariffType: String!
}

input CompleteDeviceRegistrationInput {
  """
  Account number that the device is registered to.
  """
  accountNumber: String!

  """
  Postcode of the property (linked to the account) that the device is registered to.
  """
  postalCode: String!

  """
  External reference in the third-party system to identify the device.
  """
  externalDeviceIdentifier: String!
}

"""
Create a wizard for onboarding a device with SmartFlex.

The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type StartSmartFlexOnboarding {
  possibleErrors: [PossibleErrorType]

  """
  The wizard created for onboarding the device with SmartFlex.
  """
  wizard: SmartFlexOnboardingWizard
}

input StartSmartFlexOnboardingInput {
  """
  The account to which the device should be registered.
  """
  accountNumber: String!

  """
  The property where the device is located/charged.
  """
  propertyId: Int!
}

"""
Cancel onboarding of a device with SmartFlex.

The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CancelSmartFlexOnboarding {
  possibleErrors: [PossibleErrorType]

  """
  The wizard created for onboarding the device with SmartFlex.
  """
  wizard: SmartFlexOnboardingWizard
}

input CancelSmartFlexOnboardingInput {
  """
  The ID of the SmartFlex onboarding wizard to cancel.
  """
  wizardId: ID!
}

type SmartFlexBattery implements SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard

  """
  Make of the battery.
  """
  make: String

  """
  Model of the battery.
  """
  model: String
}

"""
Some general information about a device.
"""
interface SmartFlexDeviceInterface {
  """
  A UUID that identifies this device registration. Re-registering this device will result in a different ID.
  """
  id: ID!

  """
  The user-friendly name for the device.
  """
  name: String

  """
  The type of device.
  """
  deviceType: KrakenFlexDeviceTypes!

  """
  The third-party that enables control of this device.
  """
  provider: ProviderChoices!

  """
  Information about the current status of this device.
  """
  status: SmartFlexDeviceStatusInterface

  """
  Active alert message(s) for a device, showing the latest first.
  """
  alerts: [SmartFlexDeviceAlertInterface]

  """
  The current onboarding wizard for a device.
  """
  onboardingWizard: SmartFlexOnboardingWizard
}

"""
    The device types that can be controlled by KrakenFlex.
    
"""
enum KrakenFlexDeviceTypes {
  BATTERIES

  ELECTRIC_VEHICLES

  INVERTERS

  HEAT_PUMPS

  STORAGE_HEATERS

  THERMOSTATS
}

"""
    This refers to the provider that is used to authenticate when registering a device.
    
"""
enum ProviderChoices {
  DAIKIN

  ECOBEE

  ENERGIZER

  ENPHASE

  ENODE

  FORD

  GIVENERGY

  HYPERVOLT

  HUAWEI

  INDRA

  JEDLIX

  MYENERGI

  OCPP_WALLBOX

  OHME

  SENSI

  SMARTCAR

  TESLA

  SMART_PEAR

  VP_AMAZON

  VP_HONEYWELL_CC

  VP_HONEYWELL_RES

  VP_NEST
}

interface SmartFlexDeviceStatusInterface {
  """
  The current status of the device.
  """
  current: SmartFlexDeviceLifecycleStatus

  """
  Whether control of the device is currently disabled.
  """
  isSuspended: Boolean

  """
  The current state of this SmartFlex device state machine.
  """
  currentState: SmartFlexDeviceState
}

"""
The current lifecycle status of a KrakenFlex device on the smarter tariff API.
"""
enum SmartFlexDeviceLifecycleStatus {
  ONBOARDING

  PENDING_LIVE

  LIVE

  ONBOARDING_TEST_IN_PROGRESS

  FAILED_ONBOARDING_TEST

  RETIRED
}

enum SmartFlexDeviceState {
  """
  Authentication Pending - ready to start authentication and authorization, or auth is in progress.
  """
  AUTHENTICATION_PENDING

  """
  Authentication Failed - failed to connect and ready to restart authentication and authorization.
  """
  AUTHENTICATION_FAILED

  """
  Authentication Complete - ready to start test (if needed) or pending live where auth or telemetry is delayed.
  """
  AUTHENTICATION_COMPLETE

  """
  Test Charge in Progress - connection and smart control test has successfully started and is occurring.
  """
  TEST_CHARGE_IN_PROGRESS

  """
  Test Charge Failed - connection or smart control test has failed or could not start, ready to retry test.
  """
  TEST_CHARGE_FAILED

  """
  Test Charge Not Available - not currently capable of smart control test (e.g. away from home or unplugged).
  """
  TEST_CHARGE_NOT_AVAILABLE

  """
  Setup Complete - test is complete (if needed) and device is live, but not ready for smart control.
  """
  SETUP_COMPLETE

  """
  Smart Control Capable - live and ready for smart control (e.g. at home and plugged in) but none is scheduled.
  """
  SMART_CONTROL_CAPABLE

  """
  Smart Control in Progress - smart control (e.g. smart charging) is scheduled or is currently occurring.
  """
  SMART_CONTROL_IN_PROGRESS

  """
  Manual Boosting (e.g. bump charging) - user has overridden the schedule to immediately boost (e.g. bump charge now).
  """
  BOOSTING

  """
  Smart Control Off (suspended) - smart control has been (temporarily) disabled (e.g. by the user with holiday mode).
  """
  SMART_CONTROL_OFF

  """
  Smart Control Not Available - not currently capable of smart control (e.g. away from home or unplugged).
  """
  SMART_CONTROL_NOT_AVAILABLE

  """
  Lost Connection - lost connection to the device, ready to re-auth (if not temporary / automatic fix).
  """
  LOST_CONNECTION

  """
  Retired - deleted / de-authed (re-auth not possible, re-register device to onboard again).
  """
  RETIRED
}

interface SmartFlexDeviceAlertInterface {
  """
  A device alert message.
  """
  message: String

  """
  When a device alert message is published.
  """
  publishedAt: DateTime
}

type SmartFlexOnboardingWizard {
  """
  A unique identifier for this SmartFlex onboarding wizard.
  """
  id: ID!

  """
  A Backend Screen that renders the SmartFlex onboarding wizard.
  """
  backendScreen("The maximum version of Backend Screens supported by the client." maxVersionSupported: Int = 1): BackendScreenType
}

"""
A backend screen is the top-level container for mobile UI.
"""
union BackendScreenType = ComponentListType|GenericBackendScreen|Dashboard

"""
A list of components which comprise a screen.

This is a legacy type; GenericBackendScreen should be preferred. This is because API clients
should not need to explicitly query for screen attributes like `items` - these fields are
embedded in the screenData field.
"""
type ComponentListType implements AccessibilityInterface & IdentifiableInterface & BackendScreenInterface {
  """
  Whether the element is hidden from view.
  """
  accessibilityHidden: Boolean

  """
  Accessible description of the element.
  """
  accessibilityLabel: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The name of the screen.
  """
  name: String!

  """
  The refresh / polling frequency in milliseconds.
  """
  refreshFrequency: Int

  """
  Serialized JSON representation of the screen.
  """
  screenData: String

  """
  The list of components.
  """
  items: [ItemType]! @deprecated(reason: "The 'items' field is deprecated.\n\nAccess `items` via `screenData` instead.\n\n- Marked as deprecated on 2024-07-02.\n- Will be removed on 2024-08-01.")
}

"""
Properties relating to the accessibility of features.
"""
interface AccessibilityInterface {
  """
  Whether the element is hidden from view.
  """
  accessibilityHidden: Boolean

  """
  Accessible description of the element.
  """
  accessibilityLabel: String
}

"""
The identity of an object.
"""
interface IdentifiableInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String
}

"""
A backend screen is the top-level container for mobile UI.
"""
interface BackendScreenInterface {
  """
  The name of the screen.
  """
  name: String!

  """
  The refresh / polling frequency in milliseconds.
  """
  refreshFrequency: Int

  """
  Serialized JSON representation of the screen.
  """
  screenData: String
}

"""
Items are sections making up a screen. They can be different types, hence Union.
"""
union ItemType = TextType|ImageType|AnimationType|RectangularButtonType|PillButtonType|CardComponentType

"""
A block of text.
"""
type TextType implements IdentifiableInterface & TextInterface {
  """
  The text content.
  """
  value: String!

  """
  The text style, i.e. header, body.
  """
  textStyle: TextStyleV1

  """
  The text alignment.
  """
  textAlignment: Alignment

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String
}

interface TextInterface {
  """
  The text content.
  """
  value: String!

  """
  The text style, i.e. header, body.
  """
  textStyle: TextStyleV1

  """
  The text alignment.
  """
  textAlignment: Alignment
}

"""
The style is the typographical hierarchy.
These are Typescale Categories from the Mobile Design System (Figma).
"""
enum TextStyleV1 {
  TITLE1

  TITLE2

  TITLE3

  TITLE4

  TITLE5

  TITLE6

  BODY1

  BODY2

  BUTTON_TEXT

  CALLOUT1

  CALLOUT2

  CALLOUT3

  SMALL1

  SMALL2

  SMALL3

  INPUT_TITLE

  TABULAR
}

enum Alignment {
  START

  CENTER

  END
}

"""
A media element containing an image.
"""
type ImageType implements AccessibilityInterface & IdentifiableInterface & SizedItemInterface & MediaInterface {
  """
  The measurement of the element.
  """
  width: ItemSizeType

  """
  The resource URL of the media.
  """
  mediaUrl: String!

  """
  The horizontal alignment of the media.
  """
  horizontalAlignment: Alignment

  """
  Whether the element is hidden from view.
  """
  accessibilityHidden: Boolean

  """
  Accessible description of the element.
  """
  accessibilityLabel: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String
}

"""
Sizes for elements.
"""
interface SizedItemInterface {
  """
  The measurement of the element.
  """
  width: ItemSizeType
}

union ItemSizeType = FractionSizeType|PointsSizeType

"""
A fractional measurement.
"""
type FractionSizeType implements IdentifiableInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The fractional value.
  """
  fraction: Decimal!
}

"""
A measurement in points.
"""
type PointsSizeType implements IdentifiableInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The points value.
  """
  points: Int!
}

"""
The media interface.
"""
interface MediaInterface {
  """
  The resource URL of the media.
  """
  mediaUrl: String!

  """
  The horizontal alignment of the media.
  """
  horizontalAlignment: Alignment
}

"""
A media element containing an animation, such as a Lottie.
"""
type AnimationType implements AccessibilityInterface & IdentifiableInterface & SizedItemInterface & MediaInterface {
  """
  The measurement of the element.
  """
  width: ItemSizeType

  """
  The resource URL of the media.
  """
  mediaUrl: String!

  """
  The horizontal alignment of the media.
  """
  horizontalAlignment: Alignment

  """
  Whether the element is hidden from view.
  """
  accessibilityHidden: Boolean

  """
  Accessible description of the element.
  """
  accessibilityLabel: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String
}

type RectangularButtonType implements IdentifiableInterface & ButtonInterface {
  """
  The button style.
  """
  buttonStyle: ButtonStyle

  """
  Title text of the button.
  """
  title: String!

  """
  The action to perform when the button is pressed.
  """
  buttonAction: ActionType!

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  Colour style of button eg. filled, outlined, text_only.
  """
  variant: ButtonVariance
}

"""
The button interface.
"""
interface ButtonInterface {
  """
  The button style.
  """
  buttonStyle: ButtonStyle

  """
  Title text of the button.
  """
  title: String!

  """
  The action to perform when the button is pressed.
  """
  buttonAction: ActionType!
}

enum ButtonStyle {
  PRIMARY

  SECONDARY
}

"""
Actions are things to do upon a user interaction, such as tapping a button.
"""
union ActionType = DeeplinkActionType|LinkActionType|BackendScreenEventActionType|CloseActionType|ScreenActionType

"""
An action which navigates to the URL of another backend screen.
"""
type DeeplinkActionType implements IdentifiableInterface & ActionInterface {
  """
  The name of the action object's type.
  """
  typeName: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The URL to navigate to.
  """
  url: String!
}

"""
Actions are events created by buttons and other interaction.
"""
interface ActionInterface {
  """
  The name of the action object's type.
  """
  typeName: String
}

"""
An action which navigates to any URL.
"""
type LinkActionType implements IdentifiableInterface & ActionInterface {
  """
  The name of the action object's type.
  """
  typeName: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The URL to navigate to.
  """
  url: String!
}

"""
An action which triggers some event in the Kraken backend.
"""
type BackendScreenEventActionType implements IdentifiableInterface & ActionInterface {
  """
  The name of the action object's type.
  """
  typeName: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The ID of the event to trigger.
  """
  eventId: String!

  """
  List of key-value pairs to pass as parameters to the event.
  """
  params: [BackendScreenParam]!
}

"""
A key-value pair (both Strings) which is passed as a parameter to a screen.
"""
type BackendScreenParam {
  key: String!

  value: String!
}

"""
Closes the screen.
"""
type CloseActionType implements AccessibilityInterface & IdentifiableInterface & ActionInterface {
  """
  The name of the action object's type.
  """
  typeName: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  Whether the element is hidden from view.
  """
  accessibilityHidden: Boolean

  """
  Accessible description of the element.
  """
  accessibilityLabel: String
}

"""
An action which calls another backend screen via its screen id.
"""
type ScreenActionType implements IdentifiableInterface & ActionInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The name of the action object's type.
  """
  typeName: String

  """
  The ID of the screen to navigate to.
  """
  screenId: String!

  """
  Map of the parameters (key-value pairs) to pass to the next backend screen.
  """
  params: [BackendScreenParam]!

  """
  Whether to allow returning to the original caller screen.
  """
  allowBack: Boolean!
}

enum ButtonVariance {
  FILLED

  OUTLINED

  TEXT_ONLY
}

type PillButtonType implements IdentifiableInterface & ButtonInterface {
  """
  The button style.
  """
  buttonStyle: ButtonStyle

  """
  Title text of the button.
  """
  title: String!

  """
  The action to perform when the button is pressed.
  """
  buttonAction: ActionType!

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String
}

"""
A card containing a list of items
"""
type CardComponentType implements AccessibilityInterface & IdentifiableInterface {
  """
  Whether the element is hidden from view.
  """
  accessibilityHidden: Boolean

  """
  Accessible description of the element.
  """
  accessibilityLabel: String

  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The list of components.
  """
  items: [CardItemType]!
}

"""
Items are sections making up a card.
"""
union CardItemType = TextType|ImageType|AnimationType|RectangularButtonType|PillButtonType

"""
A generic backend screen that can be used to define any type of screen.
"""
type GenericBackendScreen implements BackendScreenInterface {
  """
  The name of the screen.
  """
  name: String!

  """
  The refresh / polling frequency in milliseconds.
  """
  refreshFrequency: Int

  """
  Serialized JSON representation of the screen.
  """
  screenData: String
}

"""
A list of components which comprise a dashboard screen.
"""
type Dashboard implements IdentifiableInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The list of sections for a dashboard.
  """
  dashboardItems: [SectionType]!

  """
  The serialised dashboard items.
  """
  serialisedDashboardItems: String!
}

"""
A section containing a list of cards or carousel items
"""
type SectionType implements IdentifiableInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The content of the section.
  """
  content: SectionContent!

  """
  The order of the section.
  """
  order: Int!
}

union SectionContent = CardComponentType|CarouselItemType

type CarouselItemType implements IdentifiableInterface {
  """
  Unique identifier of the object.
  """
  id: ID

  """
  The name of the object's type.
  """
  typename: String

  """
  The list of cards.
  """
  cards: [CardComponentType]!
}

type BatteryDeviceType {
  """
  ID of the device in KrakenFlex.
  """
  krakenflexDeviceId: ID

  """
  Batteries.
  """
  deviceType: KrakenFlexDeviceTypes

  """
  Battery integration provider (make).
  """
  provider: ProviderChoices

  """
  Device specific parameters.
  """
  params: BatteryParamsType

  """
  The current status of the battery (e.g. connected, state of charge, power).
  """
  deviceStatus: DeviceStatusType

  """
  The charging preferences of the battery (e.g. min / max state of charge %).
  """
  chargingPreferences: BatteryChargingPreferencesType
}

type BatteryParamsType {
  """
  ID of the battery variant.
  """
  variantId: ID
}

type DeviceStatusType {
  """
  The lifecycle status of the device.
  """
  status: KrakenFlexDeviceStatusChoices @deprecated(reason: "The 'status' field is deprecated.\n\nPlease use the 'devices' query instead.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-06.")

  """
  Whether control of the device has been temporarily suspended.
  """
  suspended: Boolean

  """
  The maximum import power of the device in kilowatts.
  """
  maxImportInKw: Float

  """
  The maximum export power of the device in kilowatts.
  """
  maxExportInKw: Float

  """
  Whether device is connected.
  """
  pluggedIn: Boolean

  """
  Device status telemetry readings.
  """
  readings: DeviceStatusReadingsType
}

"""
The current lifecycle status of a KrakenFlex device on the smarter tariff API:

- `ONBOARDING` indicates the device has been registered on the system but has not yet completed the on-boarding process.
    - Including a test charge step, to validate that communication and control of the device is possible within expected limits.
- `ONBOARDING_TEST_IN_PROGRESS` indicates that there is a test charge in progress for the device.
- `LIVE` indicates that the device has completed the on-boarding process and is ready for control.
- `FAILED_ONBOARDING_TEST` indicates that there has been an issue validating that the device can be reliably communicated with or controlled on the system.
- `RETIRED` indicates that the device has no connection details and is not currently available for control.
"""
enum KrakenFlexDeviceStatusChoices {
  ONBOARDING

  PENDING_LIVE

  LIVE

  ONBOARDING_TEST_IN_PROGRESS

  FAILED_ONBOARDING_TEST

  RETIRED
}

type DeviceStatusReadingsType {
  """
  Device charging power in kilowatts (kW) - negative for import, positive for export.
  """
  activePowerInKw: DeviceStatusReadingType

  """
  Energy stored in the device in kilowatt-hours (kWh).
  """
  energyInKwh: DeviceStatusReadingType

  """
  State of charge of the battery in % (may not be a whole number).
  """
  socPercentage: DeviceStatusReadingType
}

type DeviceStatusReadingType {
  """
  Value of the reading.
  """
  value: Float!

  """
  Timestamp of the reading.
  """
  timestamp: DateTime!
}

type BatteryChargingPreferencesType {
  """
  The minimum state of charge (soc) %.
  """
  minimumSocPercentage: Int

  """
  The maximum state of charge (soc) %.
  """
  maximumSocPercentage: Int
}

type BatteryVariantsType {
  """
  Make of the home battery.
  """
  make: String

  """
  List of home battery models per make.
  """
  models: [BatteryVariantModelsType]
}

type BatteryVariantModelsType {
  """
  ID of the battery variant.
  """
  variantId: ID

  """
  Model name of the battery.
  """
  model: String

  """
  Coupling type (AC/DC).
  """
  couplingType: BatteryCouplingType

  """
  Usable capacity in kWh.
  """
  batteryCapacityInKwh: Decimal

  """
  Max import/export power in kW.
  """
  maxPowerInKw: Decimal

  """
  Whether an integration/make is live, i.e. available.
  """
  isIntegrationLive: Boolean

  """
  Whether a variant is deprecated.
  """
  isDeprecated: Boolean
}

"""
An enumeration.
"""
enum BatteryCouplingType {
  AC

  DC
}

"""
Allow customers to set/update their battery's charging preferences.

The possible errors that can be raised are:

- KT-CT-4321: Serializer validation error.
- KT-CT-4301: Unable to find device for given account.
- KT-CT-4353: An error occurred while trying to update your charging preferences.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type SetBatteryChargingPreferences {
  possibleErrors: [PossibleErrorType]

  """
  The battery device updated, with the ID of the device in KrakenFlex.
  """
  krakenflexDevice: BatteryDeviceType
}

input BatteryChargingPreferencesInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The minimum state of charge (soc) %.
  """
  minimumSocPercentage: Int!
}

"""
Consumption cost for different smart tariffs.
"""
type SmartTariffComparisonType {
  """
  Total cost for a period.
  """
  currentCost: Float!

  """
  Total cost with tax for a period.
  """
  currentCostWithTax: Float!

  """
  Costs comparisons for available smart tariffs. Note: if product type is not supported or product doesn't have unit rates - it will not be included in response.
  """
  costComparisons: [TariffComparisonType]

  """
  The datetime the consumption readings start.
  """
  consumptionReadingsStartAt: DateTime!

  """
  The datetime the consumption readings end.
  """
  consumptionReadingsEndAt: DateTime!
}

type TariffComparisonType {
  """
  Tariff name.
  """
  tariff: String

  """
  Cost of a tariff.
  """
  cost: Float

  """
  Cost of a tariff with tax.
  """
  costWithTax: Float
}

type SavingSessionsType {
  """
  Info related to a specific account.
  """
  account("Kraken account number." accountNumber: String!): SavingSessionsAccountType

  """
  Saving Sessions events, ordered by start datetime.
  """
  events("Optional argument to include dev events." getDevEvents: Boolean): [SavingSessionsEventType]

  """
  The total number of events.
  """
  eventCount("Optional argument to include dev events." getDevEvents: Boolean): Int

  """
  Combined statistics from all of the Savings Sessions so far.
  """
  nationalAggregatedStats: SavingSessionsNationalAggregatedStatsType

  """
  Prize draw information.
  """
  prizeDrawInformation: SavingSessionsPrizeDrawInformationType
}

type SavingSessionsAccountType {
  """
  Whether the account is eligible to join the campaign.
  """
  canJoinCampaign: Boolean

  """
  Whether the account joined the campaign.
  """
  hasJoinedCampaign: Boolean

  """
  Meterpoints eligible for signup to Saving Sessions.
  """
  eligibleMeterPoints: [EligibleMetersPointsType]

  """
  The meter point signed up to Saving Sessions.
  """
  signedUpMeterPoint: EligibleMetersPointsType

  """
  Whether the account is a business account.
  """
  isBusinessAccount: Boolean

  """
  Whether the account is a tester account for the campaign.
  """
  isTesterAccount: Boolean

  """
  The events that the account has joined.
  """
  joinedEvents: [SavingSessionsAccountJoinedEventsType]

  """
  The event streak history of the account.
  """
  eventStreak: [SavingSessionsAccountEventStreakType]
}

type EligibleMetersPointsType {
  """
  The formatted supply address including postcode.
  """
  address: String

  """
  The valid Saving Sessions MPAN.
  """
  mpan: String
}

type SavingSessionsAccountJoinedEventsType {
  """
  The event ID of the joined event.
  """
  eventId: Int

  """
  The start datetime of the joined event.
  """
  startAt: DateTime

  """
  The end datetime of the joined event.
  """
  endAt: DateTime

  """
  The amount of OctoPoints the account has been awarded for their participation in the event.
  """
  rewardGivenInOctoPoints: Int

  """
  The energy saved in kWh for the event.
  """
  energySavedInKwh: Float

  """
  The outcome of the account's participation of the event.
  """
  status: SavingSessionsAccountEventResultStatusChoices

  """
  The status of the event.
  """
  eventStatus: SavingSessionsAccountEventStatus

  """
  Updated results status.
  """
  resultsStatus: SavingSessionsAccountEventResultStatusChoices

  """
  The saved amount of CO2 in grams for the event.
  """
  co2SavedInGrams: Float

  """
  The total consumption reduction in percentage for the event.
  """
  percentageSaved: Float

  """
  Percent rank amongst all customers that reduced consumption.
  """
  netReductionPctRank: Float

  """
  The average payment amongst all customers per event.
  """
  avgCustomerRemunerationPounds: Float

  """
  How much we thought the customer was going to use over the event period.
  """
  baselineConsumptionDeltaKwh: Float

  """
  How much the customer actually used over the event period.
  """
  consumptionDeltaKwh: Float

  """
  The datetime of when the results were set.
  """
  resultsSetAt: DateTime
}

"""
An enumeration.
"""
enum SavingSessionsAccountEventResultStatusChoices {
  NONE

  CALCULATING

  UPCOMING

  SUCCESS

  PARTIAL_SUCCESS

  FAIL

  MISSING_READINGS
}

"""
An enumeration.
"""
enum SavingSessionsAccountEventStatus {
  UPCOMING

  ONGOING

  DONE
}

type SavingSessionsAccountEventStreakType {
  """
  The start datetime of the joined event.
  """
  eventStartDate: DateTime

  """
  Did the account opt-in to the event.
  """
  isOptedIntoEvent: Boolean

  """
  Dispatch notice time of event (day before, within 1 day, etc).
  """
  dispatchNotice: DispatchNoticeTypeChoices

  """
  The streak point the account had during the event.
  """
  streakPoints: Int
}

"""
    The various dispatch notice time types ecisting in the datalake for saving session events.
    
"""
enum DispatchNoticeTypeChoices {
  DAY_AHEAD

  WITHIN_DAY_1

  WITHIN_DAY_2
}

type SavingSessionsEventType {
  """
  The event ID.
  """
  id: Int

  """
  The event code.
  """
  code: String

  """
  The start of the event.
  """
  startAt: DateTime

  """
  The end of the event.
  """
  endAt: DateTime

  """
  Status of the event.
  """
  status: SavingSessionsAccountEventStatus

  """
  The total number of participants who joined the event.
  """
  totalParticipants: Int

  """
  The number of OctoPoints an account will earn per kWh of energy reduced, if successful.
  """
  rewardPerKwhInOctoPoints: Int

  """
  Whether this this a test event.
  """
  devEvent: Boolean
}

type SavingSessionsNationalAggregatedStatsType {
  """
  The amount of energy saved across all Saving Sessions, in kWh.
  """
  energySavedInKwh: Int

  """
  The equivalent total energy saved in a phrase.
  """
  energySavedEquivalentInWords: String

  """
  The equivalent total CO2 saved in a phrase.
  """
  co2SavedEquivalentInWords: String

  """
  Optional additional context for the CO2e statement.
  """
  co2SavedEquivalentTooltip: String

  """
  The last datetime the stats were updated.
  """
  lastUpdatedAt: DateTime
}

type SavingSessionsPrizeDrawInformationType {
  """
  Whether there is prize draw information to show for the next Saving Session.
  """
  showPrizeDraw: Boolean

  """
  A description of the spot prize for the next Saving Session.
  """
  nextSessionPrizeDescription: String

  """
  A description of the the latest spot prize winner.
  """
  latestAwardedPrizeDescription: String

  """
  The last datetime the prize draw information was updated.
  """
  lastUpdatedAt: DateTime
}

"""
The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-GB-5110: Campaign not found.
- KT-GB-5111: Meter point not found.
- KT-GB-5112: Error joining campaign.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type JoinSavingSessionsCampaign {
  possibleErrors: [PossibleErrorType]

  account: SavingSessionsAccountReturnType
}

"""
The input type for signing an account up to Saving Sessions.
"""
input JoinSavingSessionsCampaignInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The MPAN to be signed up.
  """
  mpan: String!
}

"""
The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-GB-5114: Saving Sessions event not found.
- KT-GB-5116: Account is not part of a Saving Sessions campaign.
- KT-GB-5117: Account ineligible to join Saving Sessions event.
- KT-GB-5115: Error joining event.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type JoinSavingSessionsEvent {
  possibleErrors: [PossibleErrorType]

  """
  The event codes that the account has joined.
  """
  joinedEventCodes: [String]
}

"""
The input type for opting an account in to a Saving Sessions event.
"""
input JoinSavingSessionsEventInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The code of the event the user is trying to sign up to.
  """
  eventCode: String!
}

"""
Referral claim code is a way of claiming promotional benefit coming from the partner-reward referral schemes.
"""
type ReferralClaimCodeType {
  """
  Id of claim code instance.
  """
  id: Int

  """
  Value of claim code.
  """
  value: String

  """
  Referral scheme claim code belongs to.
  """
  referralScheme: ReferralSchemeType

  """
  Account referral associated with the claim code.
  """
  accountReferral: ReferralType

  """
  Datetime when claim code was generated.
  """
  createdAt: DateTime
}

"""
Record the terms have been accepted and progress the workflow.
"""
type AcceptTermsAndConditions {
  """
  Version of terms and conditions that were accepted.
  """
  acceptedVersion: String
}

input AcceptTermsAndConditionsInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The ID of the Enrolment.
  """
  enrolmentId: ID!

  """
  The version of accepted terms and conditions.
  """
  termsVersion: TermsVersionInput!
}

input TermsVersionInput {
  """
  The major version of terms and conditions that were accepted.
  """
  versionMajor: Int!

  """
  The minor version of terms and conditions that were accepted.
  """
  versionMinor: Int!
}

"""
The possible errors that can be raised are:

- KT-GB-6013: Account is not eligible to order a blanket.
- KT-GB-6014: An error occurred placing the order.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type OrderBlanket {
  possibleErrors: [PossibleErrorType]

  """
  Whether the blanket order was placed successfully.
  """
  success: Boolean
}

type ConstantineSpawnData {
  """
  A List of Constantines.
  """
  constantines: [ConstantineSpawn]

  """
  The datetime of when the list of Constantines will expire.
  """
  cacheExpiry: DateTime
}

type ConstantineSpawn {
  """
  The name describing which kind of Constantine this Constantine is.
  """
  displayName: String

  """
  The slug for this kind of Constantine.
  """
  slug: String

  """
  How rare this kind of Constantine is expressed as en enum associated to a percentage value.
  """
  rarity: Rarity

  """
  The description for each kind of Constantine
  """
  description: String

  """
  Unique Identifier for the Constantine.
  """
  spawnId: String
}

"""
An enumeration.
"""
enum Rarity {
  Common

  Uncommon

  Rare

  Epic

  Legendary
}

type GetSnapsResponseType {
  """
  All caught snaps of constantine for the account.
  """
  allSnaps(before: String, after: String, first: Int, last: Int): SnapConnectionTypeConnection

  """
  All available sets of constantine.
  """
  sets: [SnapSetType]
}

type SnapConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [SnapConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `SnapConnectionType` and its cursor.
"""
type SnapConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: SnapType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type SnapType {
  """
  The type of constantine which has been caught.
  """
  constantine: ConstantineType

  """
  When this constantine was caught.
  """
  caughtAt: DateTime
}

type ConstantineType {
  """
  The name describing which kind of Constantine this Constantine is.
  """
  displayName: String

  """
  The slug for this kind of Constantine.
  """
  slug: String

  """
  How rare this kind of Constantine is expressed as en enum associated to a percentage value.
  """
  rarity: Rarity

  """
  The description for each kind of Constantine
  """
  description: String
}

type SnapSetType {
  """
  The name of the set of Constantines.
  """
  displayName: String

  """
  The slug for this kind of Constantine set.
  """
  slug: String

  """
  Is this Constantine set completed (all constantines in set caught).
  """
  isComplete: Boolean

  """
  List of caught Constantines for this set.
  """
  constantinesCaught: [ConstantineType]

  """
  List of Constantines not yet caught for this set.
  """
  constantinesRemaining: [ConstantineType]
}

type OctoplusAccountInfoType {
  """
  Describes whether or not this account is enrolled in the Octoplus campaign.
  """
  isOctoplusEnrolled: Boolean

  """
  Describes whether or not the request user is the nominated user for this account.
  """
  isLoyaltyPointsUser: Boolean

  """
  Information about an account's eligibility for joining the Octoplus campaign.
  """
  octoplusEligibility: OctoplusEligibilityType

  """
  URL for the octoplus snap page if account is eligible.
  """
  octoplusSnapWebUrl: OctoplusSnapWebUrlType
}

type OctoplusEligibilityType {
  """
  Describes whether or not this account is eligible to join the Octoplus campaign.
  """
  isEligible: Boolean

  """
  Describes why an account is ineligible for Octoplus. Will be null if the account is eligible.
  """
  ineligibilityReason: IneligibilityReasons @deprecated(reason: "The 'ineligibilityReason' field is deprecated.\n\nPlease use ineligibility_reasons instead.\n\n- Marked as deprecated on 2023-10-10.\n- Will be removed on 2024-01-01.")

  """
  Returns multiple reasons for why an account is ineligible for Octoplus. Will be empty if the account is eligible.
  """
  ineligibilityReasons: [IneligibilityReasons]
}

"""
An enumeration.
"""
enum IneligibilityReasons {
  OCTOPLUS_DISABLED

  ALREADY_SIGNED_UP

  INCORRECT_BRAND

  NO_PROPERTIES

  NO_ELIGIBLE_METERS

  NO_DIRECT_DEBIT

  ACTIVE_EXCLUSION_CAMPAIGN
}

type OctoplusSnapWebUrlType {
  """
  URL for the octoplus snap page if account is eligible. Eg. 'https://octopus.energy/snap/webview?abcd=efg'.
  """
  url: String!

  """
  Domain for the snap web url, ex. 'octopus.energy'
  """
  domain: String!

  """
  Path for the snap web url, ex. 'snap/webview'
  """
  path: String!
}

type OctoplusFeatureFlagsType {
  """
  Describes whether or not the new Octopoints system should be shown in clients.
  """
  shouldClientDisplayOctopointsV2: Boolean

  """
  Describes whether or not the Octoplus campaign should be shown in clients.
  """
  shouldClientDisplayOctoplus: Boolean

  """
  Describes whether or not rewards should be shown in clients.
  """
  shouldClientDisplayRewards: Boolean

  """
  Describes whether or not Octoplus rewards should be shown in clients.
  """
  shouldClientDisplayOctoplusRewards: Boolean

  """
  Describes whether or not partner rewards should be shown in clients.
  """
  shouldClientDisplayPartnerRewards: Boolean

  """
  Describes whether or not Octoplus partner offers should be shown in clients.
  """
  shouldClientDisplayOctoplusPartnerOffers: Boolean

  """
  Describes whether or not Octoplus Shoptopus offers should be shown in clients.
  """
  shouldClientDisplayOctoplusShoptopusOffers: Boolean

  """
  Describes whether or not Octoplus related offers should be shown in clients.
  """
  shouldClientDisplayOctoplusRelatedOffers: Boolean

  """
  Describes whether or not Octoplus partner offer list should be shown in clients.
  """
  shouldClientDisplayOctoplusPartnerOfferList: Boolean
}

type OctoplusRewardType {
  """
  The unique id of the reward.
  """
  id: Int

  """
  The account number associated with this reward.
  """
  accountNumber: String

  """
  The offer claimed as part of this reward.
  """
  offer: OctoplusOfferType

  """
  The human-readable identifier for the offer.
  """
  offerSlug: String @deprecated(reason: "The 'offer_slug' field is deprecated.\n\nPlease use 'offer.slug' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10.")

  """
  The display name of the offer.
  """
  offerName: String @deprecated(reason: "The 'offer_name' field is deprecated.\n\nPlease use 'offer.name' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10.")

  """
  The price tag for the offer.
  """
  priceTag: String @deprecated(reason: "The 'price_tag' field is deprecated.\n\nPlease use 'offer.price_tag' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10.")

  """
  The name of the reward partner.
  """
  partnerName: String @deprecated(reason: "The 'partner_name' field is deprecated.\n\nPlease use 'offer.partner_name' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10.")

  """
  The instructions for how to use the reward.
  """
  usageInstructions: String @deprecated(reason: "The 'usage_instructions' field is deprecated.\n\nPlease use 'offer.usage_instructions' instead\n\n- Marked as deprecated on 2023-12-21.\n- Will be removed on 2024-02-10.")

  """
  The voucher associated with this reward.
  """
  vouchers: [VoucherType]

  """
  The datetime at which the reward was initially claimed.
  """
  claimedAt: DateTime

  """
  The current status of the reward.
  """
  status: OctoplusRewardStatus
}

type OctoplusOfferType {
  """
  The slug to be used as the offer identifier.
  """
  slug: String

  """
  The name of the offer to be displayed to the user.
  """
  name: String

  """
  The short description of the offer.
  """
  description: String

  """
  The long description of the offer.
  """
  longDescription: String

  """
  The name of the reward partner.
  """
  partnerName: String

  """
  The price tag for this offer.
  """
  priceTag: String

  """
  The points cost of claiming this offer.
  """
  pointsCost: Int

  """
  The available sites url for this offer.
  """
  availableSitesUrl: String

  """
  The partner site url for this offer.
  """
  partnerSiteUrl: String

  """
  The image urls for this offer.
  """
  imageUrls: OctoplusOfferImageUrlsType

  """
  The terms and conditions to display to the user.
  """
  termsAndConditions: String

  """
  The faqs for this offer.
  """
  faqs: [OctoplusOfferFAQsType]

  """
  The instructions for the user as to how to use their claimed reward.
  """
  usageInstructions: String

  """
  The category of the offer.
  """
  category: String

  """
  Describes whether the user should be able to claim this offer, and the reason if not.
  """
  claimAbility: OctoplusRewardClaimAbilityType

  """
  The datetime at which the user should no longer be able to claim this offer.
  """
  claimBy: DateTime
}

type OctoplusOfferImageUrlsType {
  """
  The banner image url.
  """
  banner: String

  """
  The mobile banner url.
  """
  bannerMobile: String

  """
  The logo url.
  """
  logo: String

  """
  The mobile logo url.
  """
  logoMobile: String @deprecated(reason: "The 'logo_mobile' field is deprecated.\n\nPlease use logo instead\n\n- Marked as deprecated on 2023-12-20.\n- Will be removed on 2024-01-10.")
}

type OctoplusOfferFAQsType {
  """
  The FAQ question field.
  """
  question: String

  """
  The FAQ answer field.
  """
  answer: String
}

type OctoplusRewardClaimAbilityType {
  """
  Describes whether the user should be able to claim this offer.
  """
  canClaimOffer: Boolean

  """
  Describes why a user cannot claim this offer.
  """
  cannotClaimReason: CannotClaimReason
}

enum CannotClaimReason {
  OUT_OF_STOCK

  MAX_CLAIMS_PER_PERIOD_REACHED

  INSUFFICIENT_POINTS
}

union VoucherType = OctoplusVoucherType|ShoptopusVoucherType

type OctoplusVoucherType {
  """
  The voucher code.
  """
  code: String

  """
  The type of voucher.
  """
  type: String

  """
  The barcode value/code.
  """
  barcode: String

  """
  The value to be encoded in the rendered barcode.
  """
  barcodeValue: String

  """
  The type of barcode to render.
  """
  barcodeFormat: String

  """
  The datetime at which the voucher will no longer be useable.
  """
  expiresAt: DateTime
}

type ShoptopusVoucherType {
  """
  The voucher code.
  """
  code: String
}

enum OctoplusRewardStatus {
  PENDING

  ISSUED

  CANCELLED
}

type OctoplusOfferGroupConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [OctoplusOfferGroupConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `OctoplusOfferGroupConnectionType` and its cursor.
"""
type OctoplusOfferGroupConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: OctoplusOfferGroupType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type OctoplusOfferGroupType {
  """
  Unique identifier of the Offer Group.
  """
  id: Int!

  """
  The name describing offer group.
  """
  name: String

  """
  The image urls for this offer.
  """
  imageUrls: OctoplusOfferGroupImageUrlsType

  octoplusOffers: [OctoplusOfferType!]!
}

type OctoplusOfferGroupImageUrlsType {
  """
  The mobile banner url.
  """
  bannerMobile: String
}

type ShoptopusVoucherAvailabilityType {
  """
  The voucher value.
  """
  value: Int

  """
  Denotes whether or not this voucher value is currently available.
  """
  availability: Boolean
}

"""
The possible errors that can be raised are:

- KT-GB-9316: Account is not Octoplus-enrolled.
- KT-GB-9325: Invalid constantine slug.
- KT-GB-9326: Invalid spawn ID.
- KT-GB-9319: This feature is not currently available.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type CreateSnap {
  possibleErrors: [PossibleErrorType]

  """
  Returns true if snap was successfully created.
  """
  success: Boolean
}

"""
Sign an account up to Octoplus.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-GB-9310: Account ineligible for joining Octoplus.
- KT-GB-9311: Error joining campaign.
- KT-GB-9312: Account already signed up to Octoplus.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type JoinOctoplusCampaign {
  possibleErrors: [PossibleErrorType]

  """
  Returns mutation success. Deprecated, in favour of the outcome field.
  """
  success: Boolean

  """
  Outcome of the Octoplus and Saving Sessions enrolment.
  """
  outcome: EnrolmentOutcome
}

type EnrolmentOutcome {
  """
  The outcome of the Octoplus enrolment.
  """
  octoplus: OctoplusEnrolmentOutcome

  """
  The outcome of the saving sessions enrolment, null if the account did not opt in to enrol.
  """
  savingSessions: SavingSessionsEnrolmentOutcome
}

type OctoplusEnrolmentOutcome {
  """
  Whether or not this account has been enrolled in the Octoplus campaign.
  """
  hasEnrolled: Boolean
}

type SavingSessionsEnrolmentOutcome {
  """
  Whether or not this account has been enrolled in the Saving Sessions campaign.
  """
  hasEnrolled: Boolean

  """
  The MPAN of the meter point that has been enrolled.
  """
  enrolledMpan: String

  """
  The reason for not enrolling.
  """
  notEnrolledReason: String
}

input SavingSessionsEnrolmentOptions {
  """
  Whether or not the account should enrol in Saving Sessions.
  """
  shouldEnrol: Boolean

  """
  The MPAN of the meter point to enrol with Saving Sessions. If not provided, a random eligible meter point for the account will be selected
  """
  nominatedMpan: String
}

"""
The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
- KT-GB-9313: Not enough Octopoints.
- KT-GB-9314: Reward could not be processed.
- KT-GB-9315: Reward of this type unavailable.
- KT-GB-9316: Account is not Octoplus-enrolled.
- KT-GB-9319: This feature is not currently available.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ClaimShoptopusVoucher {
  possibleErrors: [PossibleErrorType]

  """
  The Reward Voucher code.
  """
  code: String
}

"""
The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
- KT-GB-9313: Not enough Octopoints.
- KT-GB-9314: Reward could not be processed.
- KT-GB-9315: Reward of this type unavailable.
- KT-GB-9316: Account is not Octoplus-enrolled.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ClaimOctoplusReward {
  possibleErrors: [PossibleErrorType]

  """
  The ID of the claimed reward.
  """
  rewardId: String
}

"""
The possible errors that can be raised are:

- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
- KT-GB-9319: This feature is not currently available.
- KT-GB-9323: Could not create contact link.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateOctoplusRewardContactLink {
  possibleErrors: [PossibleErrorType]

  """
  The URL of the customer contact form link.
  """
  url: String
}

type OctocareUsageInfo {
  """
  The Device ID of the smart meter associated with the property of the Cared-For account, which must also have an Octopus Mini device installed.
  """
  meterDeviceId: String!

  """
  The first line of the address of the property associated with the Cared-For account.
  """
  propertyAddressLine1: String!
}

type OctocareOnboardingInfo {
  """
  The Device ID of the communication hub associated with the property of the Cared-For account, which must also have an Octopus Mini device installed.
  """
  chfDeviceId: String!

  """
  The first line of the address of the property associated with the Cared-For account.
  """
  propertyAddressLine1: String!

  """
  The ID of the property the Mini will be onboarded in.
  """
  propertyId: ID!
}

type OctoPointsType {
  """
  Info related to a specific account's wallet.
  """
  account("Kraken account number." accountNumber: String!): OctoPointsAccountType
}

type OctoPointsAccountType {
  """
  The current number of OctoPoints in an account's OctoPoints wallet.
  """
  currentPointsInWallet: Int

  """
  The events for an account's OctoPoints wallet.
  """
  events: [OctoPointsAccountEventType]
}

type OctoPointsAccountEventType {
  """
  The datetime the event happened.
  """
  createdAt: DateTime

  """
  The reason the event happened.
  """
  reason: EventReasonChoices

  """
  The amount of OctoPoints added to an account's wallet (this can be negative).
  """
  pointsAddedToWallet: Int
}

"""
An enumeration.
"""
enum EventReasonChoices {
  SAVING_SESSIONS_REWARD

  AD_HOC_CREDIT

  OCTO_POINTS_CONVERSION

  OCTO_ASSIST_FUND_DONATION
}

"""
Redeem OctoPoints as account credit.

The possible errors that can be raised are:

- KT-CT-4177: Unauthorized.
- KT-GB-5011: Not enough OctoPoints for redemption.
- KT-GB-5010: Error redeeming OctoPoints.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type RedeemOctoPointsForAccountCredit {
  possibleErrors: [PossibleErrorType]

  """
  The number of OctoPoints that were redeemed.
  """
  pointsRedeemed: Int

  """
  The number of OctoPoints remaining in the wallet.
  """
  remainingPointsInWallet: Int
}

"""
The input type for redeeming OctoPoints.
"""
input RedeemOctoPointsInput {
  """
  The account number.
  """
  accountNumber: String!
}

"""
Create an AWS provisioning claim certificate.
"""
type CreateProvisioningClaim {
  """
  The temporary provisioning certification.
  """
  tempProvisioningClaimCert: GenericScalar
}

type WeeklyUsageInsightsType {
  """
  The account identifier.
  """
  accountId: Int

  """
  The meter point identifier.
  """
  meterPointId: Int

  """
  The Monday of the week in question.
  """
  weekStart: DateTime

  """
  The account number of the customer.
  """
  accountNumber: String

  """
  The property identifier.
  """
  propertyId: Int

  """
  Corresponding MPAN.
  """
  mpan: String

  """
  The GSP.
  """
  gspGroupId: String

  """
  The name given to the GSP as per NG API.
  """
  apiGspGroupName: String

  """
  The total consumption over that week period.
  """
  consumptionKwh: String

  """
  The corresponding total grams of C02 over that week period.
  """
  carbonGrams: Float

  """
  Achieved unit rate over that week period.
  """
  achievedCarbonRate: Float

  """
  The corresponding index (very-low, low, moderate, high, very-high).
  """
  achievedCarbonIndex: AchievedCarbonIndexChoices

  """
  The first meter reading we have for this customer within week period.
  """
  periodStart: DateTime

  """
  The last meter reading we have for this customer within week period.
  """
  periodEnd: DateTime

  """
  The number of smart meter readings we have within the week period (should be 336).
  """
  numberPeriods: String

  """
  Whether or not the customer has full readings within the week period.
  """
  hasFullReadings: String

  """
  If the week is the latest week i.e if the date is 2024-03-06 (Wed) then the latest full week should be 2024-02-26 (Mon).
  """
  isLatestWeek: String

  """
  Where the customer ranks for carbon intensity within their region. (1=Greenest, 100=Dirtiest).
  """
  achievedCarbonRank: String
}

"""
An enumeration.
"""
enum AchievedCarbonIndexChoices {
  VERY_LOW

  LOW

  MODERATE

  HIGH

  VERY_HIGH
}

type FieldSalesVisitConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [FieldSalesVisitConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `FieldSalesVisitConnectionType` and its cursor.
"""
type FieldSalesVisitConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: FieldSalesVisitType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A field sales visit at an address.
"""
type FieldSalesVisitType {
  startedAt: DateTime!

  stoppedAt: DateTime!

  addressLine1: String!

  addressLine2: String!

  addressLine3: String!

  """
  Post town
  """
  addressLine4: String!

  """
  County
  """
  addressLine5: String!

  outcome: AppSessionOutcome

  """
  Affiliate Link.
  """
  affiliateLink: AffiliateLinkType

  """
  Field Sales Outcomes.
  """
  outcomes: [FieldSalesVisitOutcomeType]
}

"""
An enumeration.
"""
enum AppSessionOutcome {
  """
  Switched
  """
  SWITCHED

  """
  Switched Business
  """
  SWITCHED_BUSINESS

  """
  Switched (Credit Check Waiver)
  """
  SWITCHED_CREDIT_CHECK_WAIVER

  """
  Switched (First Contact)
  """
  SWITCHED_FIRST_CONTACT

  """
  Switched (Callback)
  """
  SWITCHED_CALLBACK

  """
  Switched (Smart Product)
  """
  SWITCHED_SMART_PRODUCT

  """
  Quoted - no switch
  """
  QUOTED_NO_SWITCH

  """
  Quoted - no sale
  """
  QUOTED_NO_SALE

  """
  Quoted - no sale - quote emailed
  """
  QUOTED_NO_SALE_QUOTE_EMAILED

  """
  Quoted - no sale price
  """
  QUOTED_NO_SALE_PRICE

  """
  Quoted - no sale exit fees
  """
  QUOTED_NO_SALE_EXIT_FEES

  """
  Quoted - no sale no email
  """
  QUOTED_NO_SALE_NO_EMAIL

  """
  Quoted - no sale issue bank details
  """
  QUOTED_NO_SALE_ISSUE_BANK_DETAILS

  """
  Quoted - no sale advanced payment
  """
  QUOTED_NO_SALE_ADVANCED_PAYMENT

  """
  Quoted - no sale standing charge
  """
  QUOTED_NO_SALE_STANDING_CHARGE

  """
  Quoted - no sale paper bills
  """
  QUOTED_NO_SALE_PAPER_BILLS

  """
  Quoted - no sale monthly dd
  """
  QUOTED_NO_SALE_MONTHLY_DD

  """
  Quoted - no sale credit check issue
  """
  QUOTED_NO_SALE_CREDIT_CHECK_ISSUE

  """
  Quoted - no sale waiver wanted
  """
  QUOTED_NO_SALE_WAIVER_WANTED

  """
  Quoted - no sale objected to deposit
  """
  QUOTED_NO_SALE_DEPOSIT

  """
  Quoted - no sale objected to autopay
  """
  QUOTED_NO_SALE_AUTOPAY

  """
  Quoted - no sale prepay too high
  """
  QUOTED_NO_SALE_PREPAY

  """
  Quoted - no sale unsure of current contract
  """
  QUOTED_NO_SALE_UNSURE_OF_CURRENT_CONTRACT

  """
  Quoted - no sale other
  """
  QUOTED_NO_SALE_OTHER

  """
  Pitch - no quote
  """
  PITCH_NO_QUOTE

  """
  No pitch
  """
  NO_PITCH

  """
  No pitch - switched recently
  """
  NO_PITCH_SWITCHED_RECENTLY

  """
  No pitch - vulnerable
  """
  NO_PITCH_VULNERABLE

  """
  No pitch - no d2d
  """
  NO_PITCH_NO_D2D

  """
  No pitch - not interested
  """
  NO_PITCH_NOT_INTERESTED

  """
  No pitch - TPI/third party
  """
  NO_PITCH_TPI_THIRD_PARTY

  """
  Pitch no quote - switched recently
  """
  PITCH_NO_QUOTE_SWITCHED_RECENTLY

  """
  Pitch no quote - price
  """
  PITCH_NO_QUOTE_PRICE

  """
  Pitch no quote - in contract
  """
  PITCH_NO_QUOTE_IN_CONTRACT

  """
  Pitch no quote - no email
  """
  PITCH_NO_QUOTE_NO_EMAIL

  """
  Pitch no quote - not interested
  """
  PITCH_NO_QUOTE_NOT_INTERESTED

  """
  Pitch no quote - advanced payment
  """
  PITCH_NO_QUOTE_ADVANCED_PAYMENT

  """
  Callback
  """
  CALLBACK

  """
  Quoted - callback
  """
  QUOTED_CALLBACK

  """
  Callback - pitched
  """
  CALLBACK_PITCHED

  """
  No answer
  """
  NO_ANSWER

  """
  Not bill payer
  """
  NOT_BILL_PAYER

  """
  Not decision maker
  """
  NOT_DECISION_MAKER

  """
  Busy
  """
  BUSY

  """
  Multiple properties owned
  """
  MULTIPLE_PROPERTIES

  """
  Callback - courtesy call
  """
  CALLBACK_COURTESY_CALL

  """
  Dont call again
  """
  DONT_CALL_AGAIN

  """
  No cold calling
  """
  NO_COLD_CALLING

  """
  Sheltered housing
  """
  SHELTERED_HOUSING

  """
  No fixed address
  """
  NO_FIXED_ADDRESS

  """
  Occupy account
  """
  OCCUPY_ACCOUNT

  """
  Occupier - not bill payer
  """
  OCCUPIER_NOT_BILL_PAYER

  """
  Occupier - no answer
  """
  OCCUPIER_NO_ANSWER

  """
  Occupier - refused to discuss
  """
  OCCUPIER_REFUSED_TO_DISCUSS

  """
  Occupier - suspected empty property
  """
  OCCUPIER_SUSPECTED_EMPTY_PROPERTY

  """
  Meter reading
  """
  METER_READING

  """
  Meter reading - unable to take reading
  """
  METER_READING_UNABLE_TO_TAKE_READING

  """
  Meter reading - no answer
  """
  METER_READING_NO_ANSWER

  """
  Energy help visit - completed
  """
  ENERGY_HELP_VISIT_COMPLETED

  """
  Energy help visit - leaflet left
  """
  ENERGY_HELP_VISIT_LEAFLET

  """
  PSR registered
  """
  PSR_REGISTERED

  """
  Smart meter registered
  """
  SMART_METER_REGISTERED

  """
  Consumer app download
  """
  CONSUMER_APP_DOWNLOAD

  """
  EBSS voucher check in
  """
  EBSS_VOUCHER_CHECK_IN

  """
  PPM requested
  """
  PPM_REQUESTED

  """
  COT proven
  """
  COT_PROVEN

  """
  COT no proof
  """
  COT_NO_PROOF

  """
  COS
  """
  COS

  """
  Paid in full
  """
  PAID_IN_FULL

  """
  Payment plan
  """
  PAYMENT_PLAN

  """
  Paid partial
  """
  PAID_PARTIAL

  """
  Paid reduced settlement
  """
  PAID_REDUCED_SETTLEMENT

  """
  Insolvency
  """
  INSOLVENCY

  """
  Exhausted - no contact
  """
  EXHAUSTED_NO_CONTACT

  """
  Exhausted - contact
  """
  EXHAUSTED_CONTACT

  """
  Unable to locate
  """
  UNABLE_TO_LOCATE

  """
  Empty
  """
  EMPTY

  """
  Demolished
  """
  DEMOLISHED

  """
  Unable to trace
  """
  UNABLE_TO_TRACE

  """
  Prison
  """
  PRISON

  """
  Vulnerable
  """
  VULNERABLE

  """
  Deceased
  """
  DECEASED

  """
  Withdrawn
  """
  WITHDRAWN

  """
  Query
  """
  QUERY

  """
  Wrong address selected
  """
  WRONG_ADDRESS_SELECTED

  """
  Prepayment meter
  """
  PREPAYMENT_METER

  """
  Already an existing customer
  """
  EXISTING_CUSTOMER

  """
  Lead generation
  """
  LEAD_GENERATION

  """
  Electric vehicle lead generation
  """
  LEAD_GENERATION_EV

  """
  Electric juice switch & lead generation
  """
  LEAD_GENERATION_EJ

  """
  Electric juice lite switch & lead generation
  """
  LEAD_GENERATION_EJ_LITE

  """
  Business lead generation
  """
  LEAD_GENERATION_BUSINESS

  """
  Solar lead generation
  """
  LEAD_GENERATION_SOLAR

  """
  Heat pump lead generation
  """
  LEAD_GENERATION_HEAT_PUMP

  """
  Property ineligible
  """
  PROPERTY_INELIGIBLE

  """
  Electric juice switch
  """
  ELECTRIC_JUICE_SWITCH

  """
  Electric juice lite switch
  """
  ELECTRIC_JUICE_SWITCH_LITE

  """
  Electric juice not interested
  """
  ELECTRIC_JUICE_NOT_INTERESTED

  """
  Vulnerability project
  """
  VULNERABILITY_PROJECT

  """
  The customer was transferred to another team/agent
  """
  TRANSFERRED
}

"""
Affiliate link for the organization.
"""
type AffiliateLinkType {
  id: ID!

  organisation: AffiliateOrganisationType

  subdomain: String!

  trainingStatus: LinkTrainingStatus!

  isBusiness: Boolean!

  contactName: String!

  contactEmail: String!

  landingUrl: String!
}

type AffiliateOrganisationType {
  id: ID!

  name: String!

  """
  Sales Channel
  """
  salesChannel: SalesChannelChoices

  """
  Allow performing tariff renewals via API.
  """
  canRenewTariffs: Boolean

  """
  Default Account Type
  """
  defaultAccountType: AccountTypeChoices

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """
  Allow registration requests with customers without an email address.
  """
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""
An enumeration.
"""
enum SalesChannelChoices {
  DIRECT

  PRICE_COMPARISON

  TELESALES

  DIGI_TELESALES

  EVENTS

  FIELD_SALES

  AGGREGATOR

  PARTNERSHIPS

  NEW_TENANT

  MOVE_IN

  WORKPLACE_POP_UP

  BROKER

  PARENT_POWER

  PEOPLE_POWER

  GIFT_OF_KIT

  HIGH_REFERRER

  SUPPLIER_OF_LAST_RESORT

  ACQUISITION

  WORKS_WITH_OCTOPUS

  LANDLORD

  DEBT_COLLECTION_AGENCY

  OCTOPUS_TRUSTED_PARTNERS
}

"""
An enumeration.
"""
enum LinkTrainingStatus {
  """
  Not applicable
  """
  NOT_APPLICABLE

  """
  In training
  """
  IN_TRAINING

  """
  Qualified
  """
  QUALIFIED
}

"""
The specific outcome of a field sales visit at an address.
"""
type FieldSalesVisitOutcomeType {
  type: AppSessionOutcomeType!

  category: AppSessionOutcomeCategory

  reason: String
}

"""
An enumeration.
"""
enum AppSessionOutcomeType {
  """
  Sale
  """
  SALE

  """
  Business Sale
  """
  BUSINESS_SALE

  """
  Occupier
  """
  OCCUPIER

  """
  Meter Reading
  """
  METER_READING

  """
  Electroverse Lead
  """
  ELECTROVERSE_LEAD

  """
  Electroverse
  """
  ELECTROVERSE

  """
  Ev Lead
  """
  EV_LEAD

  """
  Energy Help
  """
  ENERGY_HELP

  """
  Solar Lead
  """
  SOLAR_LEAD

  """
  Ev Charger
  """
  EV_CHARGER

  """
  Heat Pump Lead
  """
  HEAT_PUMP_LEAD

  """
  Intelligent Octopus Signup
  """
  INTELLIGENT_OCTOPUS_SIGNUP

  """
  Credit
  """
  CREDIT

  """
  Unknown
  """
  UNKNOWN

  """
  Lead
  """
  LEAD

  """
  Business Lead
  """
  BUSINESS_LEAD

  """
  Electric Universe
  """
  ELECTRIC_UNIVERSE

  """
  Energy Support
  """
  ENERGY_SUPPORT
}

"""
An enumeration.
"""
enum AppSessionOutcomeCategory {
  """
  Success
  """
  SUCCESS

  """
  Quoted No Switch
  """
  QUOTED_NO_SWITCH

  """
  Quoted No Sale
  """
  QUOTED_NO_SALE

  """
  Pitch No Quote
  """
  PITCH_NO_QUOTE

  """
  No Pitch
  """
  NO_PITCH

  """
  Callback
  """
  CALLBACK

  """
  Unsuccessful
  """
  UNSUCCESSFUL

  """
  Dont Call Again
  """
  DONT_CALL_AGAIN

  """
  Psr Registered
  """
  PSR_REGISTERED

  """
  Smart Meter Registered
  """
  SMART_METER_REGISTERED

  """
  Consumer App Download
  """
  CONSUMER_APP_DOWNLOAD

  """
  Vulnerability Project
  """
  VULNERABILITY_PROJECT

  """
  Transferred
  """
  TRANSFERRED

  """
  Unknown
  """
  UNKNOWN

  """
  Switched
  """
  SWITCHED

  """
  Switched Business
  """
  SWITCHED_BUSINESS

  """
  Switched Credit Check Waiver
  """
  SWITCHED_CREDIT_CHECK_WAIVER

  """
  Switched First Contact
  """
  SWITCHED_FIRST_CONTACT

  """
  Switched Callback
  """
  SWITCHED_CALLBACK

  """
  Switched Smart Product
  """
  SWITCHED_SMART_PRODUCT

  """
  Quoted No Sale Quote Emailed
  """
  QUOTED_NO_SALE_QUOTE_EMAILED

  """
  Quoted No Sale Price
  """
  QUOTED_NO_SALE_PRICE

  """
  Quoted No Sale Exit Fees
  """
  QUOTED_NO_SALE_EXIT_FEES

  """
  Quoted No Sale No Email
  """
  QUOTED_NO_SALE_NO_EMAIL

  """
  Quoted No Sale Issue Bank Details
  """
  QUOTED_NO_SALE_ISSUE_BANK_DETAILS

  """
  Quoted No Sale Advanced Payment
  """
  QUOTED_NO_SALE_ADVANCED_PAYMENT

  """
  Quoted No Sale Standing Charge
  """
  QUOTED_NO_SALE_STANDING_CHARGE

  """
  Quoted No Sale Paper Bills
  """
  QUOTED_NO_SALE_PAPER_BILLS

  """
  Quoted No Sale Monthly Dd
  """
  QUOTED_NO_SALE_MONTHLY_DD

  """
  Quoted No Sale Credit Check Issue
  """
  QUOTED_NO_SALE_CREDIT_CHECK_ISSUE

  """
  Quoted No Sale Waiver Wanted
  """
  QUOTED_NO_SALE_WAIVER_WANTED

  """
  Quoted No Sale Deposit
  """
  QUOTED_NO_SALE_DEPOSIT

  """
  Quoted No Sale Autopay
  """
  QUOTED_NO_SALE_AUTOPAY

  """
  Quoted No Sale Prepay
  """
  QUOTED_NO_SALE_PREPAY

  """
  Quoted No Sale Unsure Of Current Contract
  """
  QUOTED_NO_SALE_UNSURE_OF_CURRENT_CONTRACT

  """
  Quoted No Sale Other
  """
  QUOTED_NO_SALE_OTHER

  """
  No Pitch Switched Recently
  """
  NO_PITCH_SWITCHED_RECENTLY

  """
  No Pitch Vulnerable
  """
  NO_PITCH_VULNERABLE

  """
  No Pitch No D2D
  """
  NO_PITCH_NO_D2D

  """
  No Pitch Not Interested
  """
  NO_PITCH_NOT_INTERESTED

  """
  No Pitch Tpi Third Party
  """
  NO_PITCH_TPI_THIRD_PARTY

  """
  Pitch No Quote Switched Recently
  """
  PITCH_NO_QUOTE_SWITCHED_RECENTLY

  """
  Pitch No Quote Price
  """
  PITCH_NO_QUOTE_PRICE

  """
  Pitch No Quote In Contract
  """
  PITCH_NO_QUOTE_IN_CONTRACT

  """
  Pitch No Quote No Email
  """
  PITCH_NO_QUOTE_NO_EMAIL

  """
  Pitch No Quote Not Interested
  """
  PITCH_NO_QUOTE_NOT_INTERESTED

  """
  Pitch No Quote Advanced Payment
  """
  PITCH_NO_QUOTE_ADVANCED_PAYMENT

  """
  Quoted Callback
  """
  QUOTED_CALLBACK

  """
  Callback Pitched
  """
  CALLBACK_PITCHED

  """
  No Answer
  """
  NO_ANSWER

  """
  Not Bill Payer
  """
  NOT_BILL_PAYER

  """
  Not Decision Maker
  """
  NOT_DECISION_MAKER

  """
  Busy
  """
  BUSY

  """
  Multiple Properties
  """
  MULTIPLE_PROPERTIES

  """
  Callback Courtesy Call
  """
  CALLBACK_COURTESY_CALL

  """
  No Cold Calling
  """
  NO_COLD_CALLING

  """
  Sheltered Housing
  """
  SHELTERED_HOUSING

  """
  No Fixed Address
  """
  NO_FIXED_ADDRESS

  """
  Occupy Account
  """
  OCCUPY_ACCOUNT

  """
  Occupier Not Bill Payer
  """
  OCCUPIER_NOT_BILL_PAYER

  """
  Occupier No Answer
  """
  OCCUPIER_NO_ANSWER

  """
  Occupier Refused To Discuss
  """
  OCCUPIER_REFUSED_TO_DISCUSS

  """
  Occupier Suspected Empty Property
  """
  OCCUPIER_SUSPECTED_EMPTY_PROPERTY

  """
  Meter Reading
  """
  METER_READING

  """
  Meter Reading Unable To Take Reading
  """
  METER_READING_UNABLE_TO_TAKE_READING

  """
  Meter Reading No Answer
  """
  METER_READING_NO_ANSWER

  """
  Energy Help Visit Completed
  """
  ENERGY_HELP_VISIT_COMPLETED

  """
  Energy Help Visit Leaflet
  """
  ENERGY_HELP_VISIT_LEAFLET

  """
  Ebss Voucher Check In
  """
  EBSS_VOUCHER_CHECK_IN

  """
  Wrong Address Selected
  """
  WRONG_ADDRESS_SELECTED

  """
  Prepayment Meter
  """
  PREPAYMENT_METER

  """
  Existing Customer
  """
  EXISTING_CUSTOMER

  """
  Lead Generation
  """
  LEAD_GENERATION

  """
  Lead Generation Ev
  """
  LEAD_GENERATION_EV

  """
  Lead Generation Ej
  """
  LEAD_GENERATION_EJ

  """
  Lead Generation Ej Lite
  """
  LEAD_GENERATION_EJ_LITE

  """
  Lead Generation Business
  """
  LEAD_GENERATION_BUSINESS

  """
  Lead Generation Solar
  """
  LEAD_GENERATION_SOLAR

  """
  Lead Generation Heat Pump
  """
  LEAD_GENERATION_HEAT_PUMP

  """
  Property Ineligible
  """
  PROPERTY_INELIGIBLE

  """
  Electric Juice Switch
  """
  ELECTRIC_JUICE_SWITCH

  """
  Electric Juice Switch Lite
  """
  ELECTRIC_JUICE_SWITCH_LITE

  """
  Electric Juice Not Interested
  """
  ELECTRIC_JUICE_NOT_INTERESTED

  """
  Ppm Requested
  """
  PPM_REQUESTED

  """
  Cot Proven
  """
  COT_PROVEN

  """
  Cot No Proof
  """
  COT_NO_PROOF

  """
  Cos
  """
  COS

  """
  Paid In Full
  """
  PAID_IN_FULL

  """
  Payment Plan
  """
  PAYMENT_PLAN

  """
  Paid Partial
  """
  PAID_PARTIAL

  """
  Paid Reduced Settlement
  """
  PAID_REDUCED_SETTLEMENT

  """
  Insolvency
  """
  INSOLVENCY

  """
  Exhausted No Contact
  """
  EXHAUSTED_NO_CONTACT

  """
  Exhausted Contact
  """
  EXHAUSTED_CONTACT

  """
  Unable To Locate
  """
  UNABLE_TO_LOCATE

  """
  Empty
  """
  EMPTY

  """
  Demolished
  """
  DEMOLISHED

  """
  Unable To Trace
  """
  UNABLE_TO_TRACE

  """
  Prison
  """
  PRISON

  """
  Vulnerable
  """
  VULNERABLE

  """
  Deceased
  """
  DECEASED

  """
  Withdrawn
  """
  WITHDRAWN

  """
  Query
  """
  QUERY
}

"""
The possible errors that can be raised are:

- KT-GB-5911: We have assigned all electric blanket discount codes.
- KT-GB-5912: Account already has a discount code assigned.
- KT-GB-5913: An error occurred assigning a discount code.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type AssignDiscountCode {
  possibleErrors: [PossibleErrorType]

  """
  The assigned discount code.
  """
  discountCode: String
}

type CharityDonationHistoryType {
  totalDonatedAmount: Int
}

"""
Carbon offset entry type.
"""
type CarbonOffsetType {
  """
  Supported sub modes.
  """
  transportModes: [CarbonOffsetTransportModeType]

  """
  The maximum number of hours which can be offset.
  """
  maxHoursToOffset: Int

  """
  A query to return the carbon offset calculation result.
  """
  calculateCarbonOffset("The account number." accountNumber: String!, "The transport mode for the journey offset calculation, e.g. CAR." transportModeCode: String!, "The transport sub code for the journey offset calculation e.g. PETROL. Only applies to some transport modes." transportModeSubCode: String, "The number of hours to offset." hoursToOffset: Int!): CarbonOffsetCalculationResultType
}

"""
The type of transport that can be offset, with the code required in the backend to make the calculation and create a charge.
"""
type CarbonOffsetTransportModeType {
  """
  The transport mode which the carbon offset is being calculated for.
  """
  code: String

  """
  Additional sub types defined for some transport modes.
  """
  subCodes: [String]
}

"""
The carbon offset calculation result for a journey.
"""
type CarbonOffsetCalculationResultType {
  """
  The calculated amount of CO2 produced by the journey.
  """
  co2OffsetInTonnes: Float

  """
  The calculated cost in pence to offset the CO2 from the journey.
  """
  costInPence: Int
}

"""
Create a Carbon Offset Charge for an account.

The possible errors that can be raised are:

- KT-CT-3923: Unauthorized.
- KT-GB-7911: Account cannot calculate carbon offset.
- KT-GB-7912: Error charging account for carbon offset.
- KT-GB-7910: Error calculating carbon offset.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type ChargeCarbonOffset {
  possibleErrors: [PossibleErrorType]

  """
  The amount of CO2 in tonnes which is being offset.
  """
  co2OffsetInTonnes: Float

  """
  The amount charged to offset the journey.
  """
  costInPence: Int
}

"""
The values used to create a carbon offset charge on the account.
"""
input ChargeCarbonOffsetInput {
  """
  The amount the customer was quoted and is expecting to be charged in pence. Used to abort the charge if differs.
  """
  expectedCost: Int!

  """
  The transport mode for the journey offset calculation, e.g. CAR.
  """
  transportModeCode: String!

  """
  The transport sub code for the journey offset calculation e.g. PETROL. Only applies to some transport modes.
  """
  transportModeSubCode: String

  """
  The number of hours to offset.
  """
  hoursToOffset: Int!

  """
  The account number.
  """
  accountNumber: String!
}

type BalanceForecastType {
  """
  Whether the balance forecast is available for the given account.
  """
  isAvailable: Boolean
}

type AccountUrl {
  urlIdentifier: String

  url: String
}

type Urls {
  """
  The Wheel of Fortune URL for the given account's electricity meter.
  """
  wheelOfFortuneElec: String

  """
  The Wheel of Fortune URL for the given account's gas meter.
  """
  wheelOfFortuneGas: String

  """
  The meter reading submission URL for the given account.
  """
  meterReadingSubmission: String

  """
  The tariff renewal URL for the given account.
  """
  tariffRenewal: String

  """
  URL to book a smart meter installation for the given account and property.
  """
  bookSmartMeterInstallation(propertyId: Int!): String

  """
  Pre-signed URL for editing a customers Priority Services Register preferences.
  """
  updateSensitiveCustomerData: String

  """
  Pre-signed URL to join the Saving Sessions campaign.
  """
  savingSessionsJoinCampaign: String

  """
  Pre-signed URL to the saving session dashboard.
  """
  savingSessionsDashboard: String

  """
  Pre-signed URL to join the next Saving Sessions event.
  """
  savingSessionsJoinNextEvent: String @deprecated(reason: "The 'savingSessionsJoinNextEvent' field is deprecated.\n\nUse the savingSessionsDashboard instead.\n\n- Marked as deprecated on 2022-10-31.\n- Will be removed on 2022-11-15.")
}

"""
Generate a PAN (Payment Allocation Number) for a smart meter. This can be used to add credit to the meter in a shop,
if the meter is in prepayment mode.

The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
"""
type GeneratePaymentAllocationNumber {
  possibleErrors: [PossibleErrorType]

  """
  The Payment Allocation Number routes payments made via a PSP (Payment Service Provider) to this device.
  """
  pan: String!
}

"""
Identifies a SMETS2 meter (or a SMETS1 E&A'd meter).
"""
input SmartMeterDeviceInput {
  """
  Account number of customer.
  """
  accountNumber: String!

  """
  Electricity or gas meter device ID.
  """
  deviceId: String!
}

type CampaignType {
  name: String!

  slug: String!

  expiryDate: Date
}

"""
Quote a given account on a campaign offer.
"""
type QuoteCampaignOffer {
  quoteCode: String
}

input QuoteCampaignOfferInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  Property to quote on.
  """
  propertyId: Int!

  """
  Slug of campaign to quote on.
  """
  campaignSlug: String!
}

"""
Replace the given agreement with the given product.

TODO: Move this outside of plugin as it is applicable to the wider domain.
"""
type ReplaceAgreement {
  account: AccountInterface
}

interface AccountInterface {
  """
  The brand of the account.
  """
  brand: String

  """
  The current status of the account.
  """
  status: AccountStatus

  """
  The current account balance.
  """
  balance("If this variable is set to true, the balance will be calculated based on the sum of balances on all ledgers configured to contribute to this account's balance. Otherwise, only the main ledger's balance will be fetched (legacy behaviour). If you are unsure, set this value to true." includeAllLedgers: Boolean = false): Int!

  """
  The current account overdue balance.
  """
  overdueBalance: Int

  """
  Unique reference number from a 3rd party enrolment.
  """
  urn: String

  """
  The billing name of the account.
  """
  billingName: String

  """
  The billing sub name of the account.
  """
  billingSubName: String

  """
  The billing email of the account.
  """
  billingEmail: String

  """
  The billing address of the account.
  """
  billingAddress: String

  billingAddressLine1: String

  billingAddressLine2: String

  billingAddressLine3: String

  billingAddressLine4: String

  billingAddressLine5: String

  billingAddressPostcode: String

  billingCountryCode: String

  billingDeliveryPointIdentifier: String

  """
  List of billing address lines.
  """
  splitBillingAddress: [String]

  """
  The billing address of this account, stored in the new
  libaddressinput-based format.

  Note that `name` and `organization` are very unlikely to be
  supplied here; the `billing_name` field on the account
  itself is generally used for that purpose instead.
  """
  address: RichAddressType

  """
  A code that uniquely identifies the account.
  """
  number: String

  """
  The portfolio this account is linked to.
  """
  portfolio: PortfolioType

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  """
  ledgers("The ledger to return" ledgerId: ID, "The ledger to return by its number" ledgerNumber: String): [LedgerType]

  """
  Metadata associated with the account.
  """
  metadata: [Metadata]

  """
  Whether the account can request a credit refund.
  """
  canRequestRefund: Boolean

  """
  Details about the eligibility status for requesting a refund.
  """
  requestRefundEligibility: RequestRefundEligibilityType

  """
  The payments made into an account from a payment instruction.
  """
  payments("**WARNING: Will be mandatory in future versions**\n\nThe ledger to return payments from." ledgerId: String, status: AccountPaymentStatusOptions, "Filter for payments that were taken for a particular reason." reason: PaymentReasonOptions, "Whether to include payment promises (of any kind: made, broken or fulfilled) or not. The default is to include them." includePromises: Boolean = true, before: String, after: String, first: Int, last: Int): AccountPaymentConnectionTypeConnection

  """
  The repayments that have been requested for this account.
  """
  repayments("Only return repayments whose status matches one of these statuses" statuses: [AccountRepaymentStatusOptions], before: String, after: String, first: Int, last: Int): AccountRepaymentConnectionTypeConnection

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(activeOnDate: Date, active: Boolean, canCreatePayment: Boolean @deprecated(reason: "The 'canCreatePayment' field is deprecated.\n\nPlease use 'includeDormant' instead.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-12-06."), "If false, we remove the currently valid schedule if it has already fulfilled its purpose and will have no further impact on customer payments, along with any schedules which are not valid from today." includeDormant: Boolean = true, "The ledger to return transactions from." ledgerType: Int, "The ledger id to return the payment schedules from." ledgerId: ID, reason: PaymentScheduleReasonOptions, before: String, after: String, first: Int, last: Int): PaymentScheduleConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast("The end date to retrieve forecasts for. This end date is inclusive." dateTo: Date!, "The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed." ledgerId: Int): [PaymentForecastType] @deprecated(reason: "The 'paymentForecast' field is deprecated.\n\nPlease use 'paginatedPaymentForecast' instead.\n\n- Marked as deprecated on 2024-01-03.\n- Will be removed on 2025-01-01.")

  """
  Paginated payment forecasts for an account. Starts from today's date (inclusive). The interface supports `last` but does not guarantee 'lastness'.
  """
  paginatedPaymentForecast("The end date to retrieve forecasts for. This end date is inclusive." dateTo: Date, "The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed." ledgerId: Int, before: String, after: String, first: Int, last: Int): PaymentForecastConnectionTypeConnection

  """
  The referrals created by this account.
  """
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """
  Number of referrals created by this account.
  """
  referralsCreated: Int

  """
  The rewards applied to this account.
  """
  rewards: [RewardType]

  """
  The referral schemes currently active for this account.
  """
  activeReferralSchemes: ReferralSchemeTypes

  """
  Fetch transactions that have taken place on the account.
  """
  transactions("Include only these specific transaction types in the result." transactionTypes: [TransactionTypeFilter] = [], "Exclude these specific transaction types from the result." transactionTypesExcluded: [TransactionTypeFilter] = [], "The ledger to return transactions from." ledgerId: Int, "In a multi-ledger scenario, include all ledgers' transactions if `true`. Analogously, if `false` and no `ledgerId` argument is present, the list of transactions defaults to the main ledger (legacy behaviour)." includeAllLedgers: Boolean, "\nOptional date representing the beginning of the postedDate range filter.\nThis date value is inclusive.\n" fromDate: Date, "\nOptional date representing the end of the postedDate range filter.\nThis date value is exclusive.\n" toDate: Date, "The order in which to return the transactions." orderBy: TransactionsOrderBy = POSTED_DATE_DESC, offset: Int, before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """
  Fetch annual statements for the account.
  """
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """
  Fetch issued bills (invoices/statements) for the account.
  """
  bills("Include bills without PDFs." includeBillsWithoutPDF: Boolean = false, "\nInclude open statements. This flag needs to be used along with\nincludeBillsWithoutPDF=false otherwise results will prove unexpected.\n" includeOpenStatements: Boolean = false, "Include held statements within the results." includeHeldStatements: Boolean = false, "Include pre-Kraken \/ historical statements within the results." includeHistoricStatements: Boolean = true, "Only include bills emailed to the current user's email." onlyCurrentEmail: Boolean = false, "Optional date representing the beginning of the search results. This date value is inclusive." fromDate: Date, "Optional date representing the end of the search results. This date value is exclusive." toDate: Date, "Optional date representing the beginning of the search results based on issued date. This date value is inclusive." issuedFromDate: Date, "Optional date representing the end of the search results based on issued date. This date value is exclusive." issuedToDate: Date, "The order in which to return the bills." orderBy: BillsOrderBy = FROM_DATE_DESC, offset: Int, before: String, after: String, first: Int, last: Int): BillConnectionTypeConnection

  """
  Information about the account's billing cycle.
  """
  billingOptions: BillingOptionsType

  """
  Fetch a specific issued bill (invoice/statement) for the account.
  """
  bill(id: ID!, billType: BillTypeEnum): BillInterface

  """
  The direct debit instructions of the account
  """
  directDebitInstructions("Filter the direct debit instructions by status" statuses: [DirectDebitInstructionStatus], before: String, after: String, first: Int, last: Int): DirectDebitInstructionConnectionTypeConnection

  """
  The account events that were recorded for the account.
  """
  events("Filter the account events by their type." eventTypes: [AccountEventType], before: String, after: String, first: Int, last: Int): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """
  The type of account.
  """
  accountType: AccountTypeChoices

  """
  The company type of a business account.
  """
  businessType: BusinessTypeOptions @deprecated(reason: "The 'businessType' field is deprecated.\n\nUse `business.businessType` instead\n\n- Marked as deprecated on 2022-03-09.\n- Will be removed on 2024-01-01.")

  """
  Business info related to a business account.
  """
  business: BusinessType

  """
  The method the account has specified they prefer we contact them
  """
  commsDeliveryPreference: CommsDeliveryPreference

  communicationDeliveryPreference: String @deprecated(reason: "The 'communicationDeliveryPreference' field is deprecated.\n\nUse `commsDeliveryPreference` instead\n\n- Marked as deprecated on 2022-05-27.\n- Will be removed on 2024-01-01.")

  """
  The document accessibility preference of the account.
  """
  documentAccessibility: DocumentAccessibilityChoices

  """
  Account references linked to this account.
  """
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  Files attached to this account.
  """
  paginatedFileAttachments("File attachment id." id: Int, "File attachment category." category: String, before: String, after: String, first: Int, last: Int): AccountFileAttachmentConnectionTypeConnection

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """
  The campaigns associated with an account.
  """
  campaigns: [AccountCampaignType]

  """
  True if there is an active Hardship Agreement for this account. False otherwise.
  """
  isInHardship: Boolean

  """
  List of active hardship agreements for the user when is_in_hardship is True.
  """
  activeHardshipAgreements: [HardshipAgreementType]

  """
  Notes for the account.
  """
  notes: [AccountNoteType]

  """
  Contribution agreements for account.
  """
  contributionAgreements: [ContributionAgreementType]

  """
  Assistance agreements for account.
  """
  assistanceAgreements: [AssistanceAgreementType]

  """
  Debt collection proceedings for account.
  """
  debtCollectionProceedings: [DebtCollectionProceedingType]

  """
  The datetime that the account was originally created.
  """
  createdAt: DateTime

  """
  The language that the account preferred for communications.
  """
  preferredLanguageForComms: String
}

enum AccountStatus {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """
  Account requires processes to be completed before supply can be set up
  """
  INCOMPLETE

  """
  Withdrawn before supply started
  """
  WITHDRAWN

  """
  Supply could have started, be ongoing or ended.
  """
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """
  Dormant. Users should not be able to log into dormant accounts.
  """
  DORMANT

  """
  Void. Account created in error.
  """
  VOID
}

"""
A postal address.

This data model is based on the structure used by Google's
[libaddressinput library](https://github.com/google/libaddressinput)&mdash;so
you can use it, or other libraries that use its data model
and reference data, to accept input.

All fields can be blank, except for ``country`` which must
always be supplied.
"""
type RichAddressType {
  """
  A personal name.
  """
  name: String

  """
  The name of a business or organisation.
  """
  organization: String

  """
  The 'street address' component.

  This value can (and often will) contain newline characters
  when appropriate.

  In some cases, data may appear in this field instead of the
  below fields; e.g. a UK post town name may appear here
  instead of in the `dependent_locality` field. This happens
  when data has been migrated from a legacy format, and that
  format had insufficient metadata to determine the
  appropriate field.

  If `structured_street_address` is also set, the value of
  this field will be a string generated from that value.
  """
  streetAddress: String

  """
  The 'street address' component, in a structured format.

  This field stores the same value as `street_address`, but
  with more detail; for instance, instead of `123 Example
  Street` it might be `{'street_number': '123',
  'street_name': 'Example', 'street_type': 'Street'}`. In
  many cases this will be blank; we only use this field for
  Krakens where we need to supply this level of granularity
  to some third-party service, like a bulk mail provider.

  The exact structure of this value depends on the country _of
  the address_, which is not necessarily the same as the
  country this Kraken is configured to serve. For addresses
  outside of the countries listed below, this field will be
  left blank.

  ### `AU`: Australia

  The following keys may be present; all are optional. All
  keys have string values, and their meaning is the same as
  their aseXML counterparts. (Note that, unlike aseXML, all
  keys are provided at the top level, rather than being
  nested.)

  - `flat_or_unit_type`
  - `flat_or_unit_number`
  - `floor_or_level_type`
  - `floor_or_level_number`
  - `building_or_property_name`
  - `location_descriptor`
  - `lot_number`
  - `house_number_1`
  - `house_number_suffix_1`
  - `house_number_2`
  - `house_number_suffix_2`
  - `street_name`
  - `street_type`
  - `street_suffix`
  - `postal_delivery_type`
  - `postal_delivery_number_prefix`
  - `postal_delivery_number_value`
  - `postal_delivery_number_suffix`

  ### `JP`: Japan

  The following keys may be present; all are optional.
  If keys are empty, they may be omitted from the response entirely.

  - `chome`
  - `banchi`
  - `go`
  - `edaban`
  - `kana_building_name`
  - `kanji_building_name`
  - `building_number`
  - `room_number`
  - `address_code`
  - `physical_location_identifier`
  """
  structuredStreetAddress: GenericScalar

  """
  UK dependent localities, or neighbourhoods or boroughs in
  some other locations.
  """
  dependentLocality: String

  """
  City or town portion of an address, e.g. US city, AU
  suburb/town, IT comune, UK post town.
  """
  locality: String

  """
  Top-level administrative subdivision, e.g. US state, AU
  state/territory, IT region, JP prefecture.

  ### `AU`: Australia

  This must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,
  `NT`, `WA`. For addresses not within these locations, use
  the value that Australia Post uses, e.g. `ACT` for the
  Jervis Bay Territory or `WA` for Christmas Island.
  """
  administrativeArea: String

  """
  Postal code (ZIP code in the US).
  """
  postalCode: String

  """
  Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  """
  sortingCode: String

  """
  ISO 3166-1 alpha-2 code of the country this address belongs
  to, e.g. `AU`, `GB`.
  """
  country: String

  """
  Identifier used by the local postal service for this
  address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  US Zip-9 + Delivery Point.

  This is the value that gets encoded in the barcode printed
  on the envelope by large-volume bulk mail providers.
  """
  deliveryPointIdentifier: String
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type PortfolioType {
  id: ID!

  number: String!

  createdAt: DateTime!

  updatedAt: DateTime!

  billingName: String

  collectiveBilling: Boolean!

  """
  Operations team for this portfolio.
  """
  operationsTeam: OperationsTeamType
}

type OperationsTeamType {
  id: Int

  teamName: String

  isOffline: Boolean

  isAcceptingCalls: Boolean
}

"""
Ledgers provide the foundation of Krakens bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
"""
type LedgerType implements LedgerInterface {
  id: ID

  """
  The display name of the ledger.
  """
  name: String

  """
  The canonical name of the ledger.
  """
  number: String

  """
  The ledger type code.
  """
  ledgerType: String

  """
  The current balance on the ledger in minor units of currency.
  """
  balance: Int

  """
  The amount owed from the customer perspective. A positive value implies the customer owes the business, while a negative amount implies the customer is in credit.
  """
  amountOwedByCustomer: Int

  """
  Whether this ledger's balance contributes to the account's balance.
  """
  affectsAccountBalance: Boolean

  """
  A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  """
  statements("The id of billing document." statementId: Int, before: String, after: String, first: Int, last: Int): StatementBillingDocumentConnectionTypeConnection

  """
  An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
  """
  invoices("The id of the invoice." invoiceId: Int, before: String, after: String, first: Int, last: Int): InvoiceBillingDocumentConnectionTypeConnection

  transactions("Return these transaction types only." transactionTypes: [TransactionTypeFilter] = [], before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  """
  Repayment requests for a given ledger.
  """
  repaymentRequests(before: String, after: String, first: Int, last: Int): RepaymentRequestConnectionTypeConnection

  """
  Refund requests for a given ledger.
  """
  refundRequests(before: String, after: String, first: Int, last: Int): RefundRequestConnectionTypeConnection

  paymentAdequacy: PaymentAdequacyDetailsType
}

interface LedgerInterface {
  id: ID

  """
  The display name of the ledger.
  """
  name: String

  """
  The canonical name of the ledger.
  """
  number: String

  ledgerType: String

  """
  The current balance on the ledger in minor units of currency.
  """
  balance: Int

  """
  The amount owed from the customer perspective. A positive value implies the customer owes the business, while a negative amount implies the customer is in credit.
  """
  amountOwedByCustomer: Int

  """
  Whether this ledger's balance contributes to the account's balance.
  """
  affectsAccountBalance: Boolean

  """
  A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  """
  statements(before: String, after: String, first: Int, last: Int): StatementBillingDocumentConnectionTypeConnection

  """
  An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
  """
  invoices(before: String, after: String, first: Int, last: Int): InvoiceBillingDocumentConnectionTypeConnection

  transactions("Return these transaction types only." transactionTypes: [TransactionTypeFilter] = [], before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  """
  Repayment requests for a given ledger.
  """
  repaymentRequests(before: String, after: String, first: Int, last: Int): RepaymentRequestConnectionTypeConnection

  """
  Refund requests for a given ledger.
  """
  refundRequests(before: String, after: String, first: Int, last: Int): RefundRequestConnectionTypeConnection

  paymentAdequacy: PaymentAdequacyDetailsType
}

"""
A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
"""
type StatementBillingDocumentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [StatementBillingDocumentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `StatementBillingDocumentConnectionType` and its cursor.
"""
type StatementBillingDocumentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: StatementBillingDocumentType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
"""
type StatementBillingDocumentType {
  id: Int

  """
  The unique reference of the statement that can be used for identifying the statement externally.
  """
  identifier: String

  """
  The start of the statement's period.
  """
  startAt: DateTime!

  """
  The end of the statement's period.
  """
  endAt: DateTime!

  """
  The date and time the statement was sent to the customer.
  """
  firstIssuedAt: DateTime

  """
  The earliest charge date of the statement.
  """
  earliestChargeAt: DateTime

  """
  The latest charge date of the statement.
  """
  latestChargeAt: DateTime

  """
  URL to the PDF of the statement.
  """
  pdfUrl: String

  """
  Billing document that annuls this statement.
  """
  annulledBy: AnnulmentBillingDocumentType
}

"""
An annulment is a billing document that annuls another billing document.
"""
type AnnulmentBillingDocumentType {
  id: Int!

  """
  ID of the billing document annulled by this annulment.
  """
  annulledBillingDocumentId: Int!

  """
  First time the annulment was issued.
  """
  firstIssued: DateTime

  """
  URL to the PDF of the annulment.
  """
  pdfUrl: String
}

"""
An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
"""
type InvoiceBillingDocumentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [InvoiceBillingDocumentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `InvoiceBillingDocumentConnectionType` and its cursor.
"""
type InvoiceBillingDocumentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: InvoiceBillingDocumentType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
An invoice is a bill that contains individual transactions  (i.e. charges, credits, payments, and repayments). These may come from any period of time.
"""
type InvoiceBillingDocumentType {
  id: Int

  """
  First time the invoice was issued.
  """
  firstIssued: DateTime

  """
  URL to the PDF of the Invoice.
  """
  pdfUrl: String

  """
  Billing document that annuls this invoice.
  """
  annulledBy: AnnulmentBillingDocumentType

  """
  The unique billing document's reference that can be used for identifying it externally.
  """
  number: String
}

type TransactionConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [TransactionConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `TransactionConnectionType` and its cursor.
"""
type TransactionConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: TransactionType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Transaction types which will be included or excluded, depending on the input argument.
"""
enum TransactionTypeFilter {
  """
  For filtering/excluding issued transactions.
  """
  ISSUED_TRANSACTIONS

  """
  For filtering/excluding energy charge transactions: Gas or Electricity.
  """
  ENERGY_CHARGES

  """
  For filtering/excluding imported charge transactions.
  """
  IMPORTED_CHARGES

  """
  For filtering/excluding imported credit transactions.
  """
  IMPORTED_CREDITS

  """
  For filtering/excluding imported repayment transactions.
  """
  IMPORTED_REPAYMENTS

  """
  For filtering/excluding imported payment transactions.
  """
  IMPORTED_PAYMENTS
}

type RepaymentRequestConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [RepaymentRequestConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `RepaymentRequestConnectionType` and its cursor.
"""
type RepaymentRequestConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: RepaymentRequestType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type RepaymentRequestType {
  """
  The ID of the repayment request.
  """
  requestId: String

  """
  The amount of money requested.
  """
  amount: Int

  """
  Classifier code for repayment reason.
  """
  reasonCode: String

  """
  The method by which the money will be transferred to the customer.
  """
  method: RepaymentMethod

  """
  The payment instruction, if any, associated with the repayment request.
  """
  instruction: PaymentInstructionType

  """
  The current status of the repayment request.
  """
  status: RepaymentRequestStatus
}

"""
    Methods by which repayments can be sent to the customer.
    
"""
enum RepaymentMethod {
  BANK_TRANSFER

  CHEQUE

  CARD
}

"""
    Possible status' for a repayment (or refund) request
    
"""
enum RepaymentRequestStatus {
  REQUESTED

  ACCEPTED

  CANCELLED

  REJECTED
}

type RefundRequestConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [RefundRequestConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `RefundRequestConnectionType` and its cursor.
"""
type RefundRequestConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: RefundPaymentRequestType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type RefundPaymentRequestType {
  """
  The ID of the refund request.
  """
  requestId: ID

  """
  The amount of money requested.
  """
  amount: Int

  """
  The payment which is being refunded.
  """
  payment: AccountPaymentType

  """
  Internal code for the reason the refund is being requested.
  """
  reasonCode: String

  """
  The current status of the refund request.
  """
  status: RepaymentRequestStatus
}

type AccountPaymentType {
  id: ID!

  """
  Amount of payment in pence
  """
  amount: BigInt!

  """
  The date this payment is scheduled to be debited
  """
  paymentDate: Date!

  reference: String!

  """
  The transaction type of the payment.
  """
  transactionType: AccountPaymentTransactionTypeChoices

  """
  The current status of the payment
  """
  status: AccountPaymentStatusOptions

  """
  Surcharge amount generated by this payment.
  """
  surchargeAmount: Int
}

"""
An enumeration.
"""
enum AccountPaymentTransactionTypeChoices {
  DD_FIRST_COLLECTION

  DD_REGULAR_COLLECTION

  DD_RE_PRESENTATION

  DD_FINAL_COLLECTION

  CREDIT_CARD

  DEBIT_CARD

  PREPAID_CARD

  AUSTRALIA_POST

  BACS_DEPOSIT

  BPAY

  BTRE

  BPOINT

  BRISTOL_POUND

  CASH

  CENTREPAY

  CHEQUE

  EAPA_VOUCHER

  ERRONEOUS_PAYMENT

  HEEAS

  IVR

  TRANSFER_FROM_SAP

  FUEL_DIRECT

  EFT

  URGS

  AGENCY

  PAYPOINT_CASH

  PAYPOINT_CARD

  PAYPOINT_CHEQUE

  ALLPAY_CASH

  ALLPAY_CARD

  ALLPAY_CHEQUE

  PAYZONE

  DWP

  POST_OFFICE_CASH

  POST_OFFICE_CHEQUE

  POST_OFFICE_SAVINGS_STAMPS

  POST_OFFICE_CARD

  DCA_COLLECTION

  PREPAY_KEY

  PREPAY_CARD

  PREPAY_TOKEN

  PREPAY_SMART

  PAYMENT_FEE

  FAILED_REPAYMENT_REVERSAL

  KONBINI

  PAGOPA_NOTICE

  UNKNOWN
}

"""
An enumeration.
"""
enum AccountPaymentStatusOptions {
  """
  The payment has been scheduled for collection and the customer has been notified. While a payment is scheduled, it can still be deleted.
  """
  SCHEDULED

  """
  The payment has been submitted. From this point it cannot be altered.
  """
  PENDING

  """
  The payment has been approved by the merchant and added to your Kraken account.
  """
  CLEARED

  """
  The payment failed permanently.
  """
  FAILED

  """
  A payment promise has been created, but it has not left the customers bank account.
  """
  PROMISED

  """
  The payment has been made successfully and applied to the Kraken balance.
  """
  FULFILLED

  """
  The payment promise has been broken.
  """
  PROMISE_BROKEN

  """
  Payments made in a previous system and then imported into Kraken.
  """
  HISTORIC

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """
  The initial state of a payment in Kraken. It should be scheduled with a payment vendor in the future.
  """
  REQUESTED

  """
  This payment was deleted. From this point it cannot be altered.
  """
  DELETED
}

"""
Payment adequacy adjusts fixed payment schedules to maintain a healthy ledger balance over a year.
"""
type PaymentAdequacyDetailsType {
  """
  This ledger will be exempt from default Payment Adequacy. This may mean that it is completely exempt, or handled with special rules.
  """
  isCurrentlyExempt: Boolean
}

type Metadata {
  """
  The key for the metadata.
  """
  key: String!

  """
  The metadata value.
  """
  value: JSONString
}

type RequestRefundEligibilityType {
  """
  Whether the account can request a refund.
  """
  canRequestRefund: Boolean!

  """
  The reason why a refund cannot be requested.
  """
  reason: String
}

type AccountPaymentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AccountPaymentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountPaymentConnectionType` and its cursor.
"""
type AccountPaymentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AccountPaymentType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum PaymentReasonOptions {
  BALANCE_THRESHOLD_CROSSED

  BILL_ISSUED

  PAYMENT_PLAN

  REGULAR_SCHEDULE
}

type AccountRepaymentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AccountRepaymentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountRepaymentConnectionType` and its cursor.
"""
type AccountRepaymentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AccountRepaymentType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type AccountRepaymentType {
  id: ID!

  """
  Amount of payment in pence
  """
  amount: BigInt!

  """
  The date this payment is scheduled to be debited
  """
  paymentDate: Date!

  """
  The current status of the repayment
  """
  status: AccountRepaymentStatusOptions
}

"""
An enumeration.
"""
enum AccountRepaymentStatusOptions {
  """
  The request for a repayment has been received but not actioned yet.
  """
  REQUESTED

  """
  The repayment has been approved but not made yet.
  """
  APPROVED

  """
  The payment has been submitted to the merchant. It is still possible for this repayment to fail.
  """
  SUBMITTED

  """
  The repayment failed permanently. This could be because of technical issues, or if the merchant rejects the payment for some reason. The payment will need to be retried by ops.
  """
  FAILED

  """
  The repayment has been made to the merchant to be sent to the customer. This is a terminal state, we don't get any further confirmation.
  """
  PAID

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """
  Payments made in a previous system and then imported into Kraken.
  """
  HISTORIC
}

type PaymentScheduleConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [PaymentScheduleConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `PaymentScheduleConnectionType` and its cursor.
"""
type PaymentScheduleConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: PaymentScheduleType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
An object that represents when we have agreed to take payments from a payment instruction.
"""
type PaymentScheduleType {
  id: ID!

  """
  The supplementary ledger for this payment schedule, if it is on one
  """
  supplementaryLedger: SupplementaryLedgerType

  validFrom: Date!

  validTo: Date

  """
  The reason the payment schedule was created.
  """
  reason: PaymentScheduleReasonOptions

  paymentHolidayReason: String!

  paymentDay: Int

  """
  The frequency of the payment schedule
  """
  paymentFrequency: PaymentFrequencyOptions

  paymentFrequencyMultiplier: Int!

  paymentAmount: Int!

  paymentAdequacyAdjustment: Int

  paymentAdequacyAdjustmentExpiryDate: Date

  isVariablePaymentAmount: Boolean!

  """
  The sum of the payment adequacy contributions on the payment schedule that are expected to be taken before the debt repayment is complete.
  """
  totalDebtAmount: Int

  isPaymentHoliday: Boolean

  """
  The method of payment for the schedule.
  """
  scheduleType: ScheduleType
}

"""
Ledgers provide the foundation of Krakens bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
"""
type SupplementaryLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """
  The display name of the ledger.
  """
  name: String

  ledgerType: String

  """
  The current final balance of the ledger in pence.
  """
  currentBalance: Int

  paymentAdequacy: PaymentAdequacyDetailsType
}

interface SupplementaryLedgerInterface {
  id: ID

  """
  The display name of the ledger.
  """
  name: String

  ledgerType: String

  """
  The current final balance of the ledger in pence.
  """
  currentBalance: Int

  paymentAdequacy: PaymentAdequacyDetailsType
}

"""
An enumeration.
"""
enum PaymentScheduleReasonOptions {
  """
  The default value for usual account payments.
  """
  GENERAL_ACCOUNT_PAYMENT

  """
  A payment schedule created to take a payment around the supply start date of a meterpoint to help prevent accounts accruing debt.
  """
  SSD_PAYMENT

  """
  A payment schedule created to take the final payment when an account is closed.
  """
  FINAL_PAYMENT

  """
  A payment schedule created to take payments to pay back a debt. These schedules typically expire once the debt has been re-payed.
  """
  DEBT_REPAYMENT_PLAN
}

"""
An enumeration.
"""
enum PaymentFrequencyOptions {
  """
  Weekly
  """
  Weekly

  """
  Monthly
  """
  Monthly

  """
  Planned
  """
  Planned
}

"""
An enumeration.
"""
enum ScheduleType {
  BACS_TRANSFER

  CARD_PAYMENT

  DIRECT_DEBIT

  PAYMENT_SLIP
}

type PaymentForecastType {
  paymentNumber: Int

  date: Date

  amount: Int

  """
  The payment method used for the forecasted payment.
  """
  method: ScheduleType
}

type PaymentForecastConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [PaymentForecastConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `PaymentForecastConnectionType` and its cursor.
"""
type PaymentForecastConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: PaymentForecastType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type ReferralConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ReferralConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `ReferralConnectionType` and its cursor.
"""
type ReferralConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: ReferralType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Details of an account referral
"""
type ReferralType implements ReferralInterface {
  id: ID!

  paymentDate: Date

  """
  The type of reward scheme.
  """
  schemeType: ReferralSchemeTypeChoices

  referredUserName: String

  paymentStatus: String

  referredUserJoinDate: DateTime

  code: String

  """
  Payment amount given to the referred account in pence.
  """
  referredUserPaymentAmount: Int

  """
  Payment amount given to the referring account in pence.
  """
  referringUserPaymentAmount: Int

  """
  The payment amount in pence received by the referrer and the referee combined.
  """
  combinedPaymentAmount: Int
}

interface ReferralInterface {
  paymentDate: Date

  """
  The type of reward scheme.
  """
  schemeType: ReferralSchemeTypeChoices

  referredUserName: String

  paymentStatus: String

  referredUserJoinDate: DateTime

  code: String

  """
  Payment amount given to the referred account in pence.
  """
  referredUserPaymentAmount: Int

  """
  Payment amount given to the referring account in pence.
  """
  referringUserPaymentAmount: Int

  """
  The payment amount in pence received by the referrer and the referee combined.
  """
  combinedPaymentAmount: Int
}

"""
An enumeration.
"""
enum ReferralSchemeTypeChoices {
  """
  Referral Reward.
  """
  REFERRAL_REWARD

  """
  Signup Reward.
  """
  SIGNUP_REWARD

  """
  Partner Reward.
  """
  PARTNER_REWARD

  """
  Promo Reward.
  """
  PROMO_REWARD

  """
  Legacy Referral.
  """
  LEGACY_REFERRAL
}

"""
            A reward is based on a scheme that an account has applied for in order to be
            eligible for a discount. Examples can include signup, promo, or partner codes that
            were applied to an account.
            
"""
type RewardType implements RewardInterface {
  id: ID!

  paymentDate: Date

  """
  The type of reward scheme.
  """
  schemeType: ReferralSchemeTypeChoices

  """
  Reward amount given to the account in pence.
  """
  rewardAmount: Int

  """
  The status of the reward payment.
  """
  paymentStatus: ReferralStatusChoices
}

interface RewardInterface {
  paymentDate: Date

  """
  The type of reward scheme.
  """
  schemeType: ReferralSchemeTypeChoices

  """
  Reward amount given to the account in pence.
  """
  rewardAmount: Int

  """
  The status of the reward payment.
  """
  paymentStatus: ReferralStatusChoices
}

"""
An enumeration.
"""
enum ReferralStatusChoices {
  """
  Pending.
  """
  Pending

  """
  Paid.
  """
  Paid

  """
  Cancelled.
  """
  Cancelled
}

type ReferralSchemeTypes {
  domestic: ReferralSchemeType

  business: ReferralSchemeType

  friendsAndFamily: ReferralSchemeType @deprecated(reason: "The 'friendsAndFamily' field is deprecated.\n\nPlease use domestic instead.\n\n- Marked as deprecated on 2020-03-05.\n- Will be removed on 2024-01-01.")
}

"""
A referral scheme is a way for one account to earn a reward for referring another. This is achieved by the referred account using a url (provided by the referring account) to sign up.
"""
type ReferralSchemeType {
  """
  A fully qualified url give people to create accounts referred by this scheme.
  """
  referralUrl: String

  """
  A referral url for display purposes.
  """
  referralDisplayUrl: String

  """
  The reward amount received by the referrer.
  """
  referrerRewardAmount: Int

  """
  The reward amount received by the referred party.
  """
  referredRewardAmount: Int

  """
  The reward amount received by the referrer and the referee combined.
  """
  combinedRewardAmount: Int

  """
  The number of loyalty points to be awarded to the referrer in addition to the reward amount.
  """
  loyaltyPointsBonus: Int

  """
  Whether the current account is eligible to be referred under this scheme.
  """
  canBeReferred: Boolean

  """
  The unique code for the scheme.
  """
  code: String

  """
  The given name of the person making the referral.
  """
  referrerGivenName: String

  """
  The family name of the person making the referral.
  """
  referrerFamilyName: String @deprecated(reason: "The 'referringFamilyName' field is deprecated.\n\nOnly make use of the referrerGivenName for privacy reasons.\n\n- Marked as deprecated on 2022-11-07.\n- Will be removed on 2023-01-07.")

  """
  Scheme type of the referral scheme.
  """
  schemeType: String
}

enum TransactionsOrderBy {
  POSTED_DATE_ASC

  POSTED_DATE_DESC
}

type ProvisionalTransactionConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ProvisionalTransactionConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `ProvisionalTransactionConnectionType` and its cursor.
"""
type ProvisionalTransactionConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: ProvisionalTransactionType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A provisional transaction represents some debit or credit to or from a customer's account which we cannot yet finalise for some reason, but which is still useful to keep a note of, and display to the customer. Provisional transactions are purely to give guidance in the absence of finalised information. We therefore only return provisional transactions that have not been finalised. When a transaction is finalised, it is available through the `transactions` field.
"""
type ProvisionalTransactionType {
  id: ID!

  """
  A user readable string that indicates what this transaction relates to.
  """
  title: String

  """
  The amount in pence for this provisional transaction. It will be negative for charges, positive for credits.
  """
  amount: Int

  """
  The date at which the charge should be applied to the account.
  """
  date: Date
}

type AnnualStatementConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AnnualStatementConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AnnualStatementConnectionType` and its cursor.
"""
type AnnualStatementConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AnnualStatementType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Annual statements that are sent to the account. They summarize important information about usage and tariffs.
"""
type AnnualStatementType {
  periodStartsAt: DateTime!

  periodEndsAt: DateTime!

  id: ID

  pdfUrl: String
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type BillConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [BillConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `BillConnectionType` and its cursor.
"""
type BillConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: BillInterface

  """
  A cursor for use in pagination
  """
  cursor: String!
}

interface BillInterface {
  id: ID

  billType: BillTypeEnum

  fromDate: Date

  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.


          
  """
  temporaryUrl: String

  """
  The date the bill was sent to the customer.
  """
  issuedDate: Date
}

enum BillTypeEnum {
  STATEMENT

  INVOICE

  CREDIT_NOTE

  PRE_KRAKEN
}

enum BillsOrderBy {
  FROM_DATE_DESC

  ISSUED_DATE_DESC
}

"""
Information about an account's billing schedule.
"""
type BillingOptionsType {
  """
  The day of the month on which the account's billing period should start.
  """
  periodStartDay: Int

  periodLength: AccountBillingOptionsPeriodLength

  periodLengthMultiplier: Int

  """
  If true, this account is billed on specific day of a regular cycle. If false, the billing schedule is flexible, depending on when meter readings are submitted.
  """
  isFixed: Boolean!

  """
  The date on which the current billing cycle started.
  """
  currentBillingPeriodStartDate: Date

  """
  The date on which the current billing cycle will end. Null if the account is on flexible billing.
  """
  currentBillingPeriodEndDate: Date

  """
  The next date on which this account will next be billed. This is the same as the start date for their next bill cycle. Null if the account is on flexible billing.
  """
  nextBillingDate: Date
}

"""
An enumeration.
"""
enum AccountBillingOptionsPeriodLength {
  """
  Monthly
  """
  MONTHLY

  """
  Quarterly
  """
  QUARTERLY
}

type DirectDebitInstructionConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [DirectDebitInstructionConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `DirectDebitInstructionConnectionType` and its cursor.
"""
type DirectDebitInstructionConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: DirectDebitInstructionType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Direct Debit Instructions
"""
type DirectDebitInstructionType {
  id: ID!

  status: String!

  sortCode: String!

  iban: String!

  accountHolder: String!

  instructionType: String!

  cardPaymentNetwork: String

  cardExpiryMonth: Int

  cardExpiryYear: Int

  """
  The last four digits of the account number.
  """
  lastFourDigitsOfAccountNumber: String @deprecated(reason: "The 'lastFourDigitsOfAccountNumber' field is deprecated.\n\nUse 'maskedAccountIdentifier' for a masked reference to the instruction.\n\n- Marked as deprecated on 2021-12-23.\n- Will be removed on 2024-01-01.")

  """
  A masked reference to a recurring payment method.
  """
  maskedAccountIdentifier: String

  """
  A masked version of the IBAN.
  """
  maskedIban: String
}

"""
An enumeration.
"""
enum DirectDebitInstructionStatus {
  """
  The instruction is active and can be used to take payments.
  """
  ACTIVE

  """
  The instruction has not yet been set up.
  """
  PROVISIONAL

  """
  The instruction could not be set up with the vendor.
  """
  FAILED

  """
  The account for this instruction was closed.
  """
  ACCOUNT_CLOSED
}

type AccountEventConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AccountEventConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountEventConnectionType` and its cursor.
"""
type AccountEventConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AccountEvent

  """
  A cursor for use in pagination
  """
  cursor: String!
}

union AccountEvent = EmailEventType|PrintEventType

type EmailEventType implements Node {
  """
  The ID of the object
  """
  id: ID!

  eventType: String!

  occurredAt: DateTime!

  """
  Email message of the email event. Returns null for message's sent/received by other user's on the account
  """
  message: EmailType
}

"""
An object with an ID
"""
interface Node {
  """
  The ID of the object
  """
  id: ID!
}

"""
Represents an email communication
"""
type EmailType {
  id: ID!

  channel: MessageChannel!

  toAddress: String!

  fromEmail: String!

  toNumber: String!

  fromNumber: String!

  templateCode: String!

  createdAt: DateTime!

  sentAt: DateTime

  """
  Attachments of the email message.
  """
  attachments: [EmailAttachmentType]

  """
  Subject line of the email message.
  """
  subject: String

  textBody: String

  htmlBody: String

  """
  Email sender
  """
  sender: String

  """
  Email recipient
  """
  recipient: String
}

"""
An enumeration.
"""
enum MessageChannel {
  """
  Email
  """
  EMAIL

  """
  SMS
  """
  SMS

  """
  Print
  """
  PRINT

  """
  Intercom
  """
  INTERCOM

  """
  Junifer
  """
  JUNIFER

  """
  Push Notification
  """
  PUSH_NOTIFICATION
}

"""
Represents a file to attach to a email message.
"""
type EmailAttachmentType {
  id: ID!

  filename: String!

  """
  Temporary URL at which the attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  """
  temporaryUrl: String
}

type PrintEventType implements Node {
  """
  The ID of the object
  """
  id: ID!

  eventType: String!

  occurredAt: DateTime!

  """
  Print message of the print event.
  """
  message: PrintMessageType
}

"""
Represents a print communication.
"""
type PrintMessageType implements Node {
  """
  The ID of the object
  """
  id: ID!

  templateCode: String!

  account: AccountType

  """
  Attachments of the message.
  """
  attachments: [PrintAttachmentType]

  """
  Comms that are marked as high priority.
  """
  highPriority: Boolean
}

type SavingSessionsAccountReturnType {
  number: String!
}

"""
Represents a print attachment
"""
type PrintAttachmentType {
  id: ID!

  filename: String!

  s3Bucket: String!

  s3Key: String!

  """
  Temporary URL at which the attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  """
  temporaryUrl: String
}

"""
An enumeration.
"""
enum AccountEventType {
  """
  The email messages that were sent by the account.
  """
  EMAIL_SENT

  """
  The email messages that were received by the account.
  """
  EMAIL_RECEIVED

  """
  The marketing email messages that were sent by the account.
  """
  MARKETING_EMAIL_SENT

  """
  The print messages that were sent to the print partner by the account.
  """
  PRINT_SENT

  """
  The print messages that failed to be delivered.
  """
  PRINT_FAILED

  """
  The print messages that were returned to sender.
  """
  PRINT_RETURNED

  """
  The print messages that were cancelled.
  """
  PRINT_CANCELLED

  """
  The print messages that were sent by the print partner.
  """
  PRINT_SUCCEEDED
}

type AccountApplicationConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AccountApplicationConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountApplicationConnectionType` and its cursor.
"""
type AccountApplicationConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AccountApplicationType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type AccountApplicationType {
  status: AccountApplicationStatus!

  salesChannel: String!

  """
  The sales subchannel used when signing up. This could for example be a price comparison site.
  """
  salesSubchannel: String

  """
  Date at which this account decided to switch to us.
  """
  dateOfSale: Date

  """
  Last day of the cooling off period. Barring changes or objections, the account will be gained on the next business day after this date. This value will only be returned for current applications.
  """
  coolingOffEndDate: Date

  """
  Whether this account application represents a migration into the current system or a regular gain.
  """
  isMigrated: Boolean

  """
  The source system for a migrated account. This could be the previous supplier or the previous account management system.
  """
  migrationSource: String
}

"""
An enumeration.
"""
enum AccountApplicationStatus {
  """
  Current
  """
  CURRENT

  """
  Failed
  """
  FAILED

  """
  Historic
  """
  HISTORIC

  """
  Withdrawn
  """
  WITHDRAWN
}

"""
An enumeration.
"""
enum AccountTypeChoices {
  """
  An account designed to supply/bill business premises.
  """
  BUSINESS

  """
  An account designed to supply/bill domestic premises.
  """
  DOMESTIC

  """
  An account created when we supply a business premises but do not have details for the occupants.
  """
  BUSINESS_OCCUPIER

  """
  An account created when we supply a domestic premises but do not have details for the occupants.
  """
  OCCUPIER

  """
  An account created when we supply domestic premises that are managed by a business, i.e., a B2B2C model.
  """
  MANAGED

  """
  An account which is responsible for all other accounts in the portfolio, i.e. pays the bills for them.
  """
  PORTFOLIO_LEAD

  """
  An account created when we supply a business premises and know there are definitely no occupants.
  """
  BUSINESS_VACANT

  """
  An account created when we supply a domestic premises and know there are definitely no occupants.
  """
  VACANT
}

"""
An enumeration.
"""
enum BusinessTypeOptions {
  """
  A business account where the company type is sole trader.
  """
  SOLE_TRADER

  """
  A business account where the company type is limited.
  """
  LIMITED

  """
  A business account where the company type is proprietary limited.
  """
  PROPRIETARY_LIMITED_COMPANY

  """
  A business account where the company type is partnership.
  """
  PARTNERSHIP

  """
  A business account where the company type is charity.
  """
  CHARITY

  """
  A business account where the company type is public limited.
  """
  PUBLIC_LIMITED_COMPANY

  """
  A business account where the company type is limited liability partnership.
  """
  LIMITED_LIABILITY_PARTNERSHIP

  """
  A business account where the company type is a trust.
  """
  TRUST

  """
  A business account where the company has a trading name to carry out its business activities.
  """
  TRADING_AS

  """
  A business account for a government institution.
  """
  GOVERNMENT

  """
  A business account for a non-profit organisation.
  """
  NON_PROFIT

  """
  A business account for a church or other religious organisation.
  """
  CHURCH
}

type BusinessType {
  name: String!

  number: String!

  """
  The company type of a business account.
  """
  businessType: BusinessTypeOptions
}

"""
The method the account has specified they prefer we contact them
"""
enum CommsDeliveryPreference {
  EMAIL

  POSTAL_MAIL
}

"""
An enumeration.
"""
enum DocumentAccessibilityChoices {
  """
  Large print documents are requested for this account.
  """
  LARGE_PRINT

  """
  Braille documents are requested for this account.
  """
  BRAILLE

  """
  Audio-accessible documents are requested for this account.
  """
  AUDIO
}

type AccountReferenceType {
  namespace: String!

  value: String!

  createdAt: DateTime!

  updatedAt: DateTime!

  account: AccountType!
}

type AccountFileAttachment implements Node & FileAttachment {
  """
  The ID of the object
  """
  id: ID!

  filename: String!

  category: String!

  """
  Is the file uploaded to S3?
  """
  isUploaded: Boolean

  """
  Is the file ready for use / downloadable?
  """
  isReady: Boolean

  fetchUrl: String

  sizeInBytes: Int
}

interface FileAttachment {
  """
  Is the file uploaded to S3?
  """
  isUploaded: Boolean

  """
  Is the file ready for use / downloadable?
  """
  isReady: Boolean

  fetchUrl: String

  sizeInBytes: Int
}

type AccountFileAttachmentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AccountFileAttachmentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AccountFileAttachmentConnectionType` and its cursor.
"""
type AccountFileAttachmentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AccountFileAttachment

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type MaximumRefundType {
  """
  The maximum amount available to be requested as a refund.
  """
  amount: Int

  """
  The reason why a specific amount is the maximum available to be requested as a refund.
  """
  reasonToRecommendAmount: MaximumRefundReasonChoices

  """
  The recommended minimum balance an account should have when asking for a refund.
  """
  recommendedBalance: Int
}

"""
An enumeration.
"""
enum MaximumRefundReasonChoices {
  """
  Maximum refund is equal to the current balance minus the account recommended balance.
  """
  MAX_AVAILABLE_AMOUNT

  """
  Maximum refund is equal to the total amount the customer has paid using the current account Direct Debit instruction.
  """
  TOTAL_AMOUNT_PAID_VIA_ACTIVE_DDI

  """
  Maximum refund is equal to the maximum refund amount allowed to be requested via the dashboard.
  """
  MAX_ALLOWED_TO_REQUEST_VIA_DASHBOARD
}

type AccountCampaignType {
  """
  The date on which the associated campaign itself concludes.
  """
  campaignExpiryDate: Date

  """
  The name of the campaign.
  """
  name: String

  """
  The slug of the campaign.
  """
  slug: String

  """
  The date on which the account's participation in the campaign ends.
  """
  expiryDate: Date

  """
  The date that the account's link to the campaign started.
  """
  startDate: Date
}

"""
Represents a Hardship Agreement for a particular Account.
"""
type HardshipAgreementType {
  id: ID!

  hardshipType: HardshipAgreementHardshipType!

  """
  These are internal notes detailing the hardship.
  """
  hardshipDetails: String!

  hardshipEntryReason: HardshipAgreementHardshipEntryReason

  paymentPlanDetails: String!

  startDate: Date!
}

"""
An enumeration.
"""
enum HardshipAgreementHardshipType {
  """
  Death in the family
  """
  DEATH_IN_FAMILY

  """
  Household illness
  """
  HOUSEHOLD_ILLNESS

  """
  Family violence
  """
  FAMILY_VIOLENCE

  """
  Unemployment
  """
  UNEMPLOYMENT

  """
  Reduced income
  """
  REDUCED_INCOME

  """
  Other
  """
  OTHER
}

"""
An enumeration.
"""
enum HardshipAgreementHardshipEntryReason {
  """
  Customer self-identified as being in hardship
  """
  SELF_IDENTIFIED

  """
  Financial counsellor or external agent referral
  """
  EXTERNAL_REFERENCE

  """
  Retailer referral
  """
  RETAILER_REFERRAL
}

type AccountNoteType {
  body: String!

  isPinned: Boolean!

  createdAt: DateTime!
}

"""
A single Contribution Agreement.
"""
type ContributionAgreementType {
  id: ID!

  """
  The scheme to which the agreement contributes.
  """
  contributionScheme: ContributionSchemeType

  """
  The frequency of contributions.
  """
  interval: Interval

  """
  The start datetime of the agreement.
  """
  activeFrom: DateTime

  """
  The end datetime of the agreement, if any.
  """
  activeTo: DateTime

  """
  The amount contributed per interval. Note, this is in the smallest domination that the currecy support. e.g. Pence, Cents, Yen, etc.
  """
  amount: Int

  """
  The periods over which contributions have been made.
  """
  periods(before: String, after: String, first: Int, last: Int): ContributionPeriodConnection
}

"""
A single Contribution Scheme.
"""
type ContributionSchemeType {
  id: ID!

  code: String!

  displayName: String!

  """
  Are contributions to this scheme taxable?
  """
  taxable: Boolean!

  """
  Is this scheme currently accepting contributions?
  """
  acceptingContributions: Boolean!
}

"""
    The frequency at which contributations are made
    
"""
enum Interval {
  MONTHLY

  QUARTERLY
}

"""
Pagination for contribution periods.
"""
type ContributionPeriodConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ContributionPeriodEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `ContributionPeriod` and its cursor.
"""
type ContributionPeriodEdge {
  """
  The item at the end of the edge
  """
  node: ContributionPeriodType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A single Contribution Period.
"""
type ContributionPeriodType {
  id: ID!

  agreement: ContributionAgreementType!

  """
  When the contribution was fulfilled
  """
  fulfilledAt: DateTime

  """
  The datetime the marks the beginning of the period.
  """
  periodFrom: DateTime

  """
  The datetime the marks the end of the period.
  """
  periodTo: DateTime
}

"""
A single Assistance Agreement.
"""
type AssistanceAgreementType {
  """
  The type of assistance provided by the agreement.
  """
  assistanceType: String

  """
  The start datetime of the agreement.
  """
  activeFrom: Date

  """
  The end datetime of the agreement, if any.
  """
  activeTo: Date
}

type DebtCollectionProceedingType {
  """
  The agency responsible for the collection proceedings.
  """
  agency: DebtCollectionAgencyType

  """
  The campaign type of the collection proceedings.
  """
  campaign: CollectionCampaignType

  amount: Int

  startedAt: DateTime!

  stoppedAt: DateTime

  stopReason: DebtCollectionProceedingStopReason
}

type DebtCollectionAgencyType {
  name: String!

  code: String!

  isActive: Boolean!
}

"""
An enumeration.
"""
enum CollectionCampaignType {
  VULNERABLE_CUSTOMER

  HOME_VISIT

  TRACE

  DECEASED

  THIRD_PARTY

  FINAL_DEBT_COLLECTION

  FINAL_DEBT_COLLECTION_2

  OCCUPIER

  LITIGATION

  PERSISTENT_DEBT

  DEBT_COLLECTION_AGENCY

  LOW_RISK

  MEDIUM_RISK

  HIGH_RISK

  INSOLVENT

  TRACE_AND_COLLECT

  VULNERABILITY_VISIT

  LIVE_B2B

  FINAL_B2B

  B2B_DISCONNECTION_PROCESS

  SWITCH_TO_SMART_PAYG
}

"""
An enumeration.
"""
enum DebtCollectionProceedingStopReason {
  """
  Bankrupt
  """
  BANKRUPT

  """
  Deceased
  """
  DECEASED

  """
  Gone away
  """
  GONE_AWAY

  """
  In prison
  """
  IN_PRISON

  """
  Negative trace
  """
  NEGATIVE_TRACE

  """
  Paid in full
  """
  PAID_IN_FULL

  """
  Process exhausted
  """
  PROCESS_EXHAUSTED

  """
  Process exhausted - no contact
  """
  PROCESS_EXHAUSTED_NO_CONTACT

  """
  Process exhausted - contact
  """
  PROCESS_EXHAUSTED_CONTACT

  """
  Reduced settlement
  """
  REDUCED_SETTLEMENT

  """
  Vulnerable
  """
  VULNERABLE

  """
  Withdrawn
  """
  WITHDRAWN

  """
  Write off
  """
  WRITE_OFF

  """
  Payment arrangement
  """
  PAYMENT_ARRANGEMENT

  """
  Payment plan agreed
  """
  PAYMENT_PLAN_AGREED

  """
  Part payment
  """
  PART_PAYMENT

  """
  PPM arrangement
  """
  PPM_ARRANGEMENT

  """
  PPM requested
  """
  PPM_REQUESTED

  """
  Arrears to client
  """
  ARREARS_TO_CLIENT

  """
  High level complaint
  """
  HIGH_LEVEL_COMPLAINT

  """
  Insolvencies dealing
  """
  INSOLVENCIES_DEALING

  """
  Partial settlement
  """
  PARTIAL_SETTLEMENT

  """
  PPM fitted
  """
  PPM_FITTED

  """
  Refused to deal
  """
  REFUSED_TO_DEAL

  """
  Live to final
  """
  LIVE_TO_FINAL

  """
  COT / COS
  """
  COT_COS

  """
  COS
  """
  COS

  """
  COT proof seen
  """
  COT_PROOF_SEEN

  """
  COT no proof
  """
  COT_NO_PROOF

  """
  Enrolled in Error
  """
  ENROLLED_IN_ERROR

  """
  Low balance
  """
  LOW_BALANCE

  """
  Expired
  """
  EXP

  """
  Unable to locate property
  """
  UNABLE_TO_LOCATE_PROPERTY

  """
  Confirmed empty
  """
  CONFIRMED_EMPTY

  """
  Demolished
  """
  DEMOLISHED

  """
  Unable to trace
  """
  UNABLE_TO_TRACE

  """
  Query
  """
  QUERY
}

input ReplaceAgreementInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  MPxN of the related meter point to the agreement.
  """
  mpxn: String!

  """
  Date to replace on, must be in future.
  """
  replaceOnDate: Date!

  """
  Product code to replace with.
  """
  newProductCode: String!
}

type InstallationType {
  """
  FIT ID of the installation.
  """
  fitId: String

  """
  Meter inspection date
  """
  inspectionAt: DateTime

  """
  Details of any meters attached to the installation.
  """
  meters: [FitMeterType]

  """
  Address of the property linked to the installation.
  """
  propertyAddress: PropertyAddressType
}

type FitMeterType {
  """
  Serial number of the meter.
  """
  serialNumber: String

  """
  ID of the meter.
  """
  id: String

  """
  The type of meter.
  """
  type: String

  readings(before: String, after: String, first: Int, last: Int): FitReadingConnectionTypeConnection

  """
  Any installation capacities linked to the meter.
  """
  installationCapacities: [InstallationCapacityType]

  """
  The maximum read volume expected for the current datetime, including any extra tolerance allowed.
  """
  maxExpectedRead: Decimal

  """
  MPAN of the meter point linked to the meter.
  """
  mpan: String
}

type FitReadingConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [FitReadingConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

"""
A Relay edge containing a `FitReadingConnectionType` and its cursor.
"""
type FitReadingConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: FitReadingType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type FitReadingType {
  value: Decimal!

  readAt: DateTime!

  isBiennial: Boolean
}

type InstallationCapacityType {
  declaredNetCapacity: Decimal!

  extensionReference: String!

  installedCapacity: Decimal!
}

type PropertyAddressType {
  addressLine1: String!

  addressLine2: String!

  town: String!

  county: String!

  country: String!

  postcode: String!
}

type FitScheduleType {
  """
  Unique Identifier of the schedule.
  """
  scheduleId: UUID

  """
  Datetime the schedule was sent.
  """
  sentAt: DateTime

  """
  Datetime the schedule was accepted.
  """
  acceptedAt: DateTime

  """
  URLs for any schedule PDFs. URLs are temporary and will expire in approximately one hour. They are intended for redirection purposes only; they are not persistent in any form (eg. in emails or a web page body).
  """
  temporaryDownloadUrls: [String]
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""
The possible errors that can be raised are:

- KT-GB-6812: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type FitCreateMeterReadings {
  possibleErrors: [PossibleErrorType]

  readingsSubmitted: Boolean
}

input FitMeterReadingInput {
  installations: [FitInstallationInput]!
}

input FitInstallationInput {
  fitId: String!

  meters: [FitMeterInput]!
}

input FitMeterInput {
  id: Int!

  reading: FitReadingInput!
}

input FitReadingInput {
  value: Decimal!

  readAt: DateTime!

  isBiennial: Boolean
}

"""
FiT customers need to be able to accept their FiT schedules.
There are a number of conditions that need to be met for a schedule:
    - It must have been sent
    - It must not have been accepted
    - It must not be in the future

The possible errors that can be raised are:

- KT-GB-6813: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type FitAcceptSchedule {
  possibleErrors: [PossibleErrorType]

  """
  The accepted schedule.
  """
  fitSchedule: FitScheduleType
}

input FitAcceptScheduleInput {
  """
  The ID of the schedule to accept.
  """
  scheduleId: UUID!

  """
  The account number associated with this schedule.
  """
  accountNumber: String!
}

type LivePaymentAdequacyQuery {
  """
  The suggested monthly payment amount in pence following the payment adequacy review.
  """
  recommendedPayment: PaymentBreakdown

  """
  How much balance we expect the account to have at this time of year.
  """
  currentBalance: Int

  """
  How much balance we expect the account to have at this time of year.
  """
  targetBalance: Int

  """
  Breakdown of customer's usage per source and per month.
  """
  estimatedConsumption: [ConsumptionBreakdown]

  """
  The date that we used to calculate the review of the account.
  """
  reviewedOn: Date
}

type PaymentBreakdown {
  """
  Total to pay: ongoing + adjustment.
  """
  total: Int

  """
  Amount which covers ongoing usage.
  """
  ongoing: Int

  """
  Temporary amount to cover debt.
  """
  adjustment: Int
}

type ConsumptionBreakdown {
  """
  Human readable name of what the usage is for.
  """
  sourceName: String

  """
  Unique identifier of the source of the usage.
  """
  sourceId: String

  """
  Monthly usage in pence. First month is January.
  """
  usage: [Int]
}

type SEGInstallationType {
  """
  Whether the SEG installation is valid according to MCS.
  """
  isValid: Boolean!
}

type ElectricityConsumptionType {
  """
  The estimated Electricity Annual Consumption measured in kWh.
  """
  eac: Float

  """
  The date from which the EAC is calculated.
  """
  eacEffectiveFromDate: Date

  """
  The current supplier for the meterpoint.
  """
  supplierName: String

  """
  The date the meterpoint switched to the current supplier.
  """
  supplierEffectiveFromDate: Date

  """
  A flag stating if the meterpoint has ever had an erroneous transfer of supplier.
  """
  hasErroneousTransfer: Boolean
}

type GasConsumptionType {
  """
  The estimated Annual Quantity measured in kWh.
  """
  aq: Int

  """
  The current supplier for the meterpoint.
  """
  supplierName: String

  """
  The date the meterpoint switched to the current supplier.
  """
  supplierEffectiveFromDate: Date

  """
  The date from which the AQ is calculated.
  """
  aqEffectiveFromDate: Date
}

"""
Mutation to disable the token used to call this mutation. Requires a valid token
for authentication to avoid a potential denial-of-service issue. The token used
for authentication will be the token disabled.
"""
type DisableToken {
  message: String
}

type APIKeyAuthentication {
  """
  The DRF token to be used for authentication.
  """
  token: String

  errors: [ErrorType]
}

type EmailAuthentication {
  """
  The DRF token to be used for authentication.
  """
  token: String

  errors: [ErrorType]
}

type ErrorType {
  field: String!

  messages: [String!]!
}

type HeatPumpGoodsQuote {
  """
  Account associated to quote.
  """
  accountNumber: String

  """
  Quote code.
  """
  code: String!

  """
  ID of the quote.
  """
  quoteId: Int!

  """
  Quoted product details.
  """
  quotedProduct: GoodsQuotedProduct!

  """
  Contact details stored in hubspot.
  """
  contactDetails: ContactDetails!

  """
  Property details stored in hubspot.
  """
  addressDetails: AddressDetails!
}

type GoodsQuotedProduct {
  """
  Product code.
  """
  product: String

  """
  Number of units.
  """
  numberOfUnits: Int

  """
  Price per unit.
  """
  pricePerUnit: Int

  """
  Net amount.
  """
  netAmount: Int

  """
  Currency.
  """
  currency: String
}

type ContactDetails {
  """
  First name.
  """
  firstName: String!

  """
  Last name.
  """
  lastName: String!

  """
  Email.
  """
  email: String!

  """
  Phone.
  """
  phone: String!
}

type AddressDetails {
  """
  Unique Property Reference Number.
  """
  uprn: String

  """
  First address line.
  """
  addressLine1: String!

  """
  Second address line.
  """
  addressLine2: String

  """
  Third address line.
  """
  addressLine3: String

  """
  Fourth address line.
  """
  addressLine4: String

  """
  Fifth address line.
  """
  addressLine5: String

  """
  Postcode.
  """
  postcode: String!
}

type UPRNAddressLookup {
  """
  Unique Property Reference Number.
  """
  uprn: String

  """
  First address line.
  """
  addressLine1: String

  """
  Second address line.
  """
  addressLine2: String

  """
  Third address line.
  """
  addressLine3: String

  """
  Fourth address line.
  """
  addressLine4: String

  """
  Fifth address line.
  """
  addressLine5: String

  """
  Postcode.
  """
  postcode: String!

  """
  The complete and human-legible address in a single string.
  """
  display: String!

  """
  The non-human-legible address in a single string.
  """
  addressKey: String!
}

type UPRNLookup {
  """
  Unique Property Reference Number.
  """
  uprn: String
}

"""
Create a Goods quote for heat pumps.

This augments the standard goods quote with additional heat pump information.
"""
type CreateHeatPumpGoodsQuote {
  """
  Generated heat pump quote.
  """
  quote: HeatPumpGoodsQuote
}

input CreateHeatPumpGoodsQuoteInput {
  """
  Account to associate quote to.
  """
  accountNumber: String

  """
  ID of the product to quote.
  """
  productId: Int!

  """
  Details of the address.
  """
  addressDetails: AddressDetailsInput!

  """
  Details to pass to hubspot.
  """
  contactDetails: ContactDetailsInput!

  """
  Details of the property, used for eligiblity checks.
  """
  propertyDetails: PropertyDetailsInput!
}

input AddressDetailsInput {
  """
  Unique Property Reference Number.
  """
  uprn: String

  """
  First address line.
  """
  addressLine1: String!

  """
  Second address line.
  """
  addressLine2: String!

  """
  Third address line.
  """
  addressLine3: String

  """
  Fourth address line.
  """
  addressLine4: String

  """
  Fifth address line.
  """
  addressLine5: String

  """
  Postcode.
  """
  postcode: String!
}

input ContactDetailsInput {
  """
  First name.
  """
  firstName: String!

  """
  Last name.
  """
  lastName: String!

  """
  Email.
  """
  email: String!

  """
  Phone.
  """
  phone: String!

  """
  Consent to MBNA.
  """
  consentToMbna: Boolean
}

input PropertyDetailsInput {
  """
  Property type.
  """
  propertyType: HeatPumpPropertyType!

  """
  Heat type.
  """
  heatType: HeatPumpHeatType!

  """
  Whether the property has outdoor space for a heat pump.
  """
  hasOutdoorSpaceForHeatPump: Boolean

  """
  Whether the property has indoor space for a cylinder.
  """
  hasIndoorSpaceForCylinder: Boolean

  """
  Whether the property is undergoing a home renovation.
  """
  isHomeRenovation: Boolean
}

"""
An enumeration.
"""
enum HeatPumpPropertyType {
  END_OF_TERRACE

  SEMI_DETACHED

  DETACHED

  TERRACE

  FLAT

  OTHER

  FLAT_GROUND_FLOOR
}

"""
An enumeration.
"""
enum HeatPumpHeatType {
  MAINS_GAS_BOILER

  LPG_BOILER

  ELECTRIC_BOILER

  ELECTRIC_RADIATOR

  OIL_BOILER

  ELECTRIC_STORAGE_HEATER

  OTHER
}

"""
Create an EV Public Charging agreement.

The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-5811: Active agreement already exists.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateEvPublicChargingAgreement {
  possibleErrors: [PossibleErrorType]

  agreement: Agreement
}

"""
The input type for creating an EV Public Charging agreement.
"""
input CreateEvPublicChargingAgreementInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  Identifier of an account in the external system.
  """
  externalAccountId: String!

  """
  The start time of the agreement.
  """
  validFrom: DateTime!
}

"""
Add an EV Public Charging token.

The possible errors that can be raised are:

- KT-CT-5817: Invalid data.
- KT-CT-5812: Token with this value already exists within this period.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type AddEvPublicChargingToken {
  possibleErrors: [PossibleErrorType]

  token: Token
}

type Token {
  """
  Token's identifying value.
  """
  value: String!

  validFrom: DateTime!

  validTo: DateTime
}

"""
The input type for adding an EV Public Charging token.
"""
input AddEvPublicChargingTokenInput {
  """
  Identifier of an account in the external system.
  """
  externalAccountId: String!

  """
  Token identifier.
  """
  tokenValue: String!

  """
  The start time of token's validity.
  """
  validFrom: DateTime!
}

"""
Expire an EV Public Charging token.

The possible errors that can be raised are:

- KT-CT-5817: Invalid data.
- KT-CT-5818: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ExpireEvPublicChargingToken {
  possibleErrors: [PossibleErrorType]

  token: Token
}

"""
The input type for expiring an EV Public Charging token.
"""
input ExpireEvPublicChargingTokenInput {
  """
  Identifier of an account in the external system.
  """
  externalAccountId: String!

  """
  Token identifier.
  """
  tokenValue: String!

  """
  The end time of token's validity.
  """
  validTo: DateTime!
}

"""
Initiate a standalone payment and return the client secret required to complete it.

The possible errors that can be raised are:

- KT-CT-5813: Invalid data.
- KT-CT-5814: Invalid data.
- KT-CT-5815: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type PostEVPublicChargingCharge {
  possibleErrors: [PossibleErrorType]

  accountCharge: AccountChargeType
}

"""
The input type for post an EV Public Charging charge.
"""
input PostEVPublicChargingChargeInput {
  """
  The value of the token used for this session.
  """
  tokenValue: String!

  """
  The line items for the new charge.
  """
  lineItems: [EVPCLineItem!]!

  """
  The tax items for the new charge.
  """
  taxItems: [EVPCTaxItem!]!
}

input EVPCLineItem {
  """
  The amount (excl. tax) in smallest units of currency.
  """
  amount: Int!

  """
  The start of the public charging session.
  """
  periodStartAt: DateTime!

  """
  The end of the public charging session.
  """
  periodEndAt: DateTime!

  """
  The rate band of this line item.
  """
  band: ProductRateBands!

  """
  JSON containing any additional metadata.
  """
  metadata: JSONString
}

"""
The product rate band of a line item.
"""
enum ProductRateBands {
  """
  CONSUMPTION.
  """
  CONSUMPTION

  """
  TIME.
  """
  TIME

  """
  FEE.
  """
  FEE
}

input EVPCTaxItem {
  """
  The amount in smallest units of currency.
  """
  amount: Int!

  """
  The amount (excl. tax) that this tax was calculated from, in smallest units of currency.
  """
  amountTaxed: Int!

  """
  The rate at which tax was applied.
  """
  rate: Decimal!

  """
  The unit of the tax rate.
  """
  unitType: TaxUnitType!

  """
  The type of tax (e.g. 'VAT').
  """
  taxType: String!

  """
  JSON containing any additional metadata.
  """
  metadata: JSONString
}

"""
The dimension of the tax rate.

e.g. a sales tax is a `PROPORTION` tax with a rate of 0.25, CCL is a `CURRENCY_PER_KWH` tax
with a value of 0.5.
"""
enum TaxUnitType {
  PROPORTION

  CURRENCY_PER_KWH
}

"""
The possible errors that can be raised are:

- KT-CT-5816: Invalid data.
- KT-CT-5817: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type PostEVPublicChargingCredit {
  possibleErrors: [PossibleErrorType]

  """
  Posts an EV Public charging credit.
  """
  credit: Credit
}

"""
A credit to the customer from the energy retailer.
"""
type Credit implements TransactionType {
  id: ID

  postedDate: Date

  """
  The date time when the transaction is created.
  """
  createdAt: DateTime

  """
  Unique identifier of the account the transaction belongs to.
  """
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """
  Deprecated.
  """
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean

  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """
  Returns None if a statement is not linked with the transaction.
  """
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")

  isReversed: Boolean!

  """
  Returns True if the transaction is linked with a statement.
  """
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

"""
Transactions are a record of money being added or subtracted from the overall account balance
"""
interface TransactionType {
  id: ID

  postedDate: Date

  """
  The date time when the transaction is created.
  """
  createdAt: DateTime

  """
  Unique identifier of the account the transaction belongs to.
  """
  accountNumber: String

  """
  Gross amount including tax (when payable). Refer to the `amounts` field for a breakdown of this information.
  """
  amount: Int @deprecated(reason: "The 'amount' field is deprecated.\n\nUse `amounts` instead for a breakdown of the relevant net, tax, and gross amounts.\n\n- Marked as deprecated on 2023-12-06.\n- Will be removed on 2024-06-01.")

  """
  The net, tax and gross amounts for the transaction. Note: for payments and repayments, only the net amount is returned.
  """
  amounts: TransactionAmountType

  """
  The customer's resulting balance after this transaction has been applied, in the smallest unit of currency.
  """
  balanceCarriedForward: Int

  """
  Deprecated.
  """
  isCredit: Boolean @deprecated(reason: "The 'isCredit' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountCharge: Boolean @deprecated(reason: "The 'isAccountCharge' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Deprecated.
  """
  isAccountPayment: Boolean @deprecated(reason: "The 'isAccountPayment' field is deprecated.\n\nThis information is provided by the __typename introspection query.\n\n- Marked as deprecated on 2020-06-19.\n- Will be removed on 2022-11-15.")

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.  Returns False if a statement is not linked with the transaction.
  """
  isHeld: Boolean

  """
  Whether this transaction has been issued on any billing document.Note: Look for the most recently issued transaction instead of looking through all transactions as some accounts may have initial transactions that were not issued.This will return False if the transaction is not associated with any billing documents.
  """
  isIssued: Boolean

  title: String

  """
  The unique identifier for the most recent billing document linked with the transaction.Note: a transaction may be linked with multiple documents, but this field will only return the identifier for the most recent billing document.
  """
  billingDocumentIdentifier: ID

  """
  Returns None if a statement is not linked with the transaction.
  """
  statementId: ID @deprecated(reason: "The 'statementId' field is deprecated.\n\nUse `billingDocumentIdentifier` instead.\n\n- Marked as deprecated on 2023-11-30.\n- Will be removed on 2024-06-01.")

  isReversed: Boolean!

  """
  Returns True if the transaction is linked with a statement.
  """
  hasStatement: Boolean

  """
  Returns the note field value for the transaction, which contains additional info.
  """
  note: String
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

type TransactionAmountType {
  """
  The net amount (in minor currency units).
  """
  net: Int

  """
  The amount of tax (in minor currency units).
  """
  tax: Int

  """
  The gross amount (in minor currency units).
  """
  gross: Int
}

input PostEVPublicChargingCreditInput {
  """
  The external account identifier.
  """
  externalAccountId: String!

  """
  The net amount of the credit to be added. Amount should be posted in the smallest unit of currency.
  """
  netAmount: Int!

  """
  The tax amount of the credit to be added. Amount should be posted in the smallest unit of currency.
  """
  taxAmount: Int!

  """
  The reason why the credit is added.
  """
  reason: AccountCreditReasonType!

  """
  Optional short note about the credit, to be displayed to the user.
  """
  displayNote: String
}

"""
Create an Electric Juice agreement for an account.
"""
type CreateElectricJuiceAgreement {
  agreement: Agreement
}

type Agreement {
  id: ID!
}

"""
The input type for creating an Electric Juice agreement.
"""
input CreateElectricJuiceAgreementInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The time from which the new agreement is valid (default: now).
  """
  validFrom: DateTime
}

"""
Create a new Electric Juice charge card for an account.
"""
type CreateElectricJuiceChargeCard {
  chargeCard: ChargeCardType
}

type ChargeCardType {
  id: ID!

  uid: String!

  nameOnCard: String!
}

"""
The input type for creating a new Electric Juice charge card.
"""
input CreateElectricJuiceChargeCardInput {
  """
  The UID on the charge card.
  """
  chargeCardUid: String!

  """
  The name printed on the charge card.
  """
  nameOnCard: String!

  """
  The account number of the account this charge card should be associated with.
  """
  accountNumber: String!
}

type Query {
  """
  Get a meter point via it's associated mpan or mprn.
  """
  meterPoints("The MPAN for the electricity meterpoint to return." mpan: ID, "The MPRN for the gas meterpoint to return." mprn: ID): MeterPointInterface

  applicableRates(accountNumber: String!, mpxn: String!, startAt: DateTime!, endAt: DateTime!, before: String, after: String, first: Int, last: Int): ApplicableRateConnectionTypeConnection

  """
  This is a work in progress and not in use yet.
  """
  quoteRequest("Code of the quote request." quoteCode: String!): QuoteRequest

  """
  Follow on product.
  """
  followOnProduct("Kraken account number." accountNumber: String!, "Electricity agreement Kraken ID." electricityAgreementId: ID, "Gas agreement Kraken ID." gasAgreementId: ID, validAt: DateTime!): FollowOnProductType

  """
  Available energy product, whose display name has the given prefix.
  """
  availableProductFromDisplayName("Display name of the product." displayName: String!): EnergyProductType

  """
  A list of product codes that are the currently available products for a meter point.
  """
  availableProductsForMeterPoint("Kraken account number." accountNumber: String!, "A list of MPxNs." mpxns: [String]!, availableAt: DateTime!): [MPxNProductType]

  """
  Check meter point eligibility for an energy product.
  """
  meterPointProductEligibility("Kraken account number." accountNumber: String!, "MPXN of a meter point." mpxn: String!, "Energy product code." productCode: String!): ProductEligibilityForMeterPoint

  """
  Get an energy product that matches the given code.
  """
  energyProduct("Code for the energy product." code: String!): EnergyProductType

  """
  Get all products for a given brand and postcode. The supplied postcode will ensure that there are tariffs available on the product for the GSP.
  """
  energyProducts("Postcode to search energy products for." postcode: String!, "Filter by a specific energy brand." brand: String, "Filter by these brands." brands: [String], "Filter for available or unavailable products only." availability: EnergyProductAvailability, "Filter by the type of energy product." filterBy: [EnergyProductFilters], before: String, after: String, first: Int, last: Int): EnergyProductConnectionTypeConnection

  electricityPrepayLedgers(accountNumber: String!, mpan: String!, serialNumber: String!): PrepayLedgersType

  gasPrepayLedgers(accountNumber: String!, mprn: String!, serialNumber: String!): PrepayLedgersType

  """
  Payments made to add credit to the account's smart prepay meters.
  """
  prepayPayments(accountNumber: String!, before: String, after: String, first: Int, last: Int): PrepayPaymentConnectionTypeConnection

  """
   Get an electricity agreement. 

   

  This field requires the `Authorization` header to be set. 

  """
  electricityAgreement(id: ID!): AgreementInterface

  """
   Get an gas agreement. 

   

  This field requires the `Authorization` header to be set. 

  """
  gasAgreement(id: ID!): AgreementInterface

  """
  Get the details of a product enrolment.
  """
  productEnrolment("The account to which the enrolment belongs." accountNumber: String!, "The ID for the enrolment." enrolmentId: ID!): ProductEnrolmentType

  """
  Get all of the enrolments for an account.
  """
  productEnrolments("The account to find all the enrolments for." accountNumber: String!): [ProductEnrolmentType]

  """
  Validate a bank account.
  """
  validateBankAccount(accountNumber: String!, sortCode: String!, vendor: PaymentsVendorChoices = SMARTDEBIT): ValidateBankAccount

  """
  Earliest possible payment date from today for which the first direct debit payment can be made.
  """
  earliestPossibleDirectDebitPaymentDate: EarliestPossibleDirectDebitPaymentDate

  """
  Get the default payment instruction for the account's Electric Juice Network ledger.
  """
  defaultElectricJuicePaymentInstruction("The account number." accountNumber: String!): DefaultElectricJuicePaymentInstructionType

  """
  Heat pump goods quote.
  """
  heatPumpGoodsQuote("Quote code." code: String!): HeatPumpGoodsQuote

  """
  List of addresses associated with the postcode.
  """
  getAddressesByPostcode("The postcode of the addresses to return." postcode: String!): [UPRNAddressLookup]

  """
  Get uprn associated with mpan.
  """
  getUprnByMpan("The mpan of the address." mpan: String!): UPRNLookup

  """
  The annual electricity consumption data for an MPAN.
  """
  annualElectricityConsumption("The MPAN of the meterpoint to return." mpan: String!): ElectricityConsumptionType!

  """
  The annual gas consumption data for an MPRN.
  """
  annualGasConsumption("The MPRN of the meterpoint to return." mprn: String!): GasConsumptionType!

  """
  The validity of a SEG installation via the MCS installation database.
  """
  segInstallation("The MCS certificate number." mcsCertificateNumber: String!): SEGInstallationType!

  """
  Get up to date payment adequacy data.
  """
  livePaymentAdequacy("Kraken account number." accountNumber: String!): LivePaymentAdequacyQuery

  """
  Get details about FIT installations attached to an account, including any meters and previous readings.
  """
  fitInstallations("Account to query for FIT installations." accountNumber: String!): [InstallationType]

  """
  Get details about a FIT schedule attached to an account.
  """
  fitSchedule("The number of the account responsible for this FIT schedule." accountNumber: String!, "Unique identifier for the schedule." scheduleId: String!): FitScheduleType

  """
  All active campaigns with offers for the given account.
  """
  activeCampaignOffers(accountNumber: String!): [CampaignType]

  """
  List URLs for an account.
  """
  accountUrls(accountNumber: String!): [AccountUrl] @deprecated(reason: "The 'accountUrls' field is deprecated.\n\nPlease access the URLs through the support site.\n\n- Marked as deprecated on 2021-10-12.\n- Will be removed on 2024-01-01.")

  """
  List Wheel of Fortune URLs for an account.
  """
  wofUrls(accountNumber: String!): [AccountUrl] @deprecated(reason: "The 'wofUrls' field is deprecated.\n\nPlease use `urls` query instead.\n\n- Marked as deprecated on 2021-10-12.\n- Will be removed on 2024-01-01.")

  """
  URLs for an account.
  """
  urls("The account number of the URLs' account." accountNumber: String!): Urls

  """
  The balance forecast for an account.
  """
  balanceForecast("Kraken account number." accountNumber: String!): BalanceForecastType

  """
  The high level type for Carbon Emission Offsets.
  """
  carbonOffset: CarbonOffsetType @deprecated(reason: "The 'carbonOffset' field is deprecated.\n\nCarbon offset functionality is no longer supported.\n\n- Marked as deprecated on 2024-05-14.\n- Will be removed on 2024-07-14.")

  """
  Data concerning accounts charity donations.
  """
  charityDonationHistory(accountNumber: String!): CharityDonationHistoryType

  """
  Whether the account has already received a discount code.
  """
  hasReceivedADiscountCode("Kraken account number." accountNumber: String!): Boolean

  """
  Whether or not there are remaining discount codes available at the time of querying.
  """
  areDiscountCodesAvailable: Boolean

  """
  The discount code for this account, if one exists.
  """
  discountCode("Kraken account number." accountNumber: String!): String

  """
  The history of field sales visits to a specific address.
  """
  fieldSalesVisits("The postcode of the addresses to return." postcode: String!, before: String, after: String, first: Int, last: Int): FieldSalesVisitConnectionTypeConnection!

  """
  Get account status information given its number.
  """
  weeklyUsageInsights("The account number to search for." accountNumber: String!): WeeklyUsageInsightsType

  """
  Query relating to OctoPoints.
  """
  octoPoints("Kraken account number." accountNumber: String): OctoPointsType @deprecated(reason: "The 'octoPoints' field is deprecated.\n\nPlease use the loyaltyPointLedgers query instead\n\n- Marked as deprecated on 2024-02-06.\n- Will be removed on 2024-05-06.")

  """
  Returns the info required to request and display live usage information for the cared-for account meter: the meter device ID and 1st address line of the property.
  """
  octocareUsageInfo("Cared-for account number." accountNumber: String!): OctocareUsageInfo

  """
  Returns the info required to start the onboarding process for a Mini in the cared-for account's property, by the cared.
  """
  octocareOnboardingInfo("Cared-for account number." accountNumber: String!): OctocareOnboardingInfo

  """
  The account numbers of the accounts that the user is caring for.
  """
  caredForAccounts: [String!]!

  """
  Octoplus Snap constantines currently available for a given account_user.
  """
  getConstantines("Account number for the Octoplus-enrolled account." accountNumber: String!): ConstantineSpawnData

  """
  Get snap for given account user.
  """
  getSnaps("Account number for the Octoplus-enrolled account." accountNumber: String!): GetSnapsResponseType

  """
  Octoplus information for a given account.
  """
  octoplusAccountInfo("Kraken account number." accountNumber: String!): OctoplusAccountInfoType

  """
  Feature flags for the octoplus campaign
  """
  octoplusFeatureFlags: OctoplusFeatureFlagsType

  """
  Octoplus Rewards for a given account user
  """
  octoplusRewards("Id for the reward being queried." rewardId: Int, "Account number for the Octoplus-enrolled account." accountNumber: String, "Slug of the offer being queried." offerSlug: String): [OctoplusRewardType]

  """
  Octoplus Offers available for a given account_user and account combination
  """
  octoplusOffers("Account number for the Octoplus-enrolled account." accountNumber: String!, "Slug of the offer being queried." slug: String): [OctoplusOfferType]

  """
  Octoplus Offer Groups available for a given account_user and account combination.
  """
  octoplusOfferGroups("Account number for the Octoplus-enrolled account." accountNumber: String!, "ID of the Offer Group being queried." id: Int, before: String, after: String, first: Int, last: Int): OctoplusOfferGroupConnectionTypeConnection

  """
  Describes availability of Shoptopus Vouchers for given Octopoint amounts.
  """
  shoptopusVoucherAvailability("The values (in Octopoints) for which to return voucher availability (maximum 5 values)." voucherValues: [Int]!): [ShoptopusVoucherAvailabilityType]

  """
  Whether the account is meets the vulnerability criteria to receive a blanket.
  """
  doesAccountMeetVulnerabilityCriteria("The account number to check." accountNumber: String!): Boolean

  """
  Whether the account has already received a blanket.
  """
  hasAlreadyReceivedBlanket("The account number to check." accountNumber: String!): Boolean

  """
  Whether there are still blankets available.
  """
  areBlanketsAvailable: Boolean

  """
  Validate referral claim code.
  """
  validateReferralClaimCode("Referral claim code value." value: String!): ReferralClaimCodeType

  """
  Saving sessions queries for an account.
  """
  savingSessions("Kraken account number." accountNumber: String): SavingSessionsType

  """
  Compare consumption costs for different smart tariffs.
  """
  smartTariffComparison("MPAN of the import meter point linked to the meter." mpan: String): SmartTariffComparisonType

  """
  The currently active battery device.
  """
  batteryDevice(accountNumber: String!, propertyId: Int!): BatteryDeviceType

  """
  All supported batteries and their details.
  """
  batteryVariants("Only return batteries of a specific make." make: String): [BatteryVariantsType]

  """
  A list of wizards for onboarding devices for an account and property.
  """
  smartFlexOnboardingWizards("The account number, e.g. A-12345678." accountNumber: String!, "Only list wizards for this property." propertyId: Int): [SmartFlexOnboardingWizard!]

  """
  Auth details (e.g. OAuth 2.0 URI) for the provider (if available).
  """
  providerAuthDetails("The provider to get the auth details for." provider: ProviderChoices!, "The device type to get the auth details for (as providers may support multiple)." deviceType: KrakenFlexDeviceTypes!, "The client type the request originated from. Used when oauth_uri is different between web and app." clientType: ClientType = APP, "The account number that will be associated with the device. Required for some providers." accountNumber: String, "The ID of the property the device belongs to." propertyId: Int): ProviderAuthDetailsType

  """
  Determines whether an account is eligible to register devices with Intelligent Octopus.
  """
  accountIoEligibility("Account number." accountNumber: String!): AccountIoEligibility

  """
  Virtual key details (e.g. certificate public key) for the provider (if available).
  """
  providerVirtualKeyDetails("The provider to get the virtual key details for." provider: ProviderChoices!, "The device type to get the virtual key details for (as providers may support multiple)." deviceType: KrakenFlexDeviceTypes!): ProviderVirtualKeyDetailsType

  """
  A list of devices registered to an account.
  """
  devices("The account number, e.g. A-12345678." accountNumber: String!, "Only list devices registered to this property." propertyId: ID, "Only list the device with this ID." deviceId: String): [SmartFlexDeviceInterface!]

  """
  A list of device types that are eligible for registration.
  """
  eligibleDeviceTypes("The account number, e.g. A-12345678." accountNumber: String!): [KrakenFlexDeviceTypes]

  """
  The user specific generated OCPP details.
  """
  ocppDetails(accountNumber: String!): OCPPDetailsType

  """
  To confirm whether a device is connected to OCPP.
  """
  ocppConnection(accountNumber: String!): OCPPConnectionType

  """
  Vehicle charging preference details.
  """
  vehicleChargingPreferences(accountNumber: String!): VehicleChargingPreferencesType @deprecated(reason: "The 'vehicleChargingPreferences' field is deprecated.\n\nPlease use 'devices.chargingPreferences' instead.\n\n- Marked as deprecated on 2024-04-23.\n- Will be removed on 2024-11-01.")

  """
  A device registered with KrakenFlex for a given account.
  """
  registeredKrakenflexDevice(accountNumber: String!): KrakenFlexDeviceType @deprecated(reason: "The 'registeredKrakenflexDevice' field is deprecated.\n\nPlease use 'devices' instead.\n\n- Marked as deprecated on 2024-04-23.\n- Will be removed on 2024-11-01.")

  """
  All planned device dispatches 24 hours ahead, (usually) in time order.
  """
  plannedDispatches(accountNumber: String!): [UpsideDispatchType]

  """
  All completed device dispatches 12 hours behind, in reverse time order.
  """
  completedDispatches(accountNumber: String!): [UpsideDispatchType]

  """
  Aggregated cost of charge for an EV device.
  """
  costOfCharge(accountNumber: String!, "Frequency by day, week, month or year." frequency: DataFrequency!, "The date up to which data should be relative to." reportDate: Date @deprecated(reason: "The 'reportDate' field is deprecated.\n\nPlease use startDate instead.\n\n- Marked as deprecated on 2023-05-10.\n- Will be removed on 2024-01-01."), "The start date of the results required. Overrides report date (end date) if provided." startDate: Date): [CostOfChargeType]

  """
  All charge point devices.
  """
  chargePointDevices: [ChargePointDevicesType] @deprecated(reason: "The 'chargePointDevices' field is deprecated.\n\nPlease use chargePointVariants instead of this query.\n\n- Marked as deprecated on 2023-05-10.\n- Will be removed on 2024-01-01.")

  """
  All charge points variants.
  """
  chargePointVariants: [ChargePointVariantType]

  """
  All electric vehicle types and their details.
  """
  electricVehicles("Only return vehicle types for the specified make." make: String, "Only return vehicle types supported by the specified provider, e.g. Tesla." supportedProvider: ProviderChoices, "Only return vehicles that are currently integrated." isIntegrationLive: Boolean): [ElectricVehicleType]

  """
  The user specific Enode link session details.
  """
  enodeLinkSession(accountNumber: String, vendor: EnodeVendors): EnodeLinkSessionType

  """
  A list of vehicles available to the user.
  """
  userVehicles(accountNumber: String, "The provider used to authenticate the device (default Enode)." supportedProvider: ProviderChoices, "The authentication details required given the chosen provider." authentication: AuthenticationInput): [UserVehiclesType]

  """
  The currently active heat pump device.
  """
  heatPumpDevice(accountNumber: String!, propertyId: Int!): HeatPumpDeviceType

  """
  A heat pump registered with KrakenFlex for a given account
  """
  heatPumpStatus(accountNumber: String!): HeatPumpStatusType

  """
  All heat pumps and their details.
  """
  heatPumpVariants("Only return heat pumps of a specific make." make: String, "Only return (non-) deprecated heat pumps." isDeprecated: Boolean): [HeatPumpVariantsType]

  """
  Retrieve the heat pump controller device status.
  """
  heatPumpControllerStatus(accountNumber: String!, euid: ID!): ControllerStatus

  """
  Retrieve the heat pump controller device status.
  """
  octoHeatPumpControllerStatus(accountNumber: String!, euid: ID!): ControllerStatus

  """
  Heat pump controller, zones and sensor configuration.
  """
  heatPumpControllerConfiguration(accountNumber: String!, euid: ID!): ControllerAndZoneConfiguration

  """
  Heat pump controller, zones and sensor configuration.
  """
  octoHeatPumpControllerConfiguration(accountNumber: String!, euid: ID!): ControllerAndZoneConfiguration

  """
  Heat pump controller EUIDs associated with an account.
  """
  controllerEuids(accountNumber: String): [String]

  """
  Heat pump controller EUIDs associated with an account.
  """
  octoHeatPumpControllerEuids(accountNumber: String): [String]

  """
  Heat pump controllers attached to an account at a given location.
  """
  octoHeatPumpControllersAtLocation(accountNumber: String!, propertyId: ID!): [ControllerAtLocation]

  """
  Latest telemetry values from the heat pump.
  """
  octoHeatPumpLivePerformance(euid: ID!): LiveTelemetry

  """
  Latest telemetry values from the heat pump.
  """
  octoHeatPumpLifetimePerformance(euid: ID!): LifetimeTelemetry

  """
  Heat pump performance data over a specified period in time buckets.
  """
  octoHeatPumpTimeSeriesPerformance(euid: ID!, startAt: DateTime!, endAt: DateTime!, performanceGrouping: PerformanceGrouping!): [HeatPumpPerformanceGroupingNode]

  """
  Heat pump performance data between two specific dates.
  """
  octoHeatPumpTimeRangedPerformance(euid: ID!, startAt: DateTime!, endAt: DateTime!): HeatPumpTimeRangedPerformance

  """
  Get current status, historic discounts and future projections for a Fan Club source.
  """
  fanClubStatus(accountNumber: String, propertyId: Int): [FanClubStatus]

  """
  A forecast of how green the electricity generation is predicted to be (do not assume a fixed length, that the periods are contiguous or in time order).
  """
  greennessForecast: [GreennessForecastPeriod]

  """
   Retrieve the number of available Wheel of Fortune spins, per energy type, of an account by the account number. 

   

  This field requires the `Authorization` header to be set. 

  """
  wheelOfFortuneSpins("The account number for which the available spins are gathered." accountNumber: String!): AvailableSpinsType!

  """
   Retrieve the segments to be displayed on the Wheel of Fortune. 

   

  This field requires the `Authorization` header to be set. 

  """
  wheelOfFortuneSegments: WheelSegmentsType!

  """
  Get contribution schemes.
  """
  contributionSchemes: [ContributionSchemeType]

  """
  Get the Loyalty Point ledger entries for the passed user.
  """
  loyaltyPointLedgers: [LoyaltyPointLedgerEntryType]

  """
  Get the Ink conversation for a given account.
  """
  inkConversation("The account number." accountNumber: String, "The conversation's relay id." conversationRelayId: String): InkConversation!

  """
  Get the content for a given message.
  """
  inkMessage("The message's relay id." messageRelayId: String!): InkMessage!

  """
  Get the status of a background task.
  """
  taskResult(taskId: String!, accountNumber: String!): TaskResult

  """
   A property with the given ID. Usually associated with supply points. 

   

  This field requires the `Authorization` header to be set. 

  """
  property(id: ID!): PropertyType

  """
  Search for properties that are already in Kraken and match the search term.
  """
  propertiesSearch("The search term. It can be an address or a meter point identifier." searchTerm: String!): [PropertySearchResult!]!

  """
  Search for properties that are already in Kraken and match the search term.
  """
  propertySearch("The search term. It can be an address or a meter point identifier." searchTerm: String!): [PropertyType] @deprecated(reason: "The 'propertySearch' field is deprecated.\n\nThis query is being deprecated in favour of `propertiesSearch`. The latter returns not only the matched properties but the level of confidence in the results through the `score` field.\n\n- Marked as deprecated on 2023-05-23.\n- Will be removed on 2024-01-01.")

  """
  Get all loyalty cards for the given account user.
  """
  loyaltyCards("Account user id." accountUserId: String!): [LoyaltyCardType]

  """
  Get print batch details, including messages in the batch.
  """
  printBatch("The print batch ID." printBatchId: Int @deprecated(reason: "The 'printBatchId' field is deprecated.\n\n\nPlease use 'batchId' instead.\n\n\n- Marked as deprecated on 2023-08-30.\n- Will be removed on 2024-08-30."), "The print batch ID." batchId: ID): PrintBatchType!

  """
  Get details about an embedded network.
  """
  embeddedNetwork(id: ID!): EmbeddedNetworkType

  """
  Link object for an affiliate organization.
  """
  affiliateLink("The affiliate link subdomain." subdomain: String!): AffiliateLinkType!

  """
  Return the details of a given affiliate organization, if any exists.
  """
  affiliateOrganisation("The affiliate organisation ID." id: Int!): AffiliateOrganisationType

  """
  Return the current active referral reward scheme of a given affiliate organisation, if any exists.
  """
  activeAffiliateReferralScheme("The affiliate link subdomain." subdomain: String!): ReferralSchemeType

  """
  The current version of kraken.
  """
  krakenVersion: KrakenVersionType

  """
  Get the active terms and conditions for a product.
  """
  termsAndConditionsForProduct(productCode: String!): TermsAndConditionsType

  """
  Return a signup referral reward scheme with the given code, if it's active.
  """
  domesticSignupRewardScheme("Reward code for the scheme." code: String!): ReferralSchemeType

  """
  Return a joining reward scheme with the given code, if it's active. A joining reward can be a signup reward or a promotional reward.
  """
  domesticJoiningRewardScheme("Reward code for the scheme." code: String!): ReferralSchemeType

  """
  Return a referral reward scheme for the given account referral code.
  """
  domesticAccountReferralRewardScheme("Friend referral code." code: String!): ReferralSchemeType

  """
  Return the current active signup referral reward scheme with the given code, if any exists.
  """
  activeDomesticSignupRewardScheme: ReferralSchemeType

  """
  Information about rate limit for viewer.
  """
  rateLimit: RateLimitInformation

  """
  Get the complexity of a query.
  """
  queryComplexity("Query and relevant variables required to calculate the complexity." input: QueryComplexityInputType!): QueryComplexityOutputType

  """
  Get deposit agreements for a given account.
  """
  depositAgreements(accountNumber: String!): [DepositAgreementOutput]

  """
  Get the default payment instruction for the account's main ledger.
  """
  defaultPaymentInstruction("The account number." accountNumber: String!, "Provide an option to get either a CARD or DIRECT_DEBIT instruction." instructionType: PaymentType): PaymentInstructionType

  smartMeterDataPreferences(accountNumber: String!): SmartMeterDataPreferencesType

  """
  Retrieve smartmeter devices connected to the same Home Area Network.
  """
  smartDeviceNetwork("The deviceId of one of the devices on the Home Area Network." deviceId: String!): SmartMeterDeviceNetworkType

  """
  Query telemetry data collected by the CAD associated with the provided
  ESME or GSME device ID.

  If only the smart meter device ID is provided, the latest data
  available will be returned.

  Additionally including the range options (start, end, and grouping) will
  return the data for that time period, at the desired granularity.
  """
  smartMeterTelemetry("The ESME or GSME's EUI64 ID, e.g. '12-34-5A-FF-FF-6B-C7-89'" deviceId: String!, "The start time of the range of readings (inclusive), e.g. '2022-01-28T16:33:22+00:00'. If no UTC timezone offset is included, UTC (+00:00) will be assumed." start: DateTime, "The end time of the range of readings (exclusive), e.g. '2022-01-28T16:34:42+00:00'. If no UTC timezone offset is included, UTC (+00:00) will be assumed." end: DateTime, "The granularity of the returned data. The representative data item (e.g. consumption) for each group (e.g. every 5 minutes) will be the mean value over that period." grouping: TelemetryGrouping): [SmartMeterTelemetryType]

  """
  Retrieve a snapshot of a prepay device balance at a moment in time.
  """
  prepayBalanceSnapshot("The ESME or GSME's EUI64 ID, e.g. '12-34-5A-FF-FF-6B-C7-89'." deviceId: String!): PrepayBalanceSnapshotType

  """
  Links (urls) for the affiliate organizations.
  """
  affiliateLinks("Email address of the affiliate agent." agentContactEmail: String!): [AffiliateLinkType!]!

  """
   The currently authenticated third party. 

   

  This field requires the `Authorization` header to be set. 

  """
  thirdPartyViewer: ThirdPartyOrganizationType

  """
  Get account status information given its number.
  """
  accountStatusSearchByNumber("The account number to search for." accountNumber: String!): AccountWithStatusInfoType

  """
  Verify eligibility for a smart product.
  """
  smartProductEligibility("Product code of the smart product to verify eligibility for." productCode: String!, "Vehicle to verify eligibility for." vehicle: VehicleEligibilityInputType!): SmartProductEligibilityType

  """
  Get siteworks booking information for an account given its number.
  """
  siteworksBookingAccountSearchByNumber("The account number to search for." accountNumber: String!): SiteworksBookingAccountType

  """
  Get siteworks booking information for an account given an MPAN.
  """
  siteworksBookingAccountSearchByMpan("The MPAN to search for." mpan: String!): SiteworksBookingAccountType

  """
  Get siteworks booking information for an account given an MPRN.
  """
  siteworksBookingAccountSearchByMprn("The MPRN to search for." mprn: String!): SiteworksBookingAccountType

  """
  Get siteworks booking information for accounts at a given postcode.
  """
  siteworksBookingAccountSearchByPostcode("The postcode to search for." postcode: String!, "Filter the accounts by status." statuses: [AccountStatusChoices], before: String, after: String, first: Int, last: Int): SiteworksBookingAccountConnectionTypeConnection

  """
  Siteworks appointments for the provided postcode.
  """
  siteworksAppointments(postcode: String!, "Filter the Siteworks appointments by status." statuses: [SiteworksAppointmentStatus]!, before: String, after: String, first: Int, last: Int): SiteworksAppointmentConnectionTypeConnection

  """
  Siteworks appointments for the provided postcode.
  """
  externalSiteworksAppointments(postcode: String!, "Filter the Siteworks appointments by status." statuses: [SiteworksAppointmentStatus]!, before: String, after: String, first: Int, last: Int): SiteworksAppointmentConnectionTypeConnection

  """
  Likelihood that a smart meter at the given postcode will get a stable network connection.
  """
  wanCoverage(postcode: String!): WANCoverageStrengths

  """
  Detailed WAN coverage report for a given post code and optional address identifier
  """
  wanCoverageDetail(postcode: String!, addressIdentifier: String): [WanCoverageDetail]

  """
  Returns set of available siteworks appointment slots for the given property.
  """
  siteworksAppointmentSlots(propertyId: ID!, calculationId: String, fromDate: Date, agentReference: String, slotDuration: SlotDuration): SiteworksAppointmentSlotsType

  """
  Setting to determine delay in first poll when fetching async timeslots (in ms).
  """
  siteworksCoconutAppointmentPollDelay: Int

  """
  Setting to determine interval when fetching async timeslots (in ms).
  """
  siteworksCoconutAppointmentPollInterval: Int

  """
  Setting to determine how many times at most to fetch async timeslots.
  """
  siteworksCoconutAppointmentPollMaxCount: Int

  """
  If a quote code and product id are supplied, this returns that quote. Otherwise it returns an empty quote. This is a convenient way to expose both existing quotes, as well as the OFGEM consumption profiles are creating a quote.
  """
  quote(code: String): QuoteType

  """
  Consumption estimates based on ofgem statistics.
  """
  consumptionEstimates: ConsumptionEstimates

  """
   Fetch electricity meter readings for a given account and meter 

   

  This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

   

   

  This field requires the `Authorization` header to be set. 

  """
  electricityMeterReadings(accountNumber: String!, meterId: String!, eventTypes: [MeterReadingEventType], before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection

  """
   Fetch gas meter readings for a given account and meter 

   

  This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

   

   

  This field requires the `Authorization` header to be set. 

  """
  gasMeterReadings(accountNumber: String!, meterId: String!, eventTypes: [MeterReadingEventType], before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection

  """
  Get the auto top-up configs for a device. Ordered by effective from date, latest first.
  """
  autoTopupConfigs("Target device ID, e.g. 'A1-BC-D2-00-01-23-EF-4G'." deviceId: String!, "Target account number, e.g. 'A-A1B2C3D4'." accountNumber: String!, "The datetime from which the auto top-up is effective, e.g. '2024-01-01T00:00:00+00:00'." effectiveFrom: DateTime, before: String, after: String, first: Int, last: Int): AutoTopupConfigConnectionTypeConnection

  """
  Get auto top-up trigger events for an auto topup config. Ordered by triggered_at datetime, latest first.
  """
  autoTopupTriggers("Target auto top-up config ID, e.g. '123'." autoTopupConfigId: ID!, "Filter by datetime (inclusive) from which trigger events have occurred, e.g. '2024-01-01T00:00:00+00:00'." triggersFrom: DateTime, "Filter by status of the auto top-up trigger event." status: SmartDeviceAutoTopupTriggerStatus, "Filter by source of the auto top-up trigger event." source: SmartDeviceAutoTopupTriggerSources, "Filter by failure reason of the auto top-up trigger event." failureReason: SmartDeviceAutoTopupTriggerFailureReasons, before: String, after: String, first: Int, last: Int): AutoTopupTriggerConnectionTypeConnection

  node("The ID of the object" id: ID!): Node

  """
  Looks up an occupier account based on postcode and last 4 digits of the account number
  """
  occupierAccount(postcode: String!, shortcode: String!): OccupierAccount

  """
  The properties attached to the given account.

  This field requires the `Authorization` header to be set. 

  """
  properties(accountNumber: String!, active: Boolean): [PropertyType]

  addresses(postcode: String!, searchDomesticOnly: Boolean, useDes: Boolean, dataSource: DataSource, before: String, after: String, first: Int, last: Int): AddressConnectionTypeConnection

  multipleElectricityMeterPointsForAddress(address: AddressSearchType, searchDomesticOnly: Boolean, useDes: Boolean): ElectricityMeterPointForAddressType

  """
  Cost of usage recorded by the meter.
  """
  costOfUsage("Account number." accountNumber: String, "The electricity or gas meter ID." meterId: String, "The energy type, i.e. ELECTRICITY or GAS." fuelType: FuelType, "Datetime the data should be queried from." startAt: DateTime, "Aggregate cost according to this grouping." grouping: ConsumptionGroupings!, "Timezone to use for grouping." timezone: String): CostOfUsageType

  """
  Get mobile screen details to render.
  """
  backendScreen("The ID of the screen to return." screenId: ID!, "List of key-value pairs (strings) to pass as parameters to the screen." params: [BackendScreenParamInputType], "The maximum version of backend screens supported by the client." maxVersionSupported: Int = 1): BackendScreenType

  """
  Get a dashboard screen to render in the form of a json list of sections containing cards or grouped cards each with an order attribute.
  """
  dashboardScreen("The ID of the dashboard type screen to return." dashboardId: ID!, "The account number of the user." accountNumber: String!, "The maximum version of dahshboard type screens supported by the client." maxVersionSupported: Int! = 1, "The ledger id associated to the account." ledgerId: String, "The property id associated to the account." propertyId: String, "List of key-value pairs (strings) to pass as parameters to the screen." params: [BackendScreenParamInputType]): Dashboard

  """
  Get all registered backend screen IDs.
  """
  backendScreenIds: [String]

  """
  Get all registered backend screen event IDs.
  """
  backendScreenEventIds: [String]

  """
  Metadata for a linked object.
  """
  metadata(linkedObjectType: LinkedObjectType, identifier: String!): [Metadata]

  """
  Metadata for a linked object with key.
  """
  metadataForKey(linkedObjectType: LinkedObjectType, identifier: String!, key: String!): Metadata

  """
  Details associated with a LeaveSupplier process.
  """
  leaveSupplierProcess("The property ID." leaveSupplierProcessId: ID!): LeaveSupplierProcessType

  """
  Get all lifecycle processes associated with an account.
  """
  lifecycleProcesses("A flag to filter out only active\/current processes." onlyActive: Boolean, "The account number, e.g. A-12345678." accountNumber: String!): LifecycleProcessesType

  """
  List quotes given an account number or retrieve a Goods quote given a quote code.
  """
  goodsQuotes("The account number." accountNumber: String, "The quote code." quoteCode: String): [GoodsQuote]

  """
  List Goods products given a market.
  """
  goodsProducts("Market name of the products to list." marketName: String!, "Types of the products to filter by." productType: [String], "Code of the products to filter by." code: [String], before: String, after: String, first: Int, last: Int): GoodsProductConnectionTypeConnection

  """
  List purchases for an account.
  """
  goodsPurchases("The account number." accountNumber: String!): [GoodsPurchase]

  """
  The current energy generation mix.
  """
  energyMixData: EnergyMixDataType

  """
  Get the customer feedback survey question.
  """
  question(formId: Int!): String

  """
  Get default raw score for a customer feedback form.
  """
  defaultRawScore(formId: Int!): Int

  """
  Get a connection containing API Exceptions.
  """
  apiExceptions("Fields to filter for. Otherwise don't filter at all." input: APIExceptionQueryInput, before: String, after: String, first: Int, last: Int): APIExceptionConnectionTypeConnection

  """
  Check validity of a password reset token.
  """
  isPasswordResetTokenValid("Base64 encoded user id." userId: String!, "Password reset token to check." token: String!): Boolean

  """
  The help text of all configured password validators as plain-text or html. Defaults to plain-text.
  """
  passwordValidatorHelpTexts("Return the results as html instead of plain-text. Defaults to False." asHtml: Boolean = false): [String]

  """
  List of matching account references.
  """
  accountReference(value: String): [AccountReferenceType]

  """
   The currently authenticated user. 

   

  This field requires the `Authorization` header to be set. 

  """
  viewer: AccountUserType

  """
  Available reasons for use in account credit mutations.
  """
  accountCreditReasons: [CreditReasonType]

  """
  Available reasons for use in account charge mutations.
  """
  accountChargeReasons: [ChargeReasonType]

  """
  Get details about an account.
  """
  account(accountNumber: String!): AccountType

  """
  Get details about multiple accounts.
  """
  accounts("A phone number to find accounts associated with." phoneNumber: String, "A portfolio number to find accounts associated with." portfolioNumber: String): [AccountType]

  """
  Search for account that are already in Kraken and match the search terms.
  """
  accountsSearch("Search operators." searchTerms: AccountSearchInputType, "The maximum number of results to return." maxResults: Int = 20): [AccountSearchItemType]
}

"""
Dovetailing rates applicable for an account / meter point combination over a given time period.
"""
type ApplicableRateConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [ApplicableRateConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `ApplicableRateConnectionType` and its cursor.
"""
type ApplicableRateConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: ApplicableRate

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type ApplicableRate {
  value: Decimal

  validFrom: DateTime

  validTo: DateTime
}

type QuoteRequest {
  """
  List of electricity supply points and their quoted products.
  """
  electricitySupplyPoints: [ElectricitySupplyPoint]

  """
  List of gas supply points and their quoted products.
  """
  gasSupplyPoints: [GasSupplyPoint]

  createdAt: DateTime

  """
  The code of the created quote.
  """
  code: String!
}

type ElectricitySupplyPoint {
  """
  The Mpan of the suply point.
  """
  mpan: String

  """
  Current active agreement on this supply point.
  """
  agreement: ElectricityAgreementType

  """
  Annual consumption of the supply point. The type of ElectricityConsumption depends on the rateType.
  """
  annualConsumption: ElectricityConsumption!

  """
  A list of quoted products and the corresponding tariff information.
  """
  quotedProducts: [ElectricityQuotedProduct]!

  """
  Rate type.
  """
  rateType: RateTypeChoices!
}

union ElectricityConsumption = ElectricityConsumptionStandard|ElectricityConsumptionLabelEco7|ElectricityConsumptionThreeRate

type ElectricityConsumptionStandard {
  consumption: Int

  isEstimate: Boolean
}

type ElectricityConsumptionLabelEco7 {
  day: Int

  night: Int

  isEstimate: Boolean
}

type ElectricityConsumptionThreeRate {
  day: Int

  night: Int

  offPeak: Int

  isEstimate: Boolean
}

type ElectricityQuotedProduct {
  """
  The ID of the quoted product.
  """
  id: Int

  label: String

  """
  Energy product quoted.
  """
  product: EnergyProductType!

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int!

  """
  Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.  The type of ElectricityProductTariffInformationLabel depends on the rateType of the ElectricitySupplyPoint.
  """
  electricityTariffInformationLabel: ElectricityProductTariffInformationLabel!
}

"""
An EnergyProduct models a group of tariffs for both electricity and gas.
"""
type EnergyProductType {
  id: ID!

  fullName: String!

  """
  This name will be shown to customers during sign-up
  """
  displayName: String!

  """
  This will be shown to customers during sign-up
  """
  description: String!

  availableFrom: DateTime!

  availableTo: DateTime

  """
  Whether to hide this product from the direct registration journey
  """
  isHidden: Boolean!

  code: String!

  """
  Whether the product is an import or export product.
  """
  direction: EnergyProductDirection

  """
  These are internal notes to explain why this product exists
  """
  notes: String!

  isVariable: Boolean!

  isGreen: Boolean!

  isBusiness: Boolean!

  isChargedHalfHourly: Boolean!

  isPrepay: Boolean!

  isDefault: Boolean

  isOccupier: Boolean

  """
  Duration of agreements using this product in months
  """
  term: Int

  """
  A list of tariffs per product for a given postcode.
  """
  tariffs(postcode: String!, "Optional parameter to filter for a tariff's unit rates with a specific payment method." paymentMethod: PaymentMethodChoices = DIRECT_DEBIT, before: String, after: String, first: Int, last: Int): EnergyTariffConnectionTypeConnection

  isAvailable: Boolean

  isUnavailable: Boolean

  isFixed: Boolean

  isDomestic: Boolean

  """
  Does the product have EPG applied on the unit rates.
  """
  includesEpgReduction: Boolean

  """
  The exit fee applied per fuel if the agreement is ended early. Total value is determined by exit fee type, i.e. this value is either a flat cost or cost per year/month remaining on the agreement.
  """
  exitFees: Int

  """
  Determines how the exit fee is calculated.
  """
  exitFeesType: String

  """
  Tags associated with the product.
  """
  tags: [String]
}

enum EnergyProductDirection {
  IMPORT

  EXPORT
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type EnergyTariffConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [EnergyTariffConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `EnergyTariffConnectionType` and its cursor.
"""
type EnergyTariffConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: EnergyTariffType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

union EnergyTariffType = StandardTariff|DayNightTariff|ThreeRateTariff|GasTariffType

enum PaymentMethodChoices {
  DIRECT_DEBIT

  NON_DIRECT_DEBIT

  PREPAYMENT
}

union ElectricityProductTariffInformationLabel = ProductTariffInformationLabelStandard|ProductTariffInformationLabelEco7|ProductTariffInformationThreeRate

type ProductTariffInformationLabelStandard {
  supplier: String!

  tariffFullName: String!

  tariffDisplayName: String!

  tariffType: String!

  tariffCode: String!

  tariffEndsOn: String!

  paymentMethod: PaymentMethods!

  priceGuaranteedUntil: String!

  exitFees: Int

  exitFeesType: String

  additionals: String

  tariffComparisonRate: Decimal

  estimatedAnnualCost: Int

  annualStandingCharge: Decimal!

  standingCharge: Decimal!

  unitRate: Decimal!

  assumedAnnualConsumption: Int!
}

"""
An enumeration.
"""
enum PaymentMethods {
  DIRECT_DEBIT

  CREDIT_CARD

  PAY_ON_RECEIPT
}

type ProductTariffInformationLabelEco7 {
  supplier: String!

  tariffFullName: String!

  tariffDisplayName: String!

  tariffType: String!

  tariffCode: String!

  tariffEndsOn: String!

  paymentMethod: PaymentMethods!

  priceGuaranteedUntil: String!

  exitFees: Int

  exitFeesType: String

  additionals: String

  tariffComparisonRate: Decimal

  estimatedAnnualCost: Int

  annualStandingCharge: Decimal!

  standingCharge: Decimal!

  unitRateDay: Decimal!

  unitRateNight: Decimal!

  assumedAnnualConsumptionDay: Int!

  assumedAnnualConsumptionNight: Int!

  """
  Some tariffs expect customers to alter their usage patterns (e.g. EV tariffs) so will redistribute total consumption accordingly.
  """
  consumptionDistributionCoefficients: ConsumptionDistributionCoefficients
}

type ConsumptionDistributionCoefficients {
  day: Decimal!

  night: Decimal!
}

type ProductTariffInformationThreeRate {
  supplier: String!

  tariffFullName: String!

  tariffDisplayName: String!

  tariffType: String!

  tariffCode: String!

  tariffEndsOn: String!

  paymentMethod: PaymentMethods!

  priceGuaranteedUntil: String!

  exitFees: Int

  exitFeesType: String

  additionals: String

  tariffComparisonRate: Decimal

  estimatedAnnualCost: Int

  annualStandingCharge: Decimal!

  standingCharge: Decimal!

  unitRateDay: Decimal!

  unitRateNight: Decimal!

  unitRateOffPeak: Decimal!

  assumedAnnualConsumptionDay: Int!

  assumedAnnualConsumptionNight: Int!

  assumedAnnualConsumptionOffPeak: Int!
}

"""
An enumeration.
"""
enum RateTypeChoices {
  """
  Standard.
  """
  STANDARD

  """
  Economy7.
  """
  ECONOMY7

  """
  Three-rate.
  """
  THREE_RATE
}

type GasSupplyPoint {
  """
  The Mprn of the suply point.
  """
  mprn: String

  """
  Current active agreement on this supply point.
  """
  agreement: GasAgreementType

  """
  Annual consumption of the supply point
  """
  annualConsumption: GasConsumption!

  """
  A list of quoted products and the corresponding tariff information.
  """
  quotedProducts: [GasQuotedProduct]!

  """
  Gas has only STANDARD rate type.
  """
  rateType: String!
}

type GasConsumption {
  consumption: Int

  isEstimate: Boolean
}

type GasQuotedProduct {
  """
  The ID of the quoted product.
  """
  id: Int

  label: String

  """
  Energy product quoted.
  """
  product: EnergyProductType!

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int!

  """
  Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  gasTariffInformationLabel: ProductTariffInformationLabelStandard!
}

type FollowOnProductType {
  activeFrom: DateTime!

  activeTo: DateTime

  """
  The type of account.
  """
  accountType: AccountTypeChoices

  """
  The payment method for the product.
  """
  paymentMethod: PaymentMethods

  renewalProducts: [RenewalProductType]

  createdAt: DateTime!
}

type RenewalProductType {
  slug: String!

  product: EnergyProductType
}

type MPxNProductType {
  """
  Identifier for meter point.
  """
  mpxn: String!

  """
  List of available products for the meter point.
  """
  products: [EnergyProductType]
}

type ProductEligibilityForMeterPoint {
  """
  Whether meter point is eligible for product enrolment.
  """
  isEligible: Boolean!
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type EnergyProductConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [EnergyProductConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `EnergyProductConnectionType` and its cursor.
"""
type EnergyProductConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: EnergyProductType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

enum EnergyProductAvailability {
  AVAILABLE

  UNAVAILABLE
}

"""
An enumeration.
"""
enum EnergyProductFilters {
  """
  Display our prepayment products.
  """
  PREPAY

  """
  Display our business products.
  """
  BUSINESS

  """
  Display our domestic products.
  """
  DOMESTIC

  """
  Display our variable-term products.
  """
  VARIABLE

  """
  Display our fixed-term products.
  """
  FIXED

  """
  Display our smart (charged half-hourly) products.
  """
  SMART

  """
  Display our greenest products.
  """
  GREEN
}

type PrepayPaymentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [PrepayPaymentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `PrepayPaymentConnectionType` and its cursor.
"""
type PrepayPaymentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: PrepayPaymentType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type ProductEnrolmentType {
  id: ID!

  account: AccountType!

  status: EnrolmentStatus!

  """
  The product associated with the enrolment.
  """
  product: EnergyProductType

  """
  The electricity meter point associated with the enrolment.
  """
  electricityMeterPoint: ElectricityMeterPointType

  """
  The gas meter point associated with the enrolment.
  """
  gasMeterPoint: GasMeterPointType

  """
  The stages that are part of the enrolment.
  """
  stages: [ProductEnrolmentStageType]
}

"""
An enumeration.
"""
enum EnrolmentStatus {
  """
  Not started
  """
  NOT_STARTED

  """
  In progress
  """
  IN_PROGRESS

  """
  Completed
  """
  COMPLETED

  """
  Cancelled
  """
  CANCELLED

  """
  Failed
  """
  FAILED

  """
  Errored
  """
  ERRORED
}

type ProductEnrolmentStageType {
  """
  The name of the stage.
  """
  name: String

  """
  The current status of the stage.
  """
  status: EnrolmentStepStatus

  """
  The steps that are part of the enrolment stage.
  """
  steps: [ProductEnrolmentStepType]
}

"""
An enumeration.
"""
enum EnrolmentStepStatus {
  SKIPPED

  COMPLETED

  PENDING

  IN_PROGRESS

  STALLED

  CANCELLED

  FAILED

  ERRORED
}

type ProductEnrolmentStepType {
  """
  The name of the step.
  """
  displayName: String

  """
  The current status of the step.
  """
  status: EnrolmentStepStatus

  """
  The date time that the step was last updated.
  """
  updatedAt: DateTime
}

type ValidateBankAccount {
  bankName: String

  branch: String

  county: String

  line1: String

  line2: String

  line3: String

  line4: String

  town: String

  postcode: String
}

enum PaymentsVendorChoices {
  SMARTDEBIT

  GOCARDLESS

  STRIPE

  WESTPAC

  BOTTOMLINE_PTX
}

type EarliestPossibleDirectDebitPaymentDate {
  earliestPossibleDirectDebitPaymentDate: Date
}

type SmartMeterDataPreferencesType {
  """
  The reading frequency for the smart meter.
  """
  readingFrequency: SmartMeterReadingFrequencyChoices

  """
  Has the user given consent that their readings can be used for further analysis?
  """
  readingsAnalysisConsentProvided: Boolean

  """
  The datetime when the user gave consent that their readings can be used for further analysis.
  """
  readingsAnalysisConsentUpdatedDatetime: DateTime
}

"""
    Meter reading frequency choices for smart meters.

    Please note: these labels are exposed in the API documentation.
    
"""
enum SmartMeterReadingFrequencyChoices {
  """
  Daily
  """
  DAILY

  """
  Monthly
  """
  MONTHLY

  """
  Half hourly
  """
  HALF_HOURLY
}

type SmartMeterTelemetryType {
  """
  The start_at time of the telemetry data. E.g if querying in 30 minute intervals the reading may have been taken anywhere between 00:00:00 and 00:29:59 and represents the maximum reading taken in the time period.
  """
  readAt: DateTime

  """
  Total energy consumed by the meter measured in Wh.
  """
  consumption: Decimal

  """
  Energy being demanded by the meter measured in W.
  """
  demand: Decimal

  """
  Energy consumption in Wh between the read_at and the next reading.
  """
  consumptionDelta: Decimal

  """
  Energy cost for the consumption delta in pence.
  """
  costDelta: Decimal

  """
  Energy cost including VAT for the consumption delta in pence.
  """
  costDeltaWithTax: Decimal
}

enum TelemetryGrouping {
  TEN_SECONDS

  ONE_MINUTE

  FIVE_MINUTES

  HALF_HOURLY

  HOURLY
}

"""
A snapshot of a prepay meter's credit and debt balance at a given point in time.
"""
type PrepayBalanceSnapshotType {
  creditInPence: Int!

  debtInPence: Int!

  emergencyCreditInPence: Int

  asAt: DateTime!
}

"""
Type for the third party organization.
"""
type ThirdPartyOrganizationType {
  name: String!
}

"""
An object holding a subset of account.
"""
type AccountWithStatusInfoType {
  number: String!

  """
  The current status of the account.
  """
  status: AccountStatus

  """
  Properties linked to the account now and in the future
  """
  properties("Returns properties that have an effective period that ends at or after the given activeFrom datetime." activeFrom: DateTime): [PropertyType]

  """
  The current balance of the account.
  """
  balance: Int

  """
  The active payment method for the account.
  """
  activePaymentMethod: String
}

"""
Verify whether vehicle is eligibile for smart product.
"""
type SmartProductEligibilityType {
  """
  Whether vehicle is eligibile for smart product.
  """
  isEligible: Boolean
}

input VehicleEligibilityInputType {
  """
  Registration number of a car.
  """
  registrationNumber: String
}

"""
An object holding information about an account and its associated users, properties and meter points, used for administering siteworks bookings.
"""
type SiteworksBookingAccountType {
  number: String!

  """
  The current status of the account.
  """
  status: AccountStatus

  users: [AccountUserType!]!

  """
  Name for this account. If one exists, the billing name of the portfolio will prepend this.
  """
  billingName: String!

  accountType: String!

  """
  Properties linked to the account now and in the future.
  """
  properties: [SiteworksBookingPropertyType]

  """
  Siteworks requests associated to an account.
  """
  siteworksRequests: [SiteworksRequestType]

  """
  Active campaigns for the account.
  """
  activeCampaigns: [SiteworksCampaignType]

  """
  The interest of an account in procuring smart meters.
  """
  smets2Interest: SmartMeterInterestChoices

  """
  The brand of the account.
  """
  brand: String!
}

"""
This type is used by partner organisations to retrieve information about a property and its meter points that is used to book siteworks.
"""
type SiteworksBookingPropertyType {
  id: ID!

  postcode: String!

  """
  Retrieve any smartmeter devices connected to the property.
  """
  smartDeviceNetworks: [SmartMeterDeviceNetworkType]

  isChangeOfTenancyOngoing: Boolean

  """
  Indicates if the property meets smart meter install preconditions.
  """
  isSmets2InstallationAllowed: Boolean

  """
  Retrieve the details of an electricity meter-point.
  """
  electricityMeterPoints: [SiteworksBookingElectricityMeterPointType]

  """
  Retrieve the details of a gas meter-point.
  """
  gasMeterPoints: [SiteworksBookingGasMeterPointType]

  """
  List of address lines.
  """
  splitAddress: [String]
}

"""
This type holds information about an electricity meter point that is used by partner organisations to book siteworks.
"""
type SiteworksBookingElectricityMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!

  supplyEndDate: Date

  mpan: String!

  """
  Standard settlement configuration
  """
  ssc: String!

  energisationStatus: String!

  dccServiceFlag: String!

  status: String!

  isOnSupply: Boolean!

  """
  The latest supply period of the meterpoint.
  """
  latestSupplyPeriod: SupplyPeriodType

  """
  Whether this meter point has a meter which is due a reading.
  """
  isMeterReadingDue(maxReadingAge: Int): Boolean!

  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]

  """
  The distribution network the grid supply point falls under
  """
  gspGroupId: String

  """
  A list of agents responsible for management of the meterpoint.
  """
  agentContracts("Filter the contracts by status." statuses: [AgentContractStatusType]): [ElectricityAgentContractType]
}

"""
Interface for common fields for SiteworksBookingMeterpoints.
"""
interface SiteworksBookingMeterPointInterface {
  status: String!

  isOnSupply: Boolean!

  """
  The latest supply period of the meterpoint.
  """
  latestSupplyPeriod: SupplyPeriodType

  """
  Whether this meter point has a meter which is due a reading.
  """
  isMeterReadingDue(maxReadingAge: Int): Boolean!
}

type SupplyPeriodType {
  """
  The start date of the supply period.
  """
  supplyStartAt: DateTime

  """
  The end date of the supply period.
  """
  supplyEndAt: DateTime
}

"""
This type holds information about a gas meter point that is used by partner organisations to book siteworks.
"""
type SiteworksBookingGasMeterPointType implements SiteworksBookingMeterPointInterface {
  id: ID!

  supplyEndDate: Date

  mprn: String

  status: String!

  isOnSupply: Boolean!

  """
  The latest supply period of the meterpoint.
  """
  latestSupplyPeriod: SupplyPeriodType

  """
  Whether this meter point has a meter which is due a reading.
  """
  isMeterReadingDue(maxReadingAge: Int): Boolean!

  meters(id: Int, includeInactive: Boolean): [GasMeterType]

  """
  A list of agents responsible for management of the meterpoint.
  """
  agentContracts("Filter the contracts by status." statuses: [AgentContractStatusType]): [GasAgentContractType]
}

type SiteworksRequestType {
  """
  Siteworks appointments associated to a request.
  """
  appointments: [ActiveAppointmentType]
}

type ActiveAppointmentType {
  id: UUID!

  agent: SiteworksAppointmentAgent

  """
  The current status of the Siteworks application.
  """
  status: SiteworksAppointmentStatus

  appointmentDate: Date!

  timeSlotStart: Time

  timeSlotEnd: Time

  createdAt: DateTime!

  """
  The category of work the appointment has been booked for.
  """
  workCategory: WorkCategory

  date: Date

  requestId: String

  agentReference: String
}

"""
An enumeration.
"""
enum SiteworksAppointmentAgent {
  """
  Smart Metering Systems
  """
  SMS

  """
  AES Smart Metering
  """
  AES

  """
  Octopus Energy Services
  """
  OES

  """
  Providor Ltd
  """
  PROVIDOR

  """
  Morrison Data Services
  """
  MDS

  """
  E.on Metering
  """
  EON_METERING

  """
  Lowri Beck Services Ltd
  """
  LOWRI_BECK

  """
  MeterPlus
  """
  METERPLUS

  """
  Enterprise Managed Services Ltd
  """
  ENTERPRISE_MANAGED

  """
  Midlands Electricity plc
  """
  MIDS_ELEC

  """
  Northern Powergrid
  """
  N_POWERGRID

  """
  Electricity North West Limited
  """
  ELEC_NW

  """
  National Grid
  """
  NATIONAL_GRID

  """
  SGN Metering Services
  """
  SGN

  """
  Energy Assets Ltd
  """
  ENERGY_ASSETS

  """
  Siemens Metering Services
  """
  SIEMENS

  """
  EDF Energy Customers Ltd
  """
  LONDON

  """
  EDF Energy Customers PLC
  """
  ECM

  """
  Octopus Energy Services Ltd
  """
  OESL
}

"""
An enumeration.
"""
enum SiteworksAppointmentStatus {
  """
  The Siteworks appointment that has been booked.
  """
  BOOKED

  """
  The Siteworks work that has been completed.
  """
  COMPLETED

  """
  The Siteworks appointment that has been aborted.
  """
  ABORTED

  """
  The Siteworks appointment that has been cancelled.
  """
  CANCELLED
}

"""
    Categories of work that a Siteworks appointment is booked for.
    
"""
enum WorkCategory {
  """
  Exchange.
  """
  EXCHANGE

  """
  Move.
  """
  MOVE

  """
  New Connection.
  """
  NEW_CONNECTION

  """
  Remove.
  """
  REMOVE

  """
  Reinstall.
  """
  REINSTALL

  """
  Investigate Fault.
  """
  INVESTIGATE_FAULT

  """
  Ihd Install.
  """
  IHD_INSTALL

  """
  Commission.
  """
  COMMISSION

  """
  Comms Hub Power Cycle.
  """
  COMMS_HUB_POWER_CYCLE

  """
  Comms Hub Replacement.
  """
  COMMS_HUB_REPLACEMENT

  """
  Meter Tails Upgrade.
  """
  METER_TAILS_UPGRADE

  """
  Isolator Switch Install.
  """
  ISOLATOR_SWITCH_INSTALL

  """
  Accuracy Test.
  """
  ACCURACY_TEST

  """
  Bracket Installation.
  """
  BRACKET_INSTALLATION

  """
  Confirm Meter Details.
  """
  CONFIRM_METER_DETAILS

  """
  Replace Seals.
  """
  REPLACE_SEALS

  """
  Energise.
  """
  ENERGISE

  """
  De Energise.
  """
  DE_ENERGISE
}

type SiteworksCampaignType {
  name: String!

  slug: String!
}

type SiteworksBookingAccountConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [SiteworksBookingAccountConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `SiteworksBookingAccountConnectionType` and its cursor.
"""
type SiteworksBookingAccountConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: SiteworksBookingAccountType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
An enumeration.
"""
enum AccountStatusChoices {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """
  Account requires processes to be completed before supply can be set up
  """
  INCOMPLETE

  """
  Withdrawn before supply started
  """
  WITHDRAWN

  """
  Supply could have started, be ongoing or ended.
  """
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """
  Dormant. Users should not be able to log into dormant accounts.
  """
  DORMANT
}

type SiteworksAppointmentConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [SiteworksAppointmentConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `SiteworksAppointmentConnectionType` and its cursor.
"""
type SiteworksAppointmentConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: SiteworksAppointmentType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type SiteworksAppointmentType {
  activeAppointment: ActiveAppointmentType

  account: AccountType

  property: PropertyType
}

type WanCoverageDetail {
  postcode: String

  addressIdentifier: String

  isCoverageAvailable: Boolean

  anticipatedCoverageAt: String

  wanTechnology: String

  auxiliaryEquipment: String

  connectivityLikelihood: String

  additionalInformation: String
}

type SiteworksAppointmentSlotsType {
  calculationId: String

  slots: [SiteworksAppointmentSlotType]

  expectedJobDurationMinutes: Int
}

type SiteworksAppointmentSlotType {
  appointmentDate: Date

  startTime: Time

  endTime: Time

  agentReference: String

  siteId: String

  slotId: String

  calculationId: String

  promiseId: String
}

enum SlotDuration {
  TWO_HOUR

  AM_PM
}

type QuoteType {
  code: String

  postcode: String!

  gspGroupId: String

  includesElectricity: Boolean!

  includesGas: Boolean!

  isBusiness: Boolean!

  """
  The meter type for the quote.
  """
  meterType: MeterTypes

  mpan: String!

  paymentMethod: QuotePaymentMethod!

  """
  In kWh
  """
  elecAnnualConsumptionStandard: Int

  """
  In kWh
  """
  elecAnnualConsumptionDay: Int

  """
  In kWh
  """
  elecAnnualConsumptionNight: Int

  elecEstimate: Boolean!

  """
  In kWh
  """
  gasAnnualConsumption: Int

  gasEstimate: Boolean!

  partnerProductId: Int

  latitude: Float

  longitude: Float

  address: QuoteAddressType

  consumptionEstimates: ConsumptionEstimates

  """
  A list of the products that have been quoted for the usage provided at the time the quote was created.
  """
  quotedProducts(id: String): [QuotedProductType]

  termsAndConditions: TermsAndConditionsType

  mprn: String
}

"""
An enumeration.
"""
enum MeterTypes {
  NO_METER

  STANDARD

  ECONOMY7

  SMART

  SMART_ECONOMY7

  SMART_FLAT_ECONOMY7

  FLAT_ECONOMY7

  THREE_RATE

  FLAT_THREE_RATE

  OTHER
}

"""
An enumeration.
"""
enum QuotePaymentMethod {
  """
  Direct Debit
  """
  DIRECTDEBIT

  """
  Credit card
  """
  CREDITCARD

  """
  Pay on receipt of bill
  """
  ONRECEIPT

  """
  Prepayment
  """
  PREPAYMENT
}

type QuoteAddressType {
  addressLine1: String

  addressLine2: String

  addressLine3: String
}

type ConsumptionEstimates {
  low: ConsumptionEstimate

  medium: ConsumptionEstimate

  high: ConsumptionEstimate
}

type ConsumptionEstimate {
  elecAnnualConsumptionStandard: Int

  elecAnnualConsumptionDay: Int

  elecAnnualConsumptionNight: Int

  gasAnnualConsumption: Int
}

type QuotedProductType {
  id: ID!

  name: String!

  description: String!

  product: EnergyProductType

  recommended: Boolean!

  """
  Estimated cost in pence of the product per month based on the quoted usage.
  """
  monthlyAmount: Int

  """
  Estimated cost in pence of the product over a year based on the quoted usage. 
  """
  annualAmount: Int

  """
  Estimated saving in pence vs the 'Big 6' of the product over a year based on the quoted usage.
  """
  annualSaving: Int

  elecTariffCode: String!

  gasTariffCode: String!

  """
  Electricity tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  electricityTariffInformationLabel: TariffInformationLabelType

  """
  Gas tariff information label (TIL) provides standardised information between suppliers about a tariff.
  """
  gasTariffInformationLabel: TariffInformationLabelStandard

  """
  Whether or not this is a variable product.
  """
  isVariable: Boolean

  """
  A list of dates allowable to start supply of the quoted product.
  """
  allowedSupplyStartDates: [Date]

  """
  The amount of co2 saved per year when this product is chosen
  """
  co2SavingInKg: Int

  """
  The number of trees it would take to offset the amount of co2 that is saved per year when this product is chosen
  """
  treesSaving: Int

  includesCarbonOffsetting: Boolean
}

union TariffInformationLabelType = TariffInformationLabelStandard|TariffInformationLabelEco7|TariffInformationLabelThreeRate

type TariffInformationLabelStandard {
  supplier: String

  tariffName: String

  tariffType: String

  tariffCode: String

  paymentMethod: String

  tariffEndsOn: String

  priceGuaranteedUntil: String

  exitFees: Int

  exitFeesType: String

  additionals: String

  tariffComparisonRate: Float

  standingCharge: Float

  estimatedAnnualCost: Int

  annualStandingCharge: Float

  unitRate: Float

  assumedAnnualConsumption: Int
}

type TariffInformationLabelEco7 {
  supplier: String

  tariffName: String

  tariffType: String

  tariffCode: String

  paymentMethod: String

  tariffEndsOn: String

  priceGuaranteedUntil: String

  exitFees: Int

  exitFeesType: String

  additionals: String

  tariffComparisonRate: Float

  standingCharge: Float

  estimatedAnnualCost: Int

  annualStandingCharge: Float

  unitRateDay: Float

  unitRateNight: Float

  assumedAnnualConsumptionDay: Int

  assumedAnnualConsumptionNight: Int
}

type TariffInformationLabelThreeRate {
  supplier: String

  tariffName: String

  tariffType: String

  tariffCode: String

  paymentMethod: String

  tariffEndsOn: String

  priceGuaranteedUntil: String

  exitFees: Int

  exitFeesType: String

  additionals: String

  tariffComparisonRate: Float

  standingCharge: Float

  estimatedAnnualCost: Int

  annualStandingCharge: Float

  unitRateDay: Float

  unitRateNight: Float

  unitRateOffPeak: Float

  assumedAnnualConsumptionDay: Int

  assumedAnnualConsumptionNight: Int

  assumedAnnualConsumptionOffPeak: Int
}

"""
Represents groupings of meter reading events Meter readings can be filtered by these event types.
"""
enum MeterReadingEventType {
  CUSTOMER

  SMART_METER

  ESTIMATE

  CHANGE_OF_SUPPLY

  METER_EXCHANGE

  PREPAY

  PRE_SUPPLIER

  DATA_COLLECTOR
}

"""
GraphQL output type for querying nodes of auto top-up configs.

Using this class instead of AutoTopupConfigType directly allows for pagination.
"""
type AutoTopupConfigConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AutoTopupConfigConnectionTypeEdge]!
}

"""
A Relay edge containing a `AutoTopupConfigConnectionType` and its cursor.
"""
type AutoTopupConfigConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AutoTopupConfigType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
GraphQL output type for querying auto top-up configs.
"""
type AutoTopupConfigType {
  id: ID!

  """
  The account number, e.g.: 'A-A1B2C3D4'.
  """
  accountNumber: String!

  """
  Alphanumber code identifying the device, e.g.: 'A1-BC-D2-00-01-23-EF-4G'.
  """
  deviceId: String!

  """
  Auto top-up amount in the lowest currency unit. i.e. USA cents / GBP pence / etc.
  """
  topupAmount: Int!

  """
  The date and time when the config became effective.
  """
  effectiveFrom: DateTime!

  """
  The date and time when the config stopped being effective.
  """
  effectiveTo: DateTime
}

"""
GraphQL output type for querying nodes of auto top-up trigger events.

Using this class instead of AutoTopupTriggerType directly allows for pagination.
"""
type AutoTopupTriggerConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AutoTopupTriggerConnectionTypeEdge]!
}

"""
A Relay edge containing a `AutoTopupTriggerConnectionType` and its cursor.
"""
type AutoTopupTriggerConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AutoTopupTriggerType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
GraphQL output type for querying auto top-up trigger events.
"""
type AutoTopupTriggerType {
  id: ID!

  """
  Integer ID of the related AutoTopupConfig, e.g. '123'.
  """
  autoTopupConfigId: ID!

  """
  DateTime when auto topup was triggered, e.g. '2024-01-01T00:00:00+00:00'.
  """
  triggeredAt: DateTime!

  """
  Status of the auto top-up trigger event.
  """
  status: SmartDeviceAutoTopupTriggerStatus!

  """
  Source of the auto top-up trigger event.
  """
  source: SmartDeviceAutoTopupTriggerSources!

  """
  Reason auto top-up trigger event failed, if any.
  """
  failureReason: SmartDeviceAutoTopupTriggerFailureReasons

  """
  DateTime when the trigger event was created, e.g. '2024-01-01T00:00:00+00:00'.
  """
  createdAt: DateTime!

  """
  DateTime when the trigger event was last updated, e.g. '2024-01-01T00:00:00+00:00'.
  """
  updatedAt: DateTime!
}

"""
An enumeration.
"""
enum SmartDeviceAutoTopupTriggerStatus {
  INITIATED

  COMPLETED

  FAILED
}

"""
An enumeration.
"""
enum SmartDeviceAutoTopupTriggerSources {
  LOW_CREDIT_BALANCE
}

"""
An enumeration.
"""
enum SmartDeviceAutoTopupTriggerFailureReasons {
  NO_IMPORT_METER

  FAILED_TO_COLLECT_PAYMENT

  PAYMENT_NOT_SUCCESSFUL

  FAILED_TO_TRIGGER_ADD_CREDIT_TO_METER
}

type OccupierAccount {
  account: String!

  address: String!

  date: String!

  propertyId: Int!

  """
  A Kraken Token that can be used to call the 'occupy' mutation for the account.
  """
  occupyToken: String!
}

"""

This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).

"""
type AddressConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [AddressConnectionTypeEdge]!

  """
  Total number of nodes.
  """
  totalCount: Int!

  """
  Number of nodes in the edge.
  """
  edgeCount: Int!
}

"""
A Relay edge containing a `AddressConnectionType` and its cursor.
"""
type AddressConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: AddressType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type AddressType {
  """
  A unique ID per address using part of the address with spaces removed.
  """
  addressKey: String!

  """
  The type of address (domestic, business or unknown).
  """
  addressType: AddressTypeEnum

  """
  The complete and human-legible address in a single string.
  """
  display: String!

  """
  The ID of the Grid Supply Point Group that the address belongs to.
  """
  gspGroupId: String!

  """
  Line 1 of the address. This is generally the house number and street name. 
  """
  line1: String!

  """
  Line 2 of the address. This is generally the area or village. 
  """
  line2: String!

  """
  Line 3 of the address. This is generally the area or village. 
  """
  line3: String!

  """
  Line 4 of the address. This is generally the city. 
  """
  line4: String!

  """
  Line 5 of the address. This is generally the county. 
  """
  line5: String!

  postcode: String!

  """
  The identifier for a property. The house number consists of the part of line 1 of the address that is not the street name. This includes sub-building names, building names, deliver point aliases and building numbers. For example, the house number for the property 'Flat 12 100 Example St' would be 'Flat 12 100'.
  """
  houseNumber: String

  """
  The street name for a property. The street name consists of the part of line 1 of the address that is not the house number. For example, the house number for the property 'Flat 12 100 Example St' would be 'Example St'.
  """
  streetName: String

  hasPrepaidMeters: Boolean!

  gasMeterPoints: [AddressAPIGasMeterPointType]

  electricityMeterPoints: [AddressAPIElectricityMeterPointType]
}

"""
An enumeration.
"""
enum AddressTypeEnum {
  DOMESTIC

  BUSINESS

  UNKNOWN
}

type AddressAPIGasMeterPointType {
  mprn: String
}

type AddressAPIElectricityMeterPointType {
  mpan: String

  profileClass: String
}

enum DataSource {
  CACHE

  LIVE
}

type ElectricityMeterPointForAddressType {
  addressHasMoreThanOneElectricityMeterPoint: Boolean!

  """
  List of meterpoints associated with the address. Only returned if address_has_more_than_one_electricity_meter_point is True. 
  """
  electricityMeterPoints: [String]

  """
  Line 1 of the address returned from the search
  """
  addressLine1: String

  """
  Line 2 of the address returned from the search
  """
  addressLine2: String

  """
  The postcode of the address returned from the search
  """
  postcode: String
}

input AddressSearchType {
  addressLine1: String!

  addressLine2: String!

  addressLine3: String!

  town: String!

  county: String!

  postcode: String!
}

type CostOfUsageType {
  """
  Whether cost of usage can be displayed for a user.
  """
  costEnabled: Boolean

  """
  Energy product direction, e.g. IMPORT or EXPORT.
  """
  direction: String

  """
  Cost of usage for given period.
  """
  details("The meter ID." meterId: String, "The energy type, i.e. ELECTRICITY or GAS." fuelType: FuelType, startAt: DateTime, "Aggregate cost according to this grouping." grouping: ConsumptionGroupings!, "Timezone to use for grouping." timezone: String, before: String, after: String, first: Int, last: Int): CostOfUsageConnectionTypeConnection
}

"""
Dovetailing usage and cost for an account / meter combination over a given time period.
"""
type CostOfUsageConnectionTypeConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [CostOfUsageConnectionTypeEdge]!

  """
  Overall cost of nodes in the edge.
  """
  cost: Int

  """
  Overall usage of nodes in the edge.
  """
  usageKwh: Decimal!
}

"""
A Relay edge containing a `CostOfUsageConnectionType` and its cursor.
"""
type CostOfUsageConnectionTypeEdge {
  """
  The item at the end of the edge
  """
  node: IntervalCostOfUsageType

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Usage and cost between two points in time.
"""
type IntervalCostOfUsageType {
  """
  Interval start datetime.
  """
  startAt: DateTime

  """
  Interval end datetime.
  """
  endAt: DateTime

  """
  Cost per time interval.
  """
  cost: Int

  """
  Usage per time interval.
  """
  usageKwh: Decimal
}

"""
An enumeration.
"""
enum FuelType {
  """
  Electricity.
  """
  ELECTRICITY

  """
  Gas.
  """
  GAS

  """
  Dual Fuel.
  """
  DUAL_FUEL
}

"""
Payment Instructions
"""
type DefaultElectricJuicePaymentInstructionType {
  id: ID!

  instructionType: String!

  cardPaymentNetwork: String

  cardExpiryMonth: Int

  cardExpiryYear: Int

  validFrom: DateTime!

  """
  The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  """
  vendor: String!

  cardNumber: String!

  cardType: String
}

"""
Store a new card instruction for Electric Juice from an embedded form.

The possible errors that can be raised are:

- KT-CT-3923: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type StoreElectricJuicePaymentInstruction {
  possibleErrors: [PossibleErrorType]

  paymentInstruction: PaymentInstructionType
}

"""
The GraphQL error type for displaying information about
GraphQL errors that might be raised from the API.
"""
type PossibleErrorType {
  """
  The error message that might be returned from the query/mutation.
  """
  message: String

  """
  The error code that might be returned from the query/mutation.
  """
  code: String

  """
  The error type that might be returned from the query/mutation.
  """
  type: String

  """
  The error description that might be returned from the query/mutation.
  """
  description: String
}

"""
Payment Instructions
"""
type PaymentInstructionType {
  id: ID!

  status: String!

  sortCode: String!

  iban: String!

  accountHolder: String!

  instructionType: String!

  cardPaymentNetwork: String

  cardExpiryMonth: Int

  cardExpiryYear: Int

  bankCode: String

  accountType: String

  validFrom: DateTime!

  """
  The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  """
  vendor: String!

  cardNumber: String!

  cardType: String

  """
  A masked reference to a recurring payment method.
  """
  maskedAccountIdentifier: String
}

"""
The input for storing a new card instruction from an embedded form.
"""
input StoreElectricJuicePaymentInstructionInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The datetime from which the instruction is vaild.
  """
  validFrom: DateTime!

  """
  The vendor's reference for this payment method.
  """
  vendorReference: String!
}

type Mutation {
  """
  Calculate the deposit amount. Record the deposit amount and return the key

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  calculateDepositAmount(calculateDepositAmountInput: CalculateDepositAmountInput!): CalculateDepositAmount

  """
  Create and retrieve a business credit risk analysis.

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  checkBusinessCreditRisk("Input for checking business credit risk." checkBusinessCreditRiskInput: CheckBusinessCreditRiskInput!): CheckBusinessCreditRisk

  """
  Create product rate(s) for a certain product.

  The possible errors that can be raised are:

  - KT-GB-9514: No available product found.
  - KT-GB-9518: Invalid input data for product rate(s).
  - KT-GB-9519: Unable to create product rate(s).
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createProductRates("List of rates to be created for the specified product." input: CreateProductRatesInputType!, "Code of the product for which the rates are being created." productCode: String!): CreateProductRates

  """
  DO NOT USE: WIP Create a quote for new meter points for products with passed in tag.
  """
  quoteNewMeterPoints(input: QuoteNewMeterPointsInput!): QuoteNewMeterPoints

  """
  DO NOT USE: WIP Create a quote for new meter points on passed in products with bespoke rates. This is an acquisition quote mutation only to be used by authenticated third party organisations for bespoke quoting.

  The possible errors that can be raised are:

  - KT-CT-4616: Unable to create a quote.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  quoteNewMeterPointsOnBespokeProducts(input: QuoteNewMeterPointsOnBespokeProductsInput!): QuoteNewMeterPointsOnBespokeProducts

  """
  Create a quote for an existing account for the specified meterpoints on the passed in products.

  The possible errors that can be raised are:

  - KT-CT-4616: Unable to create a quote.
  - KT-GB-4614: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  quoteAccountOnProducts(input: QuoteAccountOnProductsInput!): QuoteAccountOnProducts

  """
  Create a renewal quote request.
  """
  createRenewalQuoteRequest(input: CreateRenewalQuoteRequestInput!): CreateRenewalQuoteRequest

  """
  Create a renewal quote request for specified products without persisting to the database.

  The possible errors that can be raised are:

  - KT-GB-4624: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createQuoteRequestForProducts(input: CreateQuoteRequestForProductsInput!): CreateQuoteRequestForProducts

  """
  Create an acquisition quote request for requested products without persisting to the database.

  The possible errors that can be raised are:

  - KT-GB-4625: Unable to create quote request.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  createAcquisitionQuoteRequestForProducts(input: CreateAcquisitionQuoteRequestForProductsInput!): CreateAcquisitionQuoteRequestForProducts

  """
  Add a refund request to an account.

  The possible errors that can be raised are:

  - KT-GB-4127: Unable to send refund request confirmation email.
  - KT-GB-4121: Unable to process refund request.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createRefundRequest("Input fields for creating a refund request." input: RefundRequestInput!): CreateRefundRequest

  """
  Update smart meter data preferences of an account. Includes updating reading frequency and readings analysis consent.

  The possible errors that can be raised are:

  - KT-CT-4023: Unauthorized.
  - KT-GB-4015: Cannot update smart meter reading frequency preferences.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateSmartMeterDataPreferences("Input fields for updating smart meter data preferences." input: UpdateSmartMeterDataPreferencesInput!): UpdateSmartMeterDataPreferences

  """
  Joins a device to a HAN (Home Area Network).

  The possible errors that can be raised are:

  - KT-GB-4019: This device type is not currently supported.
  - KT-GB-4020: Error sending the request to join the device to the Home Area Network.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  joinDeviceToNetwork("Device ID of the CHF (Communications Hub Function)." chfDeviceId: String!, "Code that authorises joining of the device to the HAN." installCode: String, "MPAN\/MPRN of the meter or HCALCS to join to the HAN." mpxn: String, "Device ID of the device to join to the HAN." newDeviceId: String!, "Type of device that is being joined to the HAN." newDeviceType: JoinableDeviceType!): JoinDeviceToNetwork

  """
  Commissions the device after the meter has been physically installed.

  The possible errors that can be raised are:

  - KT-GB-4021: Invalid MPxN.
  - KT-GB-4022: MPxN not recognised.
  - KT-GB-4023: Error sending the request to commission the device.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  commissionMeter("Input fields for commission meters." input: CommissionMeterInput!): CommissionMeter

  """
  Decommissions a device using SmartPear's 'remove device' orchestration.

  The possible errors that can be raised are:

  - KT-GB-4024: The provided device ID does not match any devices known by Kraken.
  - KT-GB-4025: Error sending the request to decommission the device.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  decommissionSmartDevice("Input fields for decommission meters." input: DecommissionSmartDeviceInput!): DecommissionSmartDevice

  """
  Notify Kraken to run the relevant prenotifications for a new device.
  """
  registerSmartDevice("Specifies device metadata to use for prenotifications." input: RegisterSmartDeviceInput!): RegisterSmartDevice

  """
  Update the status of the CHF (Communictions Hub).

  The possible errors that can be raised are:

  - KT-GB-4026: Either the mpxn or mpan input must be provided.
  - KT-GB-4027: If both mpxn and mpan are provided, they must match.
  - KT-GB-4028: Please input a valid MPxN.
  - KT-GB-4029: Meter point not found for MPAN.
  - KT-GB-4030: Meter point not found for MPRN.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateCommsHubStatus("Input fields for updating the status of the communications hub." input: UpdateCommsHubStatusInput!): UpdateCommsHubStatus

  """
  Triggers the orchestration to join the PPMID, IHD, CAD or Alt HAN device to the ESME, GSME, GPF and/or CHF. This should be called after a meter has been commissioned.

  The possible errors that can be raised are:

  - KT-GB-4053: Fuel type should not be specified for Alt HAN device.
  - KT-GB-4031: Error sending the request to join the device to the CHF.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  joinConsumerDevice("Input fields for join device." input: JoinConsumerDeviceInput!): JoinConsumerDevice

  """
  Triggers the orchestration to remove the CAD device to the ESME, GSME, GPF and CHF.

  The possible errors that can be raised are:

  - KT-GB-4012: Unable to find the CAD device.
  - KT-GB-4032: Error sending the request to remove the device.
  - KT-GB-4013: Received invalid device type to remove other than CAD.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  removeConsumerDevice("Input fields for remove device." input: RemoveConsumerDeviceInput!): RemoveConsumerDevice

  """
  Add credit to a smart prepay meter
  """
  addCreditToSmartMeter("Controls which meter to top-up and by how much." input: SmartPrepayMeterAmountInput!): AddCreditToSmartMeter

  """
  Request an ad hoc read of the meters consumption data, which will arrive asynchronously

  The possible errors that can be raised are:

  - KT-GB-4033: No electricity device found matching device ID.
  - KT-GB-4034: Error requesting consumption data.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  requestConsumptionData("Input fields for requesting consumption data." input: RequestConsumptionDataInput!): RequestConsumptionData

  """
  Replace an existing Communications Hub with a new one and move existing devices to the new Hub.
  """
  replaceCommsHub("Input fields for replacing a Communications Hub." input: ReplaceCommsHubInput!): ReplaceCommsHub

  """
  Triggers an asynchronous request to check the connection of a device. The request reference is returned, which can be used to track the status of the request.
  """
  checkDeviceConnection("Input field for checking device connection." input: CheckDeviceConnectionInput!): CheckDeviceConnection

  """
  Add details to an existing occupier account.

  The possible errors that can be raised are:

  - KT-GB-6622: Account not found.
  - KT-GB-6623: Property not found.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  occupy(input: OccupyInput!): OccupyOutputType

  """
  Perform a move out of a property for an account.

  Optionally provide details of the new tenant and a property to perform a move in to.



  The possible errors that can be raised are:

  - KT-GB-6624: An error occurred when trying to process this house move.
  - KT-GB-6625: An error occurred when trying to process this house move.
  - KT-GB-6626: There was an error processing the PSR data.
  - KT-GB-6627: There are missing agent appointments.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  performMoveOut(input: MoveOutInput!): PerformMoveOut

  """
  Create a shell/payment account.
  """
  createShellAccount(input: CreateShellAccountInput!): CreateShellAccountPayload

  """
  Update account communication delivery preference.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-4136: Cannot set comms preference to email when account has no email.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateCommsDeliveryPreference("Input fields for updating comms delivery preferences for an account" input: UpdateCommsDeliveryPreferenceInput!): UpdateCommsDeliveryPreference

  """
  Update account billing email.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-4122: Invalid email.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateAccountBillingEmail("Input fields for updating billing email for an account." input: UpdateAccountBillingEmailInput!): UpdateAccountBillingEmail

  """
  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  addCampaignToAccount("Input variables needed for adding a campaign to an account." input: AddCampaignToAccountInput!): AddCampaignToAccount

  """
  Update the account billing address.

  The possible errors that can be raised are:

  - KT-CT-4145: Invalid address.
  - KT-CT-7123: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateAccountBillingAddress("Input variables needed for updating an account billing address." input: AccountBillingAddressInput!): UpdateAccountBillingAddress

  """
  Add a note to an account.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-4180: Account note must be a valid string.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAccountNote("Input variables needed for adding a note to an account." input: CreateAccountNoteInput!): CreateAccountNote

  """
  Renew agreements for an account.

  The possible errors that can be raised are:

  - KT-GB-4125: Invalid data.
  - KT-GB-4111: Unable to renew agreements for tariff renewal.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  renewAgreements(input: RenewAgreementsInput): RenewAgreements

  """
  Renew agreement for a meter point.

  The possible errors that can be raised are:

  - KT-GB-4112: Unable to renew agreements for meter point at this time. Please try again later.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  renewAgreementForMeterPoint(input: RenewAgreementForMeterPointInput!): RenewAgreementForMeterPoint

  """
  Renew a list of agreements for an account.

  The possible errors that can be raised are:

  - KT-GB-4113: At least one list of agreements to renew is required.
  - KT-GB-4126: Electricity and gas agreement input is invalid.
  - KT-GB-4114: Unable to renew agreements.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  renewAgreementsForAccount(input: RenewAgreementsForAccountInput): RenewAgreementsForAccount

  """
  Set stated interest in procuring a smart meter for an account.

  The possible errors that can be raised are:

  - KT-GB-4115: Could not create smart meter interest for account.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  smets2Interest(input: UpdateAccountSmartMeterInterestInput): UpdateAccountSmartMeterInterest

  """
  Start smart onboarding process for an account.

  The possible errors that can be raised are:

  - KT-GB-4102: Unable to start smart onboarding process.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  startOnboardingProcess(input: StartSmartOnboardingProcessInput): StartSmartOnboardingProcess

  """
  Start export onboarding process for an account.

  The possible errors that can be raised are:

  - KT-GB-4103: Unable to start export onboarding process.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  startExportOnboardingProcess(input: StartExportOnboardingProcessInput): StartExportOnboardingProcess

  """
  Update SSD.

  The possible errors that can be raised are:

  - KT-GB-4101: Unable to update SSD for account.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateSsd(input: UpdateSsdInput): UpdateSsd

  """
  Create a Siteworks event.
  """
  createSiteworksEvent("Input fields for creating a new Siteworks event." input: CreateSiteworksEventInput!): CreateSiteworksEvent

  """
  Allow external parties to create a Siteworks event.

  The possible errors that can be raised are:

  - KT-GB-4222: The provided 'siteworksRequestId' is not a valid UUID.
  - KT-GB-4223: Siteworks request not found. Check the provided 'siteworksRequestId' is correct.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createSiteworksEventExternal("Input fields for creating a new Siteworks event." input: CreateSiteworksEventInput!): CreateSiteworksEventExternal

  """
  Create or update a Siteworks appointment.

  The possible errors that can be raised are:

  - KT-CT-1112: 'Authorization' header not provided.
  - KT-CT-4231: Unauthorized.
  - KT-GB-4230: Invalid data.
  - KT-GB-4224: Error processing siteworks appointment.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createOrUpdateSiteworksAppointment("Input fields for creating or updating siteworks appointments." input: CreateOrUpdateSiteworksAppointmentInput!): CreateOrUpdateSiteworksAppointment

  """
  Cancel a Siteworks appointment.
  """
  cancelSiteworksAppointment("Input fields for cancelling a siteworks appointment." input: CancelSiteworksAppointmentInput!): CancelSiteworksAppointment

  """
  Confirm an appointment slot returned by the appointment slots query.

  The possible errors that can be raised are:

  - KT-GB-4219: Property does not exist.
  - KT-GB-4220: No account currently active at property.
  - KT-GB-4221: Could not confirm duplicate property.
  - KT-GB-4228: Cannot currently book appointments for legacy prepay meters.
  - KT-GB-4229: A smart meter exchange appointment for this date already exists.
  - KT-GB-4210: Bookings not supported for agent appointed at property.
  - KT-GB-4211: Timeslot no longer available.
  - KT-GB-4212: Missing or invalid data for account or property.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  confirmSiteworksAppointmentSlot("Input fields for booking a siteworks appointment slot" input: ConfirmSiteworksAppointmentSlotInput!): ConfirmSiteworksAppointmentSlot

  """
  Report details, readings and balances of meters removed during install.

  The possible errors that can be raised are:

  - KT-GB-4213: Application not found.
  - KT-GB-4231: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  reportRemovedMeterDetails("Input fields for removed meter details." input: ReportRemovedMeterDetailsInput!): ReportRemovedMeterDetails

  """
  Update or create special circumstances for the user, which may entitle them to specialist services



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-GB-5411: Failed to update special circumstance record.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateSpecialCircumstances(input: UpdateSpecialCircumstancesInput!): UpdateSpecialCircumstances

  """
  **DEPRECATED: Please use updatePaymentSchedulePaymentDay instead**

  Update monthly Direct Debit payment day

  This field requires the `Authorization` header to be set. 

  """
  directDebitPaymentDayUpdate(input: DirectDebitPaymentDayUpdateInput!): DirectDebitPaymentDayUpdate @deprecated(reason: "The 'directDebitPaymentDayUpdate' field is deprecated.\n\n\nPlease use the 'updatePaymentSchedulePaymentDay' mutation instead.\n\n\n- Marked as deprecated on 2020-10-02.\n- Will be removed on 2023-04-06.")

  """
  Update monthly Direct Debit payment day. Permitted values: 1-28. Not available for business accounts



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-GB-3918: Account not found.
  - KT-GB-3910: This feature is not available to business accounts.
  - KT-GB-3911: Your payment day cannot be changed at this time.
  - KT-GB-3912: Unable to update payment day.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  updatePaymentSchedulePaymentDay(input: UpdatePaymentSchedulePaymentDayInput!): UpdatePaymentSchedulePaymentDay

  """
  Update monthly Direct Debit payment amount. Enter amount in pence

  Lower limit: 100p (1), Upper limit: 100,000p (1,000)



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-GB-3919: Invalid payment schedule amount.
  - KT-GB-3920: Cannot update payment schedule amount.
  - KT-CT-3923: Unauthorized.
  - KT-CT-3941: Invalid data.
  - KT-CT-3942: An unexpected error occurred.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updatePaymentSchedulePaymentAmount(input: UpdatePaymentSchedulePaymentAmountInput!): UpdatePaymentSchedulePaymentAmount

  """
  Create new direct debit instruction



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-CT-3940: Invalid data.
  - KT-CT-3923: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createDirectDebitInstruction("Input fields for creating a new direct debit instruction." input: CreateDirectDebitInstructionInput!): CreateDirectDebitInstruction

  """
  Create a monthly payment schedule for a fixed amount.

  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-GB-3917: No statement in last 60 days.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  createPaymentSchedule(input: PaymentScheduleInput!): CreatePaymentSchedule

  """
  Create warm home discount application with given qualifying requirements and account.

  This field requires the `Authorization` header to be set. 

  """
  createWarmHomeDiscountApplication(accountNumber: String, applicationInputs: WarmHomeDiscountApplicationInputType): WarmHomeDiscountApplicationOutputType

  """
  Create electricity meter reading(s) with the given value(s) for the given meter(s).

  This field requires the `Authorization` header to be set. 

  """
  createElectricityMeterReading(mpan: String, readAt: Date, readings: [ReadingInputType], serialNumber: String): CreateMeterReadingOutputType

  """
  Create gas meter reading with the given value for the given meter.

  This field requires the `Authorization` header to be set. 

  """
  createGasMeterReading(mprn: String, readAt: Date, reading: Int, serialNumber: String): CreateMeterReadingOutputType

  """
  Amend unbilled electricity readings.
  """
  amendUnbilledElectricityReading("Input fields for amending unbilled electricity reading." input: AmendUnbilledReadingInput!): AmendUnbilledElectricityReading

  """
  Create a new auto top-up config for SPAYG meter.
  """
  createAutoTopupConfig("Input fields for creating an auto top-up config." input: CreateAutoTopupConfigInput!): CreateAutoTopupConfig

  """
  Disable auto top-up for SPAYG meter.
  """
  disableAutoTopup("Input fields for disabling auto top-up." input: DisableAutoTopupInput!): DisableAutoTopup

  """
  Create a quote for the given set of meter points for the supplied consumption.
  """
  createQuote(input: CreateQuoteInput!): CreateQuoteOutputType

  """
  Refresh quote with updated products for a quote code.

  The possible errors that can be raised are:

  - KT-GB-4612: Unable to refresh quote - quote not found.
  - KT-GB-4613: Error generating quote.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  refreshQuote(input: RefreshQuoteInput!): RefreshQuote

  """
  Requote for an account property.
  """
  requote(input: RequoteInput!): Requote

  """
  Bill to latest smart meter snapshot.
  """
  billToLatestSmartMeterSnapshot("Input fields for billing to latest smart meter snapshot." input: BillToLatestSmartMeterSnapshotInput!): BillToLatestSmartMeterSnapshot

  """
  Switch the specified meter points to the chosen product.

  The possible errors that can be raised are:

  - KT-GB-4116: Invalid data.
  - KT-GB-4617: Quoted product not found.
  - KT-CT-4623: Unauthorized.
  - KT-GB-4117: Unable to process product switch.
  - KT-GB-4119: Meter point already on another account.
  - KT-GB-4120: MPxN has no active agreement.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  switchMeterPointProducts(input: SwitchMeterPointProductsInput): SwitchMeterPointProducts

  """
  Add a charge for Electric Juice.
  """
  createElectricJuiceCharge("Input fields for creating an account charge." input: CreateElectricJuiceChargeInput!): CreateElectricJuiceCharge

  """
  Add a credit for Electric Juice
  """
  createElectricJuiceCredit("Input fields for creating an Electric Juice credit." input: CreateElectricJuiceCreditInput!): CreateElectricJuiceCredit

  """
  Store a new card instruction for Electric Juice from an embedded form.

  The possible errors that can be raised are:

  - KT-CT-3923: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  storeElectricJuicePaymentInstruction("Input fields for storing a new card instruction from an embedded form." input: StoreElectricJuicePaymentInstructionInput!): StoreElectricJuicePaymentInstruction

  """
  Create an Electric Juice agreement for an account.
  """
  createElectricJuiceAgreement("Input fields for creating an Electric Juice agreement for an account." input: CreateElectricJuiceAgreementInput!): CreateElectricJuiceAgreement

  """
  Create an Electric Juice charge card for an account.
  """
  createElectricJuiceChargeCard("Input fields for creating an Electric Juice charge card." input: CreateElectricJuiceChargeCardInput!): CreateElectricJuiceChargeCard

  """
  Post a charge for an EV public charging session.

  The possible errors that can be raised are:

  - KT-CT-5813: Invalid data.
  - KT-CT-5814: Invalid data.
  - KT-CT-5815: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  postEvPublicChargingCharge("Input fields for initiating a standalone payment." input: PostEVPublicChargingChargeInput!): PostEVPublicChargingCharge

  """
  Post an EV Public Charging credit.

  The possible errors that can be raised are:

  - KT-CT-5816: Invalid data.
  - KT-CT-5817: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  postEvPublicChargingCredit("Input fields for creating a credit." input: PostEVPublicChargingCreditInput!): PostEVPublicChargingCredit

  """
  Create EV public charging agreement.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-5811: Active agreement already exists.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createEvPublicChargingAgreement("Input fields for creating an agreement." input: CreateEvPublicChargingAgreementInput!): CreateEvPublicChargingAgreement

  """
  Add EV public charging token.

  The possible errors that can be raised are:

  - KT-CT-5817: Invalid data.
  - KT-CT-5812: Token with this value already exists within this period.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  addEvPublicChargingToken("Input fields for adding a token." input: AddEvPublicChargingTokenInput!): AddEvPublicChargingToken

  """
  Expire EV Public charging token.

  The possible errors that can be raised are:

  - KT-CT-5817: Invalid data.
  - KT-CT-5818: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  expireEvPublicChargingToken("Input fields for expiring a token." input: ExpireEvPublicChargingTokenInput!): ExpireEvPublicChargingToken

  """
  Create a new heat pump goods quote.
  """
  createHeatPumpGoodsQuote(input: CreateHeatPumpGoodsQuoteInput): CreateHeatPumpGoodsQuote

  """
  Provide username and password to receive a token. The token should be used as the `Authorization` header for any authenticated requests.
  """
  emailAuthentication(email: String!, password: String!): EmailAuthentication @deprecated(reason: "The 'emailAuthentication' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2021-09-03.\n- Will be removed on 2024-01-01.")

  """
  You probably want email authentication instead of this. Provide user's API Key to receive a token. The token should be used as the `Authorization` header for any authenticated requests. This form of authentication is used when the interface in question already has the API Key and it would be inappropriate to show the user a login screen.
  """
  apiKeyAuthentication(apiKey: String!): APIKeyAuthentication @deprecated(reason: "The 'apiKeyAuthentication' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2021-09-03.\n- Will be removed on 2024-01-01.")

  """
  Deactivate the auth token used to authenticate the current request.
  """
  disableToken: DisableToken @deprecated(reason: "The 'disableToken' field is deprecated.\n\nPlease use obtainKrakenToken instead of this mutation.\n\n- Marked as deprecated on 2024-05-23.\n- Will be removed on 2024-06-30.")

  """
  Submit meter readings for any FIT installations associated with a particular account.

  The possible errors that can be raised are:

  - KT-GB-6812: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  fitCreateMeterReadings(input: FitMeterReadingInput!): FitCreateMeterReadings

  """
  Accept a FIT schedule for a particular account.

  The possible errors that can be raised are:

  - KT-GB-6813: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  fitAcceptSchedule(input: FitAcceptScheduleInput!): FitAcceptSchedule

  """
  Create a quote for a campaign offer.
  """
  quoteCampaignOffer(input: QuoteCampaignOfferInput): QuoteCampaignOffer

  """
  Replace an agreement for an account with a new product.
  """
  replaceAgreement(input: ReplaceAgreementInput): ReplaceAgreement

  """
  Generate PAN for a smart prepay meter

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  """
  generatePaymentAllocationNumber("Identifies the meter to generate a PAN for." input: SmartMeterDeviceInput!): GeneratePaymentAllocationNumber

  """
  Create a charge to offset the carbon for a journey

  The possible errors that can be raised are:

  - KT-CT-3923: Unauthorized.
  - KT-GB-7911: Account cannot calculate carbon offset.
  - KT-GB-7912: Error charging account for carbon offset.
  - KT-GB-7910: Error calculating carbon offset.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  chargeCarbonOffset("Input fields for calculating a carbon offset." input: ChargeCarbonOffsetInput!): ChargeCarbonOffset @deprecated(reason: "The 'chargeCarbonOffset' field is deprecated.\n\nCarbon offset functionality is no longer supported.\n\n- Marked as deprecated on 2024-05-14.\n- Will be removed on 2024-07-14.")

  """
  Assign discount code to account and account user if available and eligible. A confirmation email will be sent to the user with the discount code.

  The possible errors that can be raised are:

  - KT-GB-5911: We have assigned all electric blanket discount codes.
  - KT-GB-5912: Account already has a discount code assigned.
  - KT-GB-5913: An error occurred assigning a discount code.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  assignDiscountCode("The account number to assign the code to." accountNumber: String): AssignDiscountCode

  """
  Create a temporary provisioning cert in krakenflex
  """
  createTempProvisioningClaim: CreateProvisioningClaim

  """
  Redeem the maximum possible number of OctoPoints as account credit

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-GB-5011: Not enough OctoPoints for redemption.
  - KT-GB-5010: Error redeeming OctoPoints.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  redeemOctoPointsForAccountCredit("Input fields for redeeming OctoPoints." input: RedeemOctoPointsInput!): RedeemOctoPointsForAccountCredit @deprecated(reason: "The 'redeemOctoPointsForAccountCredit' field is deprecated.\n\nPlease use the RedeemLoyaltyPointsForAccountCredit mutation instead\n\n- Marked as deprecated on 2024-02-06.\n- Will be removed on 2024-05-06.")

  """
  Creates a new Snap for the given account.

  The possible errors that can be raised are:

  - KT-GB-9316: Account is not Octoplus-enrolled.
  - KT-GB-9325: Invalid constantine slug.
  - KT-GB-9326: Invalid spawn ID.
  - KT-GB-9319: This feature is not currently available.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  createSnap("The account number to attach the snap to." accountNumber: String!, "The unique identifier for the constantine." spawnId: String!): CreateSnap

  """
  Enrolls an account in the Octoplus campaign.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-GB-9310: Account ineligible for joining Octoplus.
  - KT-GB-9311: Error joining campaign.
  - KT-GB-9312: Account already signed up to Octoplus.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  joinOctoplusCampaign("Kraken account number." accountNumber: String, "Options to enrol the account in Saving Sessions after joining Octoplus." savingSessionsEnrolmentOptions: SavingSessionsEnrolmentOptions): JoinOctoplusCampaign

  """
  Claim a Shoptopus Voucher using Octopoints.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  - KT-GB-9313: Not enough Octopoints.
  - KT-GB-9314: Reward could not be processed.
  - KT-GB-9315: Reward of this type unavailable.
  - KT-GB-9316: Account is not Octoplus-enrolled.
  - KT-GB-9319: This feature is not currently available.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  claimShoptopusVoucher("The account number for the Octoplus-enrolled account" accountNumber: String!, "The number of Octopoints to exchange for a reward." points: Int!): ClaimShoptopusVoucher

  """
  Claim an Octoplus Reward.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  - KT-GB-9313: Not enough Octopoints.
  - KT-GB-9314: Reward could not be processed.
  - KT-GB-9315: Reward of this type unavailable.
  - KT-GB-9316: Account is not Octoplus-enrolled.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  claimOctoplusReward("The account number for the Octoplus-enrolled account" accountNumber: String!, "The unique string identifier for the offer to be claimed." offerSlug: String!): ClaimOctoplusReward

  """
  Create a link to the customer contact form for this account.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  - KT-GB-9319: This feature is not currently available.
  - KT-GB-9323: Could not create contact link.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createOctoplusRewardContactLink("The account number for the Octoplus-enrolled account" accountNumber: String!): CreateOctoplusRewardContactLink

  """
  Orders a blanket to be delivered to the account.

  The possible errors that can be raised are:

  - KT-GB-6013: Account is not eligible to order a blanket.
  - KT-GB-6014: An error occurred placing the order.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  orderBlanket("The account number to send the blanket to." accountNumber: String): OrderBlanket

  """
  Accept the terms and conditions.
  """
  acceptTermsAndConditions("Input fields for accepting terms and conditions" input: AcceptTermsAndConditionsInput!): AcceptTermsAndConditions

  """
  Sign account up to Saving Sessions campaign.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-GB-5110: Campaign not found.
  - KT-GB-5111: Meter point not found.
  - KT-GB-5112: Error joining campaign.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  joinSavingSessionsCampaign("Input fields for joining the Saving Sessions campaign." input: JoinSavingSessionsCampaignInput!): JoinSavingSessionsCampaign

  """
  Opt account in to a Saving Sessions event.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-GB-5114: Saving Sessions event not found.
  - KT-GB-5116: Account is not part of a Saving Sessions campaign.
  - KT-GB-5117: Account ineligible to join Saving Sessions event.
  - KT-GB-5115: Error joining event.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  joinSavingSessionsEvent("Input fields for joining a Saving Sessions event." input: JoinSavingSessionsEventInput!): JoinSavingSessionsEvent

  """
  Set charging preferences for a home battery.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4353: An error occurred while trying to update your charging preferences.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setBatteryChargingPreferences(input: BatteryChargingPreferencesInput): SetBatteryChargingPreferences

  """
  De-authenticate a device.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4350: Unable to de-authenticate device.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  deauthenticateDevice(input: DeAuthenticationInput): DeauthenticateDevice

  """
  Register a device (EV, battery or heat pump) for smart control.

  The possible errors that can be raised are:

  - KT-CT-4324: Device already registered error.
  - KT-CT-4321: Serializer validation error.
  - KT-CT-4312: Unable to register device.
  - KT-CT-4363: No capable devices found.
  - KT-CT-4364: Multiple devices found.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  deviceRegistration(input: DeviceRegistrationInput): DeviceRegistration

  """
  Completes the registration of a device if the contract is eligible and the device registration valid.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-4322: Unable to complete registration error.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  thirdPartyCompleteDeviceRegistration(input: CompleteDeviceRegistrationInput): ThirdPartyCompleteDeviceRegistration

  """
  Create a wizard for onboarding a device with SmartFlex.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  startSmartFlexOnboarding(input: StartSmartFlexOnboardingInput!): StartSmartFlexOnboarding

  """
  Cancel onboarding of a device with SmartFlex.

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  cancelSmartFlexOnboarding(input: CancelSmartFlexOnboardingInput!): CancelSmartFlexOnboarding

  """
  Register a device for an account.

  The possible errors that can be raised are:

  - KT-CT-4335: Another device registration is already in progress.
  - KT-CT-4321: Serializer validation error.
  - KT-CT-4314: Unable to get provider details.
  - KT-CT-4351: Provider authentication error.
  - KT-CT-4312: Unable to register device.
  - KT-CT-4363: No capable devices found.
  - KT-CT-4364: Multiple devices found.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  registerDevice(input: RegisterDeviceInput): RegisterDevice @deprecated(reason: "The 'registerDevice' field is deprecated.\n\nPlease use `DeviceRegistration` instead of this endpoint.\n\n- Marked as deprecated on 2024-01-08.\n- Will be removed on 2024-07-01.")

  """
  Delete connection details for a device.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4352: Unable to delete connection details.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  deleteDeviceConnectionDetails(input: AccountNumberInput): DeleteDeviceConnectionDetails @deprecated(reason: "The 'deleteDeviceConnectionDetails' field is deprecated.\n\nPlease use `DeauthenticateDevice` instead of this endpoint.\n\n- Marked as deprecated on 2023-08-11.\n- Will be removed on 2024-01-01.")

  """
  Reauthenticate an already registered device.

  The possible errors that can be raised are:

  - KT-CT-4313: Could not find KrakenFlex device.
  - KT-CT-4314: Unable to get provider details.
  - KT-CT-4315: Unable to re-authenticate device.
  - KT-CT-4363: No capable devices found.
  - KT-CT-4364: Multiple devices found.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  reauthenticateDevice(input: ReauthenticateDeviceInput): ReauthenticateDevice

  """
  Set charging preferences for your electric vehicle.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4321: Serializer validation error.
  - KT-CT-4353: An error occurred while trying to update your charging preferences.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setVehicleChargePreferences(input: VehicleChargingPreferencesInput): SetVehicleChargingPreferences

  """
  Initiate a test charge of an electric vehicle (EV).

  This is to ensure that the EV or EVSE (charge point) can be controlled remotely and successfully charged for a
  short period.

  If it is not possible to initiate a test charge, a KT-CT-4355 error will be returned. It may have a
  `testChargeRefusalReasons` extension which lists the reasons why the test charge was refused. Possible reasons
  include:

  - `TC_DEVICE_LIVE` (device is already live)
  - `TC_DEVICE_ONBOARDING_IN_PROGRESS` (test dispatch already in progress)
  - `TC_DEVICE_RETIRED` (device is retired)
  - `TC_DEVICE_SUSPENDED` (device is suspended)
  - `TC_DEVICE_DISCONNECTED` (device is disconnected)
  - `TC_DEVICE_AWAY_FROM_HOME` (device is away from home)
  - `TC_DEVICE_NO_LOCATION_CONFIGURED` (device has no location configured)
  - `TC_DEVICE_LOCATION_UNABLE_TO_IDENTIFY` (unable to identify device location)
  - `TC_DEVICE_LOCATION_MISSING` (device location is missing)

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4355: Unable to trigger charge.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  triggerTestCharge(input: AccountNumberInput): PerformTestCharge

  """
  Initiate a boost charge for an electric vehicle (EV).

  This will start charging the EV and will not stop until the battery reaches 100% charged.

  If it is not possible to initiate a boost charge, a KT-CT-4357 error will be returned.
  It may have a `boostChargeRefusalReasons` extension which lists the reasons why the boost
  charge was refused. Possible reasons include:

  - `BC_DEVICE_NOT_YET_LIVE` (device is not yet live)
  - `BC_DEVICE_RETIRED` (device is retired)
  - `BC_DEVICE_SUSPENDED` (device is suspended)
  - `BC_DEVICE_DISCONNECTED` (device is disconnected)
  - `BC_DEVICE_NOT_AT_HOME` (device is not at home)
  - `BC_BOOST_CHARGE_IN_PROGRESS` (boost charge already in progress)

  The possible errors that can be raised are:

  - KT-CT-4356: A boost charge cannot currently be performed.
  - KT-CT-4357: Unable to trigger boost charge.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  triggerBoostCharge(input: AccountNumberInput): PerformBoostCharge

  """
  Stop any active boost charging.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4354: Unable to cancel boost charge.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  deleteBoostCharge(input: DeleteBoostChargeInput): DeleteBoostCharge

  """
  Suspend control of the device.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4358: Unable to suspend device control.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  suspendControl(input: AccountNumberInput): SuspendDeviceControl

  """
  Resume control of the device.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4359: Unable to resume device control.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  resumeControl(input: AccountNumberInput): ResumeDeviceControl

  """
  Trigger OCPP authentication.

  The possible errors that can be raised are:

  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-4310: Unable to register OCPP authentication details.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  ocppAuthentication(input: OCPPAuthenticationInput): OCPPAuthentication

  """
  Turn a hot water device on or off.

  The possible errors that can be raised are:

  - KT-CT-4329: Invalid data.
  - KT-CT-4346: Unable to set the room temperature.
  - KT-CT-7223: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setRoomTemperature(input: RoomTemperatureInput): SetRoomTemperature

  """
  Turn a hot water device on or off.

  The possible errors that can be raised are:

  - KT-CT-4336: Unable to set hot water state.
  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setHotWaterState(input: HotWaterStateInput): SetHotWaterState

  """
  Turn a hot water device on or off.

  The possible errors that can be raised are:

  - KT-CT-4337: Unable to set climate control state.
  - KT-CT-4301: Unable to find device for given account.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setClimateControlState(input: ClimateControlStateInput): SetClimateControlState

  """
  Register a heat pump for an account.

  The possible errors that can be raised are:

  - KT-CT-4316: Unable to get provider details.
  - KT-CT-4317: Unable to register device.
  - KT-CT-4330: Invalid data.
  - KT-CT-4331: Invalid data.
  - KT-CT-4335: Another device registration is already in progress.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  registerHeatPump(input: RegisterHeatPumpInput): RegisterHeatPump @deprecated(reason: "The 'registerHeatPump' field is deprecated.\n\nPlease use `DeviceRegistration` instead of this endpoint.\n\n- Marked as deprecated on 2024-01-08.\n- Will be removed on 2024-07-01.")

  """
  Request a certificate to provision a heating controller.

  The possible errors that can be raised are:

  - KT-CT-4332: Invalid data.
  - KT-CT-4304: Error in preprovisioning step for Octopus Heat Pump.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  requestProvisioningClaimCertificate(accountNumber: String!, "The primary key of a property you would like to associate with this controller." propertyId: ID, "Parameters requested by the app from the controller, required for Kraken Flex to authenticate the device." requestParameters: ProvisioningClaimRequestParameters!): RequestProvisioningClaimCertificate

  """
  Request a certificate to provision a heating controller.

  The possible errors that can be raised are:

  - KT-CT-4332: Invalid data.
  - KT-CT-4304: Error in preprovisioning step for Octopus Heat Pump.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpRequestProvisioningClaimCertificate(accountNumber: String!, "The primary key of a property you would like to associate with this controller." propertyId: ID, "Parameters requested by the app from the controller, required for Kraken Flex to authenticate the device." requestParameters: ProvisioningClaimRequestParameters!): RequestProvisioningClaimCertificate

  """
  Turn a specific heating controller zone ON/OFF, set it to AUTO mode or give it a BOOST.

  The possible errors that can be raised are:

  - KT-CT-4333: Invalid data.
  - KT-CT-4306: Error setting mode for heat pump controller zone.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setZoneMode("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The parameters required to instruct a specific zone operation." operationParameters: SetZoneModeParameters!): SetZoneMode

  """
  Turn a specific heating controller zone ON/OFF, set it to AUTO mode or give it a BOOST.

  The possible errors that can be raised are:

  - KT-CT-4333: Invalid data.
  - KT-CT-4306: Error setting mode for heat pump controller zone.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpSetZoneMode("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The parameters required to instruct a specific zone operation." operationParameters: SetZoneModeParameters!): SetZoneMode

  """
  De-provision a heating controller device.

  The possible errors that can be raised are:

  - KT-CT-4307: Error deprovisioning an Octopus heat pump.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  deprovisionHeatingController("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!): DeprovisionHeatingController

  """
  De-provision a heating controller device.

  The possible errors that can be raised are:

  - KT-CT-4307: Error deprovisioning an Octopus heat pump.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpDeprovisionHeatingController("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!): DeprovisionHeatingController

  """
  Add schedules for a heating controller zone.

  The possible errors that can be raised are:

  - KT-CT-4334: Invalid data.
  - KT-CT-4308: Error setting schedule(s) for heat pump controller zone.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setZoneSchedules("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The parameters required to add schedule(s) for a specific zone." zoneScheduleParameters: SetZoneSchedulesParameters!): SetZoneSchedules

  """
  Add schedules for a heating controller zone.

  The possible errors that can be raised are:

  - KT-CT-4334: Invalid data.
  - KT-CT-4308: Error setting schedule(s) for heat pump controller zone.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpSetZoneSchedules("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The parameters required to add schedule(s) for a specific zone." zoneScheduleParameters: SetZoneSchedulesParameters!): SetZoneSchedules

  """
  Remove a sensor from a heating controller device.

  The possible errors that can be raised are:

  - KT-CT-4309: Error trying to remove sensor from heat pump controller.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  removeSensor("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The sensor ID of heat pump controller's sensor to be removed." sensorId: String!): RemoveSensor

  """
  Remove a sensor from a heating controller device.

  The possible errors that can be raised are:

  - KT-CT-4309: Error trying to remove sensor from heat pump controller.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpRemoveSensor("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The sensor ID of heat pump controller's sensor to be removed." sensorId: String!): RemoveSensor

  """
  Update the display name of a sensor.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  updateSensorDisplayName("The account number." accountNumber: String!, "The new display name." displayName: String!, "The EUID of the heat pump controller." euid: ID!, "The code of the sensor to rename (such as 'SENSOR01')." sensorCode: String!): UpdateSensorDisplayName

  """
  Update the display name of a sensor.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpUpdateSensorDisplayName("The account number." accountNumber: String!, "The new display name." displayName: String!, "The EUID of the heat pump controller." euid: ID!, "The code of the sensor to rename (such as 'SENSOR01')." sensorCode: String!): UpdateSensorDisplayName

  """
  Set the temperature for the hot water.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  updateWaterSetpoint("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The temperature to set the water to." setpoint: Int!): UpdateWaterSetpoint

  """
  Set the temperature for the hot water.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpUpdateWaterSetpoint("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The temperature to set the water to." setpoint: Int!): UpdateWaterSetpoint

  """
  Update the display name of multiple sensors.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  bulkUpdateSensorDisplayName("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "A list of sensor codes and display names to set." updates: [SensorDisplayNameUpdate]!): BulkUpdateSensorDisplayName

  """
  Update the display name of multiple sensors.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpBulkUpdateSensorDisplayName("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "A list of sensor codes and display names to set." updates: [SensorDisplayNameUpdate]!): BulkUpdateSensorDisplayName

  """
  Reboot the given heating controller.

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpRebootController("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!): RebootHeatingController

  """
  Set the primary sensor for a zone.

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpSetZonePrimarySensor("The account number." accountNumber: String!, "The EUID of the heat pump controller." euid: ID!, "The parameters required to set a new primary sensor for a zone." operationParameters: SetZonePrimarySensorParameters!): SetZonePrimarySensor

  """
  Update the flow temperature settings for the heat pump.

  The possible errors that can be raised are:

  - KT-CT-4321: Serializer validation error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  octoHeatPumpUpdateFlowTemperatureConfiguration("The EUID of the heat pump controller." euid: ID!, "Flow temperature configuration parameters." flowTemperatureInput: FlowTemperatureInput!): UpdateFlowTemperatureConfiguration

  """
  Enroll account up to Fan Club.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-8104: Account already enrolled.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  enrollFanClubAccount("Input fields for joining the Fan Club." input: JoinFanClubInput!): EnrollFanClubAccount

  """
  Send notification of likely Fan Club discount.

  The possible errors that can be raised are:

  - KT-CT-8106: No catchments provided.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  fanClubDiscountNotification("Input fields for sending Fan Club discount notifications." input: FanClubDiscountNotificationInput!): FanClubDiscountNotification

  createAccountFileAttachment(input: CreateAccountFileAttachmentInput!): CreateAccountFileAttachmentPayload!

  """
  The possible errors that can be raised are:

  - KT-CT-8710: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  triggerPostUploadOperations(s3Key: String!): TriggerPostUploadOperations!

  """
  Submit a spin of the Wheel of Fortune for the given account and supply type.

  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-CT-7011: Terms must be accepted.
  - KT-CT-7023: Unauthorized.
  - KT-CT-7010: The account does not have any available submissions.
  - KT-CT-7012: Wheel of Fortune submission error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  spinWheelOfFortune("Input fields for creating a Wheel of Fortune submission." input: WheelOfFortuneSpinInput!): SpinWheelOfFortune

  """
  Do a product switch for a user.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-4619: Quote with given code not found.
  - KT-CT-4624: Unable to accept the given product code.
  - KT-CT-4626: No product selected for the given quote code.
  - KT-CT-4719: No supply point found for identifier provided.
  - KT-CT-4922: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  initiateProductSwitch("Instigate a product switch for a specific supply point given a valid product and account number." input: InitiateProductSwitchInput!): InitiateProductSwitch

  """
  Create a lead.

  The possible errors that can be raised are:

  - KT-CT-8901: Unable to create lead.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createNewLead("Input fields for creating a lead." input: NewLeadInputType!): CreateNewLead

  """
  Publish a trigger within the transactional messaging service.

  The possible errors that can be raised are:

  - KT-CT-9901: Invalid trigger type code.
  - KT-CT-9902: Invalid trigger type params.
  - KT-CT-9903: Trigger type cannot be published externally.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  publishTransactionalMessagingTrigger("Input fields to publish a transactional messaging trigger." input: PublishTransactionalMessagingTriggerInput!): PublishTransactionalMessagingTrigger

  """
  Create a contribution agreement for an account.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-9601: Invalid data.
  - KT-CT-9602: Unable to create contribution agreement.
  - KT-CT-9605: Contribution amount cannot be 0 or negative.
  - KT-CT-9606: Scheme is not accepting contributions at this time.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createContributionAgreement("Input variables needed for creating a contribution agreement on an account." input: CreateContributionAgreementInput!): CreateContributionAgreement

  """
  End a contribution agreement for an account.

  The possible errors that can be raised are:

  - KT-CT-9603: Unable to find contribution agreement.
  - KT-CT-4123: Unauthorized.
  - KT-CT-9604: Unable to end contribution agreement.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  endContributionAgreement("Input variables needed for ending a contribution agreement on an account." input: EndContributionAgreementInput!): EndContributionAgreement

  """
  Redeem the passed number of Loyalty Points as account credit.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-9201: No Loyalty Point ledger found for the user.
  - KT-CT-9202: Loyalty Points adapter not configured.
  - KT-CT-9203: No ledger entries for the ledger.
  - KT-CT-9205: Insufficient Loyalty Points.
  - KT-CT-9206: Indivisible points.
  - KT-CT-9204: Negative or zero points set.
  - KT-CT-9208: Invalid posted at datetime.
  - KT-CT-9209: Negative Loyalty Points balance.
  - KT-CT-9210: Unhandled Loyalty Points exception.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  redeemLoyaltyPointsForAccountCredit("Input fields for redeeming Loyalty Points." input: RedeemLoyaltyPointsInput!): RedeemLoyaltyPointsForAccountCredit

  """
  Transfer Loyalty Point from one account user to another.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-9205: Insufficient Loyalty Points.
  - KT-CT-9204: Negative or zero points set.
  - KT-CT-9208: Invalid posted at datetime.
  - KT-CT-9209: Negative Loyalty Points balance.
  - KT-CT-9210: Unhandled Loyalty Points exception.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  transferLoyaltyPointsBetweenUsers("Input fields for transferring Loyalty Points." input: TransferLoyaltyPointsBetweenUsersInput!): TransferLoyaltyPointsBetweenUsers

  """
  Set the Loyalty Point user for the account.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-1111: Unauthorized.
  - KT-CT-9210: Unhandled Loyalty Points exception.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  setLoyaltyPointsUser("Input fields for setting the Loyalty Points user." input: SetLoyaltyPointsUserInput!): SetLoyaltyPointsUser

  """
  Create a referral using an email address, personal link or code.

  The possible errors that can be raised are:

  - KT-CT-6723: Unauthorized.
  - KT-CT-6710: Unable to create referral.
  - KT-CT-6711: Accounts may not self-refer.
  - KT-CT-6713: Referring and referred account brands do not match.
  - KT-CT-6712: Invalid reference.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createReferral("Input fields for creating a referral." input: CreateReferralInput!): CreateReferral

  """
  Redeem the referral claim code from certain referral scheme.

  The possible errors that can be raised are:

  - KT-CT-6723: Unauthorized.
  - KT-CT-6724: Referral claim code not found.
  - KT-CT-6725: Referral claim code redeeming error.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  redeemReferralClaimCode("Input fields for redeeming referral code." input: RedeemReferralClaimCodeInput!): RedeemReferralClaimCode

  """
  Mutation to create a new portfolio user role. This will effectively link the user to the portfolio giving them all the permissions enabled for the specific role.

  The possible errors that can be raised are:

  - KT-CT-9403: Received an invalid portfolioId.
  - KT-CT-9404: Received an invalid accountUserId.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createPortfolioUserRole("Input fields for connecting a user to a portfolio." input: CreatePortfolioUserRoleInput): CreatePortfolioUserRole

  """
  Mutation to create a new Portfolio instance.

  The possible errors that can be raised are:

  - KT-CT-9402: Received an invalid brandCode.
  - KT-CT-9401: Received an invalid operationsTeamId.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createPortfolio("Input fields for creating a portfolio." input: CreatePortfolioInput): CreatePortfolio

  """
  Close the Open Print Batch if any.

  The possible errors that can be raised are:

  - KT-CT-9010: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  closeOpenPrintBatch: CloseOpenPrintBatch!

  """
  Mark the print batch as processed.

  The possible errors that can be raised are:

  - KT-CT-9011: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  markPrintBatchAsProcessed(printBatchId: ID!): MarkPrintBatchAsProcessed!

  """
  Create or update a loyalty card for the given account user.

  The possible errors that can be raised are:

  - KT-CT-5412: No account user exists with the given id.
  - KT-CT-8610: Invalid data.
  - KT-CT-8611: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createOrUpdateLoyaltyCard("Input fields for creating or updating a loyalty card." input: CreateOrUpdateLoyaltyCardInput!): CreateOrUpdateLoyaltyCardMutation

  """
  Link an account user and line user together.
  """
  linkUserToLine("Input fields to link an account user with LINE." input: LinkUserToLineInput!): LinkUserToLineResponse!

  """
  Unlink an account user and line together.
  """
  unlinkUserFromLine: UnlinkUserFromLineResponse!

  """
  Instigate a leave supplier process or update an existing process.

  The possible errors that can be raised are:

  - KT-CT-10304: Mutation not enabled in this environment.
  - KT-CT-4501: Unauthorized.
  - KT-CT-1602: Serializer validation error.
  - KT-JP-8801: Supply point not found.
  - KT-CT-10301: Unable to instigate leave supplier process.
  - KT-CT-10309: Failed to update leave supplier process - the service is not enabled.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  instigateLeaveSupplier(input: LeaveSupplierInput!): LeaveSupplierInstigated!

  """
  Cancel a leave supplier process.

  The possible errors that can be raised are:

  - KT-CT-10304: Mutation not enabled in this environment.
  - KT-CT-10302: Invalid data.
  - KT-CT-10305: Failed to cancel leave supplier process - market actions are no longer cancellable.
  - KT-CT-10306: Failed to cancel leave supplier process - the cancellation workflow has not been configured.
  - KT-CT-10307: Failed to cancel leave supplier process - failed to cancel market actions.
  - KT-CT-10308: Failed to cancel leave supplier process.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  cancelLeaveSupplier(input: CancelLeaveSupplierInput!): LeaveSupplierCancelled!

  """
  Prepare account for sign up. Returns the existing account and/or user if matching datafound for the provided input, otherwise creates a new account and account user.

  The possible errors that can be raised are:

  - KT-CT-10303: Mutation not enabled in this environment.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  prepareAccount(input: PrepareAccountInput!): PrepareAccountResult!

  """
  Create an affiliate link for a new sales agent.

  The possible errors that can be raised are:

  - KT-CT-7711: Invalid data.
  - KT-CT-7713: Invalid data.
  - KT-CT-7714: Invalid data.
  - KT-CT-7715: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAffiliateLink("Input fields for creating an affiliate link for an organisation" input: CreateAffiliateLinkInputType!): CreateAffiliateLink!

  """
  Update an existing affiliate link.

  The possible errors that can be raised are:

  - KT-CT-7711: Invalid data.
  - KT-CT-7713: Invalid data.
  - KT-CT-7714: Invalid data.
  - KT-CT-7715: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateAffiliateLink("Input fields for Updating an existing affiliate link" input: UpdateAffiliateLinkInputType!): UpdateAffiliateLink!

  """
  Create an affiliate organisation.

  The possible errors that can be raised are:

  - KT-CT-7716: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAffiliateOrganisation("Input fields for creating an affiliate organisation" input: CreateAffiliateOrganisationInputType!): CreateAffiliateOrganisation!

  """
  Update an existing affiliate organisation.

  The possible errors that can be raised are:

  - KT-CT-7717: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateAffiliateOrganisation("Input fields for Updating an existing affiliate organisation" input: UpdateAffiliateOrganisationInputType!): UpdateAffiliateOrganisation!

  """
  Create a session for an affiliate link.
  """
  createAffiliateSession("Input fields for creating a session for an affiliate link" input: CreateAffiliateSessionInputType!): CreateAffiliateSession!

  """
  Validate user's email address.
  """
  validateEmail(input: ValidateEmailInput!): ValidateEmail

  """
  Validate user's phone number.
  """
  validatePhone(input: ValidatePhoneNumberInput!): ValidatePhone

  """
  Look up an event to perform from its event_id, and return the next action to perform.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-8002: No event found.
  - KT-CT-8003: Event has no execute function.
  - KT-CT-8004: Error executing event in the backend.
  - KT-CT-8007: Incorrect or missing parameters for backend screen event.
  - KT-GB-9310: Account ineligible for joining Octoplus.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  backendScreenEvent("Input fields for performing a backend action." input: BackendScreenEventInput!): BackendScreenEvent

  """
  Create metadata on an object.

  The possible errors that can be raised are:

  - KT-CT-8412: Invalid data.
  - KT-CT-8414: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createMetadata("Input fields for creating metadata." input: MetadataInput!): CreateMetadata

  """
  Update metadata on an object.

  The possible errors that can be raised are:

  - KT-CT-8413: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateMetadata("Input fields for updating metadata." input: MetadataInput!): UpdateMetadata

  """
  Submit customer feedback.

  The possible errors that can be raised are:

  - KT-CT-5514: Unable to submit feedback.
  - KT-CT-5511: The feedback_id should be provided for feedback source.
  - KT-CT-5512: The feedback doesn't match the account.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  submitCustomerFeedback(input: CustomerFeedbackInputType!): SubmitCustomerFeedback

  """
  Submit a repayment request.

  The possible errors that can be raised are:

  - KT-CT-1132: Unauthorized.
  - KT-CT-3927: Invalid Amount.
  - KT-CT-3928: Idempotency key used for another repayment request.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  submitRepaymentRequest("Input fields for requesting a repayment." input: RequestRepaymentInputType!): SubmitRepaymentRequest

  """
  Cancel a repayment or refund request.

  The possible errors that can be raised are:

  - KT-CT-4231: Unauthorized.
  - KT-CT-3930: The repayment or refund request does not exist.
  - KT-CT-3931: This repayment or refund request cannot be cancelled.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  cancelRepaymentRequest("Input fields for cancelling a repayment request." input: CancelRepaymentRequestInputType!): CancelRepaymentRequest

  """
  Allow a repayment to be submitted.

  The possible errors that can be raised are:

  - KT-CT-3944: Account repayment does not exist.
  - KT-CT-3945: Unable to allow a repayment to be submitted.
  - KT-CT-3950: The provided reason text is too long.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  allowRepaymentSubmission("Input variable needed for allowing repayment submission." input: RepaymentInput!): AllowRepaymentSubmission

  """
  Block a repayment from being submitted.

  The possible errors that can be raised are:

  - KT-CT-3944: Account repayment does not exist.
  - KT-CT-3946: Unable to block a repayment from being submitted.
  - KT-CT-3950: The provided reason text is too long.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  blockRepaymentSubmission("Input variable needed for blocking repayment submission." input: RepaymentInput!): BlockRepaymentSubmission

  """
  Approve a repayment.

  The possible errors that can be raised are:

  - KT-CT-3934: Repayment request already approved.
  - KT-CT-3935: Repayment request cannot be paid.
  - KT-CT-3959: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  approveRepayment("Input fields for approving a repayment." input: ApproveRepaymentInput!): ApproveRepayment

  """
  Collect deposit for the given account.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-5711: No collection is required.
  - KT-CT-5712: Deposit agreement does not exist or has not been accepted.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  collectDeposit(input: CollectDepositInput!): CollectDeposit

  """
  Record the customer's acceptance of a deposit agreement.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  recordDepositAgreementAccepted(input: DepositAgreementInput!): RecordDepositAgreementAccepted

  """
  Create a new deposit agreement for the account if it needs one.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createDepositAgreement(input: CreateDepositAgreementInput!): CreateDepositAgreement

  """
  Initiate a standalone payment and return the client secret required to complete it.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-3943: Invalid ledger.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  initiateStandalonePayment("Input fields for initiating a standalone payment." input: InitiateStandalonePaymentInput!): InitiateStandalonePayment

  """
  Initiate a standalone payment and return the url where the customer can complete it.

  The possible errors that can be raised are:

  - KT-CT-1128: Unauthorized.
  - KT-CT-3822: Unauthorized.
  - KT-CT-3943: Invalid ledger.
  - KT-CT-3957: No collection method provided.
  - KT-CT-3958: Provide either ledger ID or ledger number.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  initiateHostedStandalonePayment("Input fields for initiating a standalone payment." input: InitiateHostedStandalonePaymentInput!): InitiateHostedStandalonePayment

  """
  Get the client secret needed to create a new payment instruction using an embedded form.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  getEmbeddedSecretForNewPaymentInstruction("Input fields for getting the client secret for an embedded new card payment method form." input: GetEmbeddedSecretForNewPaymentInstructionInput!): GetEmbeddedSecretForNewPaymentInstruction

  """
  Store a new payment instruction created through the embedded process.

  The possible errors that can be raised are:

  - KT-CT-4177: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  storePaymentInstruction("Input fields for storing a new payment instruction created through the embedded process." input: StorePaymentInstructionInput!): StorePaymentInstruction

  """
  Get the external URL where the user can set up a payment instruction.

  The possible errors that can be raised are:

  - KT-CT-1128: Unauthorized.
  - KT-CT-3822: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  getHostedUrlForNewPaymentInstruction("Input fields for getting the external URL for setting up a payment instruction." input: GetHostedUrlForNewPaymentInstructionInput!): GetHostedUrlForNewPaymentInstruction

  """
  Invalidate an existing instruction.

  The possible errors that can be raised are:

  - KT-CT-3926: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  invalidatePaymentInstruction("Input fields for invalidating a payment instruction from an embedded form." input: InvalidatePaymentInstructionInput!): InvalidatePaymentInstruction

  """
  Set up a new direct debit instruction.

  The possible errors that can be raised are:

  - KT-CT-3940: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  setUpDirectDebitInstruction("Input fields for creating a new direct debit instruction" input: SetUpDirectDebitInstructionInput!): SetUpDirectDebitInstruction

  """
  Attempt to collect a one-off payment. If an instruction type is provided and there is an existing payment instruction, the payment can be collected immediately. A request to collect a payment at a future date can also be made, in which case the instruction input type is not necessary, but an instruction must exist at the specified collection date for the payment to be collected successfully.

  The possible errors that can be raised are:

  - KT-CT-3932: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  collectPayment("Input fields for collecting a payment." input: CollectPaymentInput!): CollectPayment

  """
  Amend an existing payment.

  The possible errors that can be raised are:

  - KT-CT-3924: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  amendPayment("Input fields for amending an existing payment." input: AmendPaymentInput!): AmendPayment

  """
  Change the auto top up amount for the payment schedule.

  The possible errors that can be raised are:

  - KT-CT-3815: No active payment schedule found for this account.
  - KT-CT-3941: Invalid data.
  - KT-CT-3942: An unexpected error occurred.
  - KT-CT-3947: An unexpected error occurred.
  - KT-CT-3953: The payment schedule is not a balance triggered schedule.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateAutoTopUpAmount("Input fields for updating the auto-top-up amount for a schedule." input: UpdateAutoTopUpAmountInput!): UpdateAutoTopUpAmount

  """
  Replace an existing payment schedule with a new one that updates either the payment amount or payment day.

  The possible errors that can be raised are:

  - KT-CT-1111: Unauthorized.
  - KT-CT-3815: No active payment schedule found for this account.
  - KT-CT-3822: Unauthorized.
  - KT-CT-3923: Unauthorized.
  - KT-CT-3941: Invalid data.
  - KT-CT-3942: An unexpected error occurred.
  - KT-CT-3947: An unexpected error occurred.
  - KT-CT-3960: Invalid value for payment day.
  - KT-CT-3961: Cannot update plan-associated payment schedule.
  - KT-CT-3962: No new value provided to update payment schedule.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAccountPaymentSchedule("Input fields for updating a payment schedule." input: CreateAccountPaymentScheduleInput!): CreateAccountPaymentSchedule

  """
  Cancel an in-flight payment.

  The possible errors that can be raised are:

  - KT-CT-3924: Unauthorized.
  - KT-CT-3954: Payment cancellation failed.
  - KT-CT-3955: Payment cannot be cancelled.
  - KT-CT-3956: Temporary error occurred.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  cancelPayment("Input fields for cancelling a pending payment." input: CancelPaymentInput!): CancelPayment

  """
  Refund a cleared payment.

  The possible errors that can be raised are:

  - KT-CT-3924: Unauthorized.
  - KT-CT-3928: Idempotency key used for another repayment request.
  - KT-CT-3929: The payment is not in a refundable state.
  - KT-CT-3933: Refund amount greater than payment amount.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  refundPayment("Input fields for refunding a payment." input: RefundPaymentInput!): RefundPayment

  assignInkBucket(input: AssignInkBucketInput!): AssignInkBucketPayload

  updateMessageTags(input: UpdateMessageTagsInput!): UpdateMessageTagsPayload

  """
  Register an Ink inbound message.
  """
  createInkInboundMessage(input: CreateInkInboundMessageInput!): CreateInkInboundMessagePayload

  """
  The possible errors that can be raised are:

  - KT-CT-7620: Channel not supported.
  - KT-CT-7618: Unable to process message.
  - KT-CT-7624: Error when generating the presigned URL.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  generateInkPresignedUrl(input: GenerateInkPresignedUrlInput): GenerateInkPresignedUrl

  """
  Create a goods quote.

  The possible errors that can be raised are:

  - KT-CT-8202: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createGoodsQuote("Input fields for creating a goods quote." input: CreateGoodsQuoteInput!): CreateGoodsQuote

  """
  Create a goods quote without an account.

  The possible errors that can be raised are:

  - KT-CT-8202: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createGoodsQuoteWithoutAccount("Input fields for creating a goods quote without an existing account." input: CreateGoodsQuoteWithoutAccountInput!): CreateGoodsQuoteWithoutAccount

  """
  Accept a goods quote.

  The possible errors that can be raised are:

  - KT-CT-8223: Unauthorized.
  - KT-CT-8201: Received an invalid quoteId.
  - KT-CT-8224: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  acceptGoodsQuote("Input fields for accepting a quote." input: AcceptGoodsQuoteInput!): AcceptGoodsQuote

  """
  Share a goods quote.

  The possible errors that can be raised are:

  - KT-CT-4122: Invalid email.
  - KT-CT-8203: Received an invalid quote code.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  shareGoodsQuote("Input fields for sharing a quote." input: ShareGoodsQuoteInput!): ShareGoodsQuote

  """
  Create a goods purchase.

  The possible errors that can be raised are:

  - KT-CT-8206: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createGoodsPurchase("Input fields for creating a purchase without a quote." input: CreatePurchaseInput!): CreateGoodsPurchase

  """
  Verify user's email address.

  The possible errors that can be raised are:

  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  verifyEmail(input: VerifyEmailInput!): VerifyEmail

  """
  Create an account reminder.

  The possible errors that can be raised are:

  - KT-CT-1401: Invalid data.
  - KT-CT-1402: Unable to create account reminder.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAccountReminder("Input variables needed for creating an account reminder." input: CreateAccountReminderInput!): CreateAccountReminder

  """
  Create an account reference.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-8310: Invalid data.
  - KT-CT-8311: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAccountReference("Input fields for creating an account reference." input: AccountReferenceInput!): CreateAccountReference

  """
  Update an account reference.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-8310: Invalid data.
  - KT-CT-8311: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateAccountReference("Input fields for updating an account reference." input: AccountReferenceInput!): UpdateAccountReference

  """
  Delete an account reference.

  The possible errors that can be raised are:

  - KT-CT-4123: Unauthorized.
  - KT-CT-8310: Invalid data.
  - KT-CT-8312: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  deleteAccountReference("Input fields for removing an account reference." input: DeleteAccountReferenceInput!): DeleteAccountReference

  """
  Create an external account event.

  The possible errors that can be raised are:

  - KT-CT-7123: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createExternalAccountEvent("Input fields for creating an external account event." input: CreateExternalAccountEventInput!): CreateExternalAccountEvent

  """
  Add credit to an account.

  The possible errors that can be raised are:

  - KT-CT-5315: Invalid data.
  - KT-CT-5314: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAccountCredit("Input fields for creating an account credit." input: CreateAccountCreditInput!): CreateAccountCredit @deprecated(reason: "The 'createAccountCredit' field is deprecated.\n\nUse postCredit mutation as it is ledger aware.\n\n- Marked as deprecated on 2022-07-04.\n- Will be removed on 2024-01-01.")

  """
  Post credit to a ledger.

  The possible errors that can be raised are:

  - KT-CT-5316: Invalid data.
  - KT-CT-5311: The credit reason with the requested code is deprecated.
  - KT-CT-5312: The credit reason with the requested code does not exist.
  - KT-CT-5313: An error occurred whilst posting the credit.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  postCredit("Input fields for posting a credit." input: PostCreditInput!): PostCredit

  """
  Add charge to an account.

  The possible errors that can be raised are:

  - KT-CT-5211: The charge reason with the requested code is deprecated.
  - KT-CT-5212: The charge reason with the requested code does not exist.
  - KT-CT-5213: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createAccountCharge("Input fields for creating an account charge." input: CreateAccountChargeInput!): CreateAccountCharge

  """
  Transfer value from a source ledger to a destination ledger. This decreases the balance of the source ledger by the given amount and increases the balance of the destination ledger by the same amount. If the amount is negative, the effect is reversed (the source ledger's balance increases and the destination ledger's balance decreases).



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-CT-3822: Unauthorized.
  - KT-CT-3823: Unauthorized.
  - KT-CT-9701: Balance transfer to same account is not allowed.
  - KT-CT-9702: Balance transfer is not support for debit account with Zero balance.
  - KT-CT-9703: Balance transfer is not supported for debit account.
  - KT-CT-9704: Balance transfer amount should be non-zero.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  transferLedgerBalance("Input fields for processing an account balance transfer." input: TransferLedgerBalanceInputType!): TransferLedgerBalance

  """
  Create a "form submission" entity. This is only meant to be used as a quick way of putting together a form and submit data for it, in the form of JSON - it is not expected that all form submissions will come through this path.

  This field requires the `Authorization` header to be set. 

  """
  createFormSubmission(input: FormSubmissionInput!): FormSubmissionOuput

  """
  Provide a temporary token to get an auth token. This is intended to allow support users to view customer data through the brand interface.
  """
  masqueradeAuthentication("The masquerade token issued by the support site." masqueradeToken: String!, "The ID of the AccountUser to masquerade as." userId: String!): MasqueradeAuthentication

  """
  Generate a pre-signed token with a set expiry time.

  The possible errors that can be raised are:

  - KT-CT-1128: Unauthorized.
  - KT-CT-1120: The Kraken Token has expired.
  - KT-CT-1131: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  generatePreSignedToken(email: String!, "The number of days that the token will be available for authentication (From now on)." numberOfDaysAllowed: Int!, "Define (and limit) the scope of the token." scope: PreSignedTokenScope!): GeneratePreSignedToken

  """
  Invalidate a previously-issued pre-signed token.

  The possible errors that can be raised are:

  - KT-CT-1129: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  invalidatePreSignedToken(input: InvalidatePreSignedTokenInput!): InvalidatePreSignedToken

  """
  Invalidate pre-signed tokens issued to a particular user.

  The possible errors that can be raised are:

  - KT-CT-1129: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  invalidatePreSignedTokensForUser(input: InvalidatePreSignedTokensForUserInput!): InvalidatePreSignedTokensForUser

  """
  Provide the email address of an account user to send them an email with instructions on how to reset their password.

  The possible errors that can be raised are:

  - KT-CT-1133: Unable to request password reset email.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  requestPasswordReset("Input fields for requesting a password reset email." input: RequestPasswordResetInput!): RequestPasswordResetOutputType

  """
  Reset the password of an account user indicated by the userId to the value supplied.
  """
  resetPassword(input: ResetPasswordMutationInput!): ResetPasswordMutationPayload

  """
  Reset the password of an account user.

  The possible errors that can be raised are:

  - KT-CT-4125: Unauthorized.
  - KT-CT-1132: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  resetUserPassword("Input fields for resetting an account user's password." input: ResetUserPasswordInput!): ResetUserPasswordOutput

  """
  Create a Kraken Token (JWT) for authentication.  

  Provide the required input fields to obtain the token. 

  The token should be used as the `Authorization` header for any authenticated requests.

  The possible errors that can be raised are:

  - KT-CT-1135: Invalid data.
  - KT-CT-1134: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  obtainKrakenToken("Input fields that can be used to obtain a Json Web Token (JWT) for authentication to the API." input: ObtainJSONWebTokenInput!): ObtainKrakenJSONWebToken

  """
  Force users of Kraken Tokens and refresh tokens issued to the viewer to reauthenticate.

  Calling this mutation will cause all Kraken Tokens and refresh tokens issued to the authenticated viewer before the mutation was called to become invalid.
  """
  forceReauthentication("Input object argument to the force-reauthentication mutation." input: ForceReauthenticationInput!): ForceReauthentication

  """
  For authorized third-party organizations only.

  The possible errors that can be raised are:

  - KT-CT-1120: The Kraken Token has expired.
  - KT-CT-1121: Please use Kraken Token to issue long-lived refresh tokens.
  - KT-CT-1132: Unauthorized.
  - KT-CT-1122: Long-lived refresh tokens can only be issued for account users.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  obtainLongLivedRefreshToken("Input fields for obtaining a long-lived refresh token to extend the expiry claim of a Kraken token." input: ObtainLongLivedRefreshTokenInput!): ObtainLongLivedRefreshToken

  """
  Invalidate a previously-issued refresh token.

  The possible errors that can be raised are:

  - KT-CT-1130: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  invalidateRefreshToken(input: InvalidateRefreshTokenInput!): InvalidateRefreshToken

  """
  Invalidate refresh tokens issued to a particular user.

  The possible errors that can be raised are:

  - KT-CT-1128: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  invalidateRefreshTokensForUser(input: InvalidateRefreshTokensForUserInput!): InvalidateRefreshTokensForUser

  """
  Provide identifying information about an account and user to get a scoped token that will permit access to associate an email address with the accounts user.

  The possible errors that can be raised are:

  - KT-CT-1145: Account/user details do not match.
  - KT-CT-1113: Disabled GraphQL field requested.
  """
  verifyIdentity("Details about the user to be verified." input: VerifyIdentityInput!): VerifyIdentity

  """
  Mutation to create a new APIException instance.

  The possible errors that can be raised are:

  - KT-CT-7801: Received an invalid operationsTeamId.
  - KT-CT-7802: The external identifier already exists.
  - KT-CT-7805: Too many tags associated with this API Exception.
  - KT-CT-7806: Cannot create duplicate tags for the same API exception.
  - KT-CT-7811: Received an invalid assignedUserId.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createApiException("Input fields for creating an API exception." input: CreateAPIExceptionInput!): CreateAPIException

  """
  Mutation to update an existing APIException instance.

  The possible errors that can be raised are:

  - KT-CT-7804: No fields present in the input for updating the APIException.
  - KT-CT-7803: Received an invalid apiExceptionId.
  - KT-CT-7809: Update results in no changes to API Exception.
  - KT-CT-7805: Too many tags associated with this API Exception.
  - KT-CT-7806: Cannot create duplicate tags for the same API exception.
  - KT-CT-7801: Received an invalid operationsTeamId.
  - KT-CT-7811: Received an invalid assignedUserId.
  - KT-CT-7812: Support user is inactive.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateApiException("Input fields for updating an API exception." input: UpdateAPIExceptionInput!): UpdateAPIException

  """
  Mutation to create a new APICall instance.

  The possible errors that can be raised are:

  - KT-CT-7803: Received an invalid apiExceptionId.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createApiCall("Input fields for creating an API call." input: CreateAPICallInput!): CreateAPICall

  """
  Mutation to create a new APIExceptionEvent instance.

  The possible errors that can be raised are:

  - KT-CT-7803: Received an invalid apiExceptionId.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createApiExceptionEvent("Input fields for creating an API exception event." input: CreateAPIExceptionEventInput!): CreateAPIExceptionEvent

  """
  Mutation to create a new APIExceptionNote instance.

  The possible errors that can be raised are:

  - KT-CT-7803: Received an invalid apiExceptionId.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  createApiExceptionNote("Input fields for creating an API exception note." input: CreateAPIExceptionNoteInput!): CreateAPIExceptionNote

  """
  Mutation to update an existing APIExceptionNote instance.

  The possible errors that can be raised are:

  - KT-CT-7807: Received an invalid apiExceptionNoteId.
  - KT-CT-7808: Unauthorized.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateApiExceptionNote("Input fields for creating an API exception note." input: UpdateAPIExceptionNoteInput!): UpdateAPIExceptionNote

  """
  **DEPRECATED: Please use updateUser instead**

  Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.
  """
  updateUserDetails(input: UpdateAccountUserMutationInput!): UpdateAccountUserMutationPayload @deprecated(reason: "The 'updateUserDetails' field is deprecated.\n\n\nPlease use the 'updateUser' mutation instead.\n\n\n- Marked as deprecated on 2020-10-02.\n- Will be removed on 2023-04-06.")

  """
  Update the comms preferences of the account user (the authenticated user).
  """
  updateCommsPreferences(input: UpdateAccountUserCommsPreferencesMutationInput!): UpdateAccountUserCommsPreferencesMutationPayload

  """
  Update password of the authenticated user.



  This field requires the `Authorization` header to be set. 

  """
  updatePassword(input: UpdatePasswordInput): UpdatePassword

  """
  Regenerate the live secret key for the authenticated user.
  """
  regenerateSecretKey: RegenerateSecretKey

  """
  Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-CT-5413: Invalid data.
  - KT-CT-5414: Invalid data.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  updateUser("Input fields for updating user." input: UpdateUserInput!): UpdateUserMutation

  """
  Register a device token to be used for push notifications for an app.



  This field requires the `Authorization` header to be set. 

  """
  registerPushNotificationBinding("Input fields for creating an push notification binding." input: RegisterPushNotificationBindingInput!): RegisterPushNotificationBinding

  """
  Delete a device token used for push notifications. 



  This field requires the `Authorization` header to be set. 



  The possible errors that can be raised are:

  - KT-CT-5411: Invalid token or no push notification binding found for the given account user.
  - KT-CT-1113: Disabled GraphQL field requested.
  - KT-CT-1111: Unauthorized.
  - KT-CT-1112: 'Authorization' header not provided.
  """
  deletePushNotificationBinding("Input fields for deleting a push notification binding." input: DeletePushNotificationBindingInput!): DeletePushNotificationBinding
}

"""
Calculates and records the deposit amount. returns the deposit amount and key

The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CalculateDepositAmount {
  possibleErrors: [PossibleErrorType]

  """
  Calculated deposit amount
  """
  depositAmount: Int

  """
  unique key of the record inserted in DepositAmount model
  """
  key: String
}

input CalculateDepositAmountInput {
  """
  provide the credit score of the business
  """
  creditScore: Int!

  """
  provide the monthly consumption amount
  """
  monthlyAmount: Int!
}

"""
The possible errors that can be raised are:

- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CheckBusinessCreditRisk {
  possibleErrors: [PossibleErrorType]

  """
  Credit Score as reported from Credit Risk engine.
  """
  creditScore: Int
}

input CheckBusinessCreditRiskInput {
  """
  Company registration number.
  """
  companyNumber: String!

  """
  Estimated Annual Consumption of the business in KWh.
  """
  eac: Int!
}

"""
Create one or more product rates for a product.

The possible errors that can be raised are:

- KT-GB-9514: No available product found.
- KT-GB-9518: Invalid input data for product rate(s).
- KT-GB-9519: Unable to create product rate(s).
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateProductRates {
  possibleErrors: [PossibleErrorType]

  """
  Successfully created rate(s) for the specified product.
  """
  productRates: [ProductRateType]
}

"""
A single product rate.
"""
type ProductRateType {
  validFrom: DateTime

  validTo: DateTime

  """
  The band category of the product rate.
  """
  bandCategory: String

  bandSubcategory: String!

  pricePerUnit: Decimal!

  """
  The gsp of the product rate.
  """
  gsp: String

  """
  The payment_method of the product rate.
  """
  paymentMethod: String
}

input CreateProductRatesInputType {
  """
  The product rate(s) to be created.
  """
  productRates: [ProductRateInputType]!
}

"""
Input type for creating a single product rate.
"""
input ProductRateInputType {
  """
  Date and time the product rate is effective from.
  """
  validFrom: DateTime!

  """
  Date and time the product rate is effective to.
  """
  validTo: DateTime

  """
  The band category of the product rate.
  """
  bandCategory: LimitedBandCategories!

  """
  The band subcategory of the product rate. For gas products, pass 'null'. For electricity products, select a subcategory.
  """
  bandSubcategory: AllBandSubCategories = null

  """
  The value of the product rate.
  """
  pricePerUnit: Decimal!

  """
  The GSP group id of the product rate.
  """
  gsp: GSPGroupIdsOptions!

  """
  The payment method of the product rate, if applicable.
  """
  paymentMethod: PaymentMethodChoices = null
}

"""
    Set of band categories that are currently
    supported for creating product rates.
    
"""
enum LimitedBandCategories {
  STANDING_CHARGE

  CONSUMPTION_CHARGE
}

"""
    Combined list of subcategories for both consumption and standing charges
    
"""
enum AllBandSubCategories {
  STANDARD

  ECO7_DAY

  ECO7_NIGHT

  THREE_RATE_PEAK

  THREE_RATE_OFF_PEAK

  THREE_RATE_SHOULDER

  ECONOMY7

  THREE_RATE
}

"""
An enumeration.
"""
enum GSPGroupIdsOptions {
  _A

  _B

  _C

  _D

  _E

  _F

  _G

  _H

  _J

  _K

  _L

  _M

  _N

  _P
}

type QuoteNewMeterPoints {
  """
  The generated quote.
  """
  quoteRequest: QuoteRequest
}

input QuoteNewMeterPointsInput {
  """
  A list of electricity meterpoints to create this quote for.
  """
  electricityMeterPointsInput: [ElectricityMeterPointInput!]

  """
  A list of gas meterpoints to create this quote for.
  """
  gasMeterPointsInput: [GasMeterPointInput!]

  """
  Additional context about the future account which is required to create the quote.
  """
  newAccountInput: NewAccountInput!

  """
  Only quote on products with these tags. If not provided, quote against all available products.
  """
  productTags: [String!]
}

input ElectricityMeterPointInput {
  """
  Must be provided if no custom consumption input is provided.
  """
  mpan: String

  """
  Annual consumption values for this meter point. Must be provided if no MPAN is provided.
  """
  consumption: ElectricityConsumptionInput

  """
  The meter type on this meter point. Must be provided if no MPAN is provided.
  """
  meterType: MeterType

  """
  The grid supply point ID of this meter point.
  """
  gspId: String

  """
  Should the meter point be quoted on a flat rate.
  """
  flatRate: Boolean
}

input ElectricityConsumptionInput {
  """
  Amount of electricity consumed.
  """
  standard: Int

  """
  Daily electricity consumption.
  """
  day: Int

  """
  Nightly electricity consumption.
  """
  night: Int

  """
  Off peak hours electricity consumption.
  """
  offPeak: Int

  """
  If the consumption values are estimated, set this to 'True'.
  """
  isEstimate: Boolean
}

enum MeterType {
  STANDARD

  ECONOMY7

  SMART

  SMART_ECONOMY7

  SMART_FLAT_ECONOMY7

  FLAT_ECONOMY7

  THREE_RATE

  FLAT_THREE_RATE
}

input GasMeterPointInput {
  """
  Must be provided if no custom consumption input is provided.
  """
  mprn: String

  """
  Annual consumption values for this meter point.
  """
  consumption: GasConsumptionInput

  """
  The grid supply point ID of this meter point.
  """
  gspId: String
}

input GasConsumptionInput {
  """
  Amount of gas consumed.
  """
  value: Int!

  """
  If the consumption values are estimated, set this to 'True'.
  """
  isEstimate: Boolean
}

input NewAccountInput {
  """
  Account type to quote for (e.g. Business or Domestic).
  """
  accountType: AccountTypeChoices!

  """
  Company brand to quote for.
  """
  brandCode: String!

  """
  Optional parameter for the payment method to quote for. Defaults to Direct Debit.
  """
  paymentMethod: PaymentMethodChoices

  """
  Optional ID of the affiliate session active when creating this quote.
  """
  affiliateSessionId: String
}

"""
The possible errors that can be raised are:

- KT-CT-4616: Unable to create a quote.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type QuoteNewMeterPointsOnBespokeProducts {
  possibleErrors: [PossibleErrorType]

  """
  The generated quote.
  """
  quoteRequest: QuoteRequest
}

input QuoteNewMeterPointsOnBespokeProductsInput {
  """
  A list of electricity meterpoints to create this quote for.
  """
  electricityMeterPointsInput: [ElectricityMeterPointProductsInput!]

  """
  A list of gas meterpoints to create this quote for.
  """
  gasMeterPointsInput: [GasMeterPointProductsInput!]

  """
  Data for creating a new account.
  """
  newAccountInput: NewAccountInput!
}

input ElectricityMeterPointProductsInput {
  """
  Must be provided if no custom consumption input is provided.
  """
  mpan: String

  """
  Annual consumption values for this meter point. Must be provided if no MPAN is provided.
  """
  consumption: ElectricityConsumptionInput

  """
  The meter type on this meter point. Must be provided if no MPAN is provided.
  """
  meterType: MeterType

  """
  The grid supply point ID of this meter point.
  """
  gspId: String

  """
  Should the meter point be quoted on a flat rate.
  """
  flatRate: Boolean

  """
  A list of products and optional product parameters to quote for.
  """
  productsInput: [ElectricityProductInput!]!
}

input ElectricityProductInput {
  """
  Code specifying the product to quote for.
  """
  code: String

  """
  Optional payment method to quote for.
  """
  paymentMethod: PaymentMethodChoices

  """
  Bespoke rates to override default electricity unit rates.
  """
  bespokeRates: ElectricityBespokeRates
}

input ElectricityBespokeRates {
  """
  Standard bespoke rate for electricity.
  """
  standard: Decimal

  """
  Daily bespoke rate for electricity.
  """
  day: Decimal

  """
  Nightly bespoke rate for electricity.
  """
  night: Decimal

  """
  Off peak rate for electricity.
  """
  offPeak: Decimal

  """
  Standing charge for electricity.
  """
  standingCharge: Decimal!
}

input GasMeterPointProductsInput {
  """
  Must be provided if no custom consumption input is provided.
  """
  mprn: String

  """
  Annual consumption values for this meter point.
  """
  consumption: GasConsumptionInput

  """
  The grid supply point ID of this meter point.
  """
  gspId: String

  """
  A list of products and optional product parameters to quote for.
  """
  productsInput: [GasProductInput!]!
}

input GasProductInput {
  """
  Code specifying the product to quote for.
  """
  code: String

  """
  Optional payment method to quote for.
  """
  paymentMethod: PaymentMethodChoices

  """
  Bespoke rates to override default gas unit rates.
  """
  bespokeRates: GasBespokeRates
}

input GasBespokeRates {
  """
  Standard bespoke rate for gas.
  """
  value: Decimal!

  """
  Standing charge for gas.
  """
  standingCharge: Decimal!
}

"""
The possible errors that can be raised are:

- KT-CT-4616: Unable to create a quote.
- KT-GB-4614: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type QuoteAccountOnProducts {
  possibleErrors: [PossibleErrorType]

  """
  The generated quote.
  """
  quoteRequest: QuoteRequest
}

input QuoteAccountOnProductsInput {
  """
  A list of electricity meterpoints to create this quote for.
  """
  electricityMeterPointsInput: [ElectricityMeterPointProductsInput!]

  """
  A list of gas meterpoints to create this quote for.
  """
  gasMeterPointsInput: [GasMeterPointProductsInput!]

  """
  Account number to create this quote for.
  """
  accountNumber: String!

  """
  Date at which the product switch takes effect.
  """
  at: DateTime!
}

type CreateRenewalQuoteRequest {
  quoteRequest: QuoteRequest
}

input CreateRenewalQuoteRequestInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The property id to create a quote request for.
  """
  propertyId: Int!

  """
  The date at which the agreements would be renewed.
  """
  renewalAt: DateTime!
}

"""
The possible errors that can be raised are:

- KT-GB-4624: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateQuoteRequestForProducts {
  possibleErrors: [PossibleErrorType]

  """
  Returns a quote request for the requested product codes. Does not persist the quote.
  """
  quoteRequest: QuoteRequestBase
}

type QuoteRequestBase {
  """
  List of electricity supply points and their quoted products.
  """
  electricitySupplyPoints: [ElectricitySupplyPoint]

  """
  List of gas supply points and their quoted products.
  """
  gasSupplyPoints: [GasSupplyPoint]

  createdAt: DateTime
}

input CreateQuoteRequestForProductsInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The property id to create a quote request for.
  """
  propertyId: Int!

  """
  The product codes of products to quote for.
  """
  productCodes: [String]!

  """
  The date at which the agreements would be renewed.
  """
  renewalAt: DateTime!

  """
  If the customer is currently on a flat rate tariff, create a flat rate quote.
  """
  persistFlatRate: Boolean

  """
  Optional parameter to override the payment method on the current agreement.
  """
  paymentMethod: PaymentMethodChoices
}

"""
The possible errors that can be raised are:

- KT-GB-4625: Unable to create quote request.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type CreateAcquisitionQuoteRequestForProducts {
  possibleErrors: [PossibleErrorType]

  """
  Returns a quote request for the requested product codes. Does not persist the quote.
  """
  quoteRequest: QuoteRequestBase
}

input CreateAcquisitionQuoteRequestForProductsInput {
  """
  The electricity meter points to create a quote request for.
  """
  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]

  """
  The gas meter points to create a quote request for.
  """
  gasMeterPoints: [GasMeterPointConsumptionInput]

  """
  The postcode of the meter points being quoted.
  """
  postcode: String!

  """
  The product codes of products to quote for.
  """
  productCodes: [String]!

  """
  Optional parameter for the payment method to quote for. Defaults to Direct Debit.
  """
  paymentMethod: PaymentMethodChoices = DIRECT_DEBIT
}

input ElectricityMeterPointConsumptionInput {
  profileClass: Int

  mpan: String

  isEstimate: Boolean!

  annualConsumptionStandard: Int

  annualConsumptionDay: Int

  annualConsumptionNight: Int
}

input GasMeterPointConsumptionInput {
  mprn: String

  isEstimate: Boolean!

  annualConsumption: Int
}

"""
Mutation for creating an refund request for an account.

The possible errors that can be raised are:

- KT-GB-4127: Unable to send refund request confirmation email.
- KT-GB-4121: Unable to process refund request.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateRefundRequest {
  possibleErrors: [PossibleErrorType]

  refundRequest: RefundRequestType
}

type RefundRequestType {
  """
  The requested refund amount which was submitted in the repayment.
  """
  requestedAmountToReturn: Int
}

"""
The input type for the refund request.
"""
input RefundRequestInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The requested refund amount.
  """
  requestedAmount: Int!
}

"""
Update smart meter data preferences of an account.

The possible errors that can be raised are:

- KT-CT-4023: Unauthorized.
- KT-GB-4015: Cannot update smart meter reading frequency preferences.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateSmartMeterDataPreferences {
  possibleErrors: [PossibleErrorType]

  preferencesUpdated: Boolean

  smartMeterDataPreferences: SmartMeterDataPreferencesType
}

input UpdateSmartMeterDataPreferencesInput {
  accountNumber: String!

  """
  The desired reading frequency for the smart meter.
  """
  readingFrequency: SmartMeterReadingFrequencyChoices!

  """
  The consent that smart meter readings can be used for further analysis
  """
  allowReadingsAnalysis: Boolean
}

"""
Send a request to the DCC to join a smart device to a HAN (Home Area Network).

The possible errors that can be raised are:

- KT-GB-4019: This device type is not currently supported.
- KT-GB-4020: Error sending the request to join the device to the Home Area Network.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type JoinDeviceToNetwork {
  possibleErrors: [PossibleErrorType]

  requestReference: String
}

"""
    Types of devices that can be joined to a HAN (Home Area Network).
    
"""
enum JoinableDeviceType {
  """
  Electricity meter.
  """
  ELECTRICITY_METER

  """
  Gas meter.
  """
  GAS_METER

  """
  HAN Connected Auxiliary Load Control Switch (HCALCS).
  """
  AUX_SWITCH

  """
  Pre-Payment Meter Interface Device.
  """
  PPMID

  """
  In-Home Display.
  """
  IHD
}

"""
The possible errors that can be raised are:

- KT-GB-4021: Invalid MPxN.
- KT-GB-4022: MPxN not recognised.
- KT-GB-4023: Error sending the request to commission the device.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CommissionMeter {
  possibleErrors: [PossibleErrorType]

  """
  The id of the SMETS Commission Request in Kraken.
  """
  requestReference: String
}

input CommissionMeterInput {
  mpxn: String

  """
  Device ID of the CHF (Communications Hub Function).
  """
  chfDeviceId: String!

  """
  Device ID (ESME or GSME) of the device being commissioned.
  """
  meterDeviceId: String!

  """
  Code provided by manufacturer as part of ASN data, and included as part of device pre-notification, which is required to authorise device commissioning.
  """
  installationCode: String!

  """
  Type of meter being commissioned
  """
  meterType: MeterTypeChoices!

  """
  Serial number for ESME or GSME devices.
  """
  serialNumber: String
}

"""
An enumeration.
"""
enum MeterTypeChoices {
  """
  Electricity meter.
  """
  ELECTRICITY_METER

  """
  Gas meter.
  """
  GAS_METER
}

"""
The possible errors that can be raised are:

- KT-GB-4024: The provided device ID does not match any devices known by Kraken.
- KT-GB-4025: Error sending the request to decommission the device.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type DecommissionSmartDevice {
  possibleErrors: [PossibleErrorType]

  """
  The reference of the Decommission Request in Kraken.
  """
  requestReference: String
}

input DecommissionSmartDeviceInput {
  """
  Device ID for the device being decommissioned.
  """
  deviceId: String!
}

"""
A request sent to notify Kraken of a new device, which will be prenotified to the adapter.
"""
type RegisterSmartDevice {
  """
  The reference for the associated request in Kraken.
  """
  requestReference: String
}

"""
This type is used by agent services to notify Kraken of a new device.
"""
input RegisterSmartDeviceInput {
  """
  The ID of the device to register.
  """
  deviceId: String!

  """
  MPID of the Meter Asset Provider for the device. Used with ESME or GSME devices.
  """
  mapMpid: String

  """
  Supplier associated with the device.
  """
  supplierMpid: String!

  """
  The 4-letter manufacturer code for the device.
  """
  deviceManufacturer: String!

  """
  Model of the device.
  """
  deviceModel: String!

  """
  Type of the device, e.g. ESME or GSME.
  """
  deviceType: String!

  """
  SMETS CHTS version number.
  """
  smetsChtsVersion: String

  """
  Installation code of the device.
  """
  installCode: String!

  """
  ESME variant for an ESME device.
  """
  esmeVariant: String

  """
  Serial number for ESME or GSME devices.
  """
  serialNumber: String

  """
  Firmware version number.
  """
  firmwareVersion: String
}

"""
Update the status of the communications hub.

The possible errors that can be raised are:

- KT-GB-4026: Either the mpxn or mpan input must be provided.
- KT-GB-4027: If both mpxn and mpan are provided, they must match.
- KT-GB-4028: Please input a valid MPxN.
- KT-GB-4029: Meter point not found for MPAN.
- KT-GB-4030: Meter point not found for MPRN.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateCommsHubStatus {
  possibleErrors: [PossibleErrorType]

  """
  The id of the Request object in Kraken.
  """
  requestReference: String
}

input UpdateCommsHubStatusInput {
  """
  Device ID of the CHF (Communications Hub Function).
  """
  chfDeviceId: String!

  """
  The type of status update to be sent.
  """
  updateType: CommsHubStatusUpdateType!

  """
  MPxN of a meter point linked to the CHF.
  """
  mpxn: String

  """
  MPAN of the meter point linked to the CHF.
  """
  mpan: String @deprecated(reason: "The 'mpan' field is deprecated.\n\nUse mpxn instead.\n\n- Marked as deprecated on 2022-11-07.\n- Will be removed on 2023-11-07.")

  """
  Is it a new or replacement CHF?
  """
  chfInstallType: CHFInstallType

  """
  Was an external aerial installed?
  """
  hasAerialInstalled: Boolean

  """
  Location of the CHF.
  """
  chfLocation: CHFLocation

  """
  Type of the premise in which the CHF is located.
  """
  premiseType: PremiseType

  """
  In the case of NO_SM_WAN, was the issue a local metal obstruction (as defined in CHSM)?
  """
  hasMetalObstruction: Boolean

  """
  In the case of NO_SM_WAN, was the issue a thick stone wall obstruction (as defined in CHSM)?
  """
  hasConnectivityObstruction: Boolean

  """
  In the case of NO_SM_WAN, was the CHF in a shared/communal area (as defined in CHSM)?
  """
  hasSharedObstruction: Boolean

  """
  The engineer's description of the fault.
  """
  faultReason: CHFFaultReason

  """
  Whether a fault was identified before or after the installation.
  """
  faultReturnType: CHFFaultReturnType

  """
  How the CHF was installed and connected to the rest of the Smart Metering System.
  """
  chfConnectionMethod: CHFConnectionMethod

  """
  In the case of NO_FAULT_RETURN, the reason for the meter not being installed.
  """
  noFaultReturnType: CHFNoFaultReturnType
}

"""
    The type of comms hub status update request to be sent.
    
"""
enum CommsHubStatusUpdateType {
  """
  Success.
  """
  SUCCESS

  """
  No SM Wide Area Network.
  """
  NO_SM_WAN

  """
  Returning CHF due to technical fault.
  """
  FAULT_RETURN

  """
  Returning CHF for non-technical reason.
  """
  NO_FAULT_RETURN
}

"""
    Whether it is a new or replacement CHF.
    
"""
enum CHFInstallType {
  """
  New.
  """
  NEW

  """
  Replacement.
  """
  REPLACEMENT
}

"""
    Location of the CHF.
    
"""
enum CHFLocation {
  """
  Outside of the premises.
  """
  OUTSIDE

  """
  Indoors On External Wall.
  """
  INDOORS_ON_EXTERNAL_WALL

  """
  Indoors, NOT on an external wall.
  """
  DEEP_INDOORS

  """
  In the basement/cellar.
  """
  BASEMENT_OR_CELLAR
}

"""
    The type of premise in which the CHF is located.
    
"""
enum PremiseType {
  """
  Detached / Semi-detached.
  """
  DETACHED_OR_SEMI

  """
  Terraced.
  """
  TERRACED

  """
  An apartment block with 5 floors or less.
  """
  LOW_RISE_APARTMENT

  """
  An apartment block with more than 5 floors.
  """
  HIGH_RISE_APARTMENT
}

"""
    The user's description of the fault, if the meter was not installed due to a technical problem.
    
"""
enum CHFFaultReason {
  """
  Damaged Case.
  """
  DAMAGED_CASE

  """
  Damaged connector.
  """
  DAMAGED_CONNECTOR

  """
  Illegal Interference Or Missing Seals.
  """
  ILLEGAL_INTERFERENCE_OR_MISSING_SEALS

  """
  Environmental Conditions Exceeded.
  """
  ENVIRONMENTAL_CONDITIONS_EXCEEDED

  """
  Fault with SM WAN.
  """
  SM_WAN_FAULT

  """
  Fault with SM HAN interface.
  """
  SM_HAN_FAULT

  """
  Fault with LED.
  """
  LED_FAULT

  """
  Fault with aerial.
  """
  AERIAL_FAULT

  """
  Manufacturing Defect.
  """
  MANUFACTURING_DEFECT
}

"""
    Whether the fault was identified before or after the installation.
    
"""
enum CHFFaultReturnType {
  """
  Prior To Installation.
  """
  PRIOR_TO_INSTALLATION

  """
  Post Installation.
  """
  POST_INSTALLATION
}

"""
    How the CHF was installed and connected to the rest of the Smart Metering System.
    
"""
enum CHFConnectionMethod {
  """
  Hot Shoe.
  """
  HOT_SHOE

  """
  Cradle.
  """
  CRADLE

  """
  Esme.
  """
  ESME
}

"""
    The reason for the meter not being installed if there was no technical issue.
    
"""
enum CHFNoFaultReturnType {
  """
  General.
  """
  GENERAL

  """
  Non-domestic opt-out.
  """
  NON_DOMESTIC_OPT_OUT

  """
  Dual supplier HAN variant replacement.
  """
  DUAL_SUPPLIER_HAN_VARIANT_REPLACEMENT

  """
  SM WAN variant replacement requested by DCC.
  """
  SM_WAN_VARIANT_REPLACEMENT

  """
  Lost or stolen hub.
  """
  LOST_OR_STOLEN_HUB
}

"""
The possible errors that can be raised are:

- KT-GB-4053: Fuel type should not be specified for Alt HAN device.
- KT-GB-4031: Error sending the request to join the device to the CHF.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type JoinConsumerDevice {
  possibleErrors: [PossibleErrorType]

  """
  The reference of the join PPMID, IHD, CAD or Alt HAN request in Kraken.
  """
  requestReference: String
}

input JoinConsumerDeviceInput {
  """
  The fuel type of the device, electricity, gas or dual fuel
  """
  fuelType: FuelTypeChoices

  """
  Device ID of the CHF (Communications Hub Function).
  """
  chfDeviceId: String!

  """
  Device ID (IHD, PPMID, CAD or Alt HAN) of the device being added to the CHF.
  """
  consumerDeviceId: String!

  """
  Code provided by manufacturer as part of ASN data, and included as part of device pre-notification, which can be required to authorise the joined device.
  """
  installationCode: String

  """
  The device type being joined to the CHF.
  """
  consumerDeviceType: JoinConsumerDeviceChoices!
}

"""
An enumeration.
"""
enum FuelTypeChoices {
  """
  Electricity.
  """
  ELECTRICITY

  """
  Gas.
  """
  GAS

  """
  Dual Fuel.
  """
  DUAL_FUEL
}

"""
An enumeration.
"""
enum JoinConsumerDeviceChoices {
  """
  Pre-Payment Meter Interface Device.
  """
  PPMID

  """
  In-Home Display.
  """
  IHD

  """
  Consumer Access Device.
  """
  CAD

  """
  Alternative Home Area Network.
  """
  ALT_HAN
}

"""
Remove a consumer device from the CHF/HAN. Currently limited to only CAD devices.

The possible errors that can be raised are:

- KT-GB-4012: Unable to find the CAD device.
- KT-GB-4032: Error sending the request to remove the device.
- KT-GB-4013: Received invalid device type to remove other than CAD.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type RemoveConsumerDevice {
  possibleErrors: [PossibleErrorType]

  """
  The reference of the remove consumer device request in Kraken.
  """
  requestReference: String
}

input RemoveConsumerDeviceInput {
  """
  Device ID of the CAD being removed from the CHF/HAN.
  """
  consumerDeviceId: String!

  """
  The device type being joined, currently limited to CAD only.
  """
  consumerDeviceType: RemoveConsumerDeviceChoices!
}

"""
An enumeration.
"""
enum RemoveConsumerDeviceChoices {
  """
  Consumer Access Device.
  """
  CAD
}

"""
Add credit to a smart prepayment meter.
"""
type AddCreditToSmartMeter {
  """
  Top-up amount in pence to add to smart meter
  """
  amount: Int!
}

"""
This type is used by clients to top-up a smart prepay meter
"""
input SmartPrepayMeterAmountInput {
  """
  Account number of customer.
  """
  accountNumber: String!

  """
  Electricity or gas meter device ID.
  """
  deviceId: String!

  """
  Amount of credit to add to the meter, in pence.
  """
  amount: Int!

  """
  The top-up will wait for this payment to clear before proceeding.
  """
  paymentIntentId: ID

  """
  Apply as temporary credit.
  """
  isTemporaryCredit: Boolean

  """
  Reason for top-up.
  """
  reason: String
}

"""
The possible errors that can be raised are:

- KT-GB-4033: No electricity device found matching device ID.
- KT-GB-4034: Error requesting consumption data.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RequestConsumptionData {
  possibleErrors: [PossibleErrorType]

  """
  The reference for the associated request in Kraken.
  """
  requestReference: String
}

input RequestConsumptionDataInput {
  """
  Device ID for the meter.
  """
  deviceId: String!

  """
  The first half hourly period start (inclusive) to retrieve.
  """
  startAt: DateTime

  """
  The last half hourly end time (inclusive) to retrieve.
  """
  endAt: DateTime
}

type ReplaceCommsHub {
  """
  The reference for the associated request in Kraken.
  """
  requestReference: String
}

"""
Specify a new SMETS2 Communications Hub to replace an existing Communications Hub.
"""
input ReplaceCommsHubInput {
  """
  The device id of the old Communications Hub.
  """
  oldCommsHubDeviceId: String!

  """
  The device id of the new Communications Hub.
  """
  newCommsHubDeviceId: String!
}

"""
Triggers an asynchronous request to check the connection of a device.

As this is an asynchronous operation, the mutation does not return the result of the request.
Instead, the request reference is returned, which can be used to track the status of the
request. If it's an organisation, the organisation will receive an update on the request via
the agent services.
"""
type CheckDeviceConnection {
  """
  The reference of the request in Kraken.
  """
  requestReference: String
}

"""
Specify the device id of a smart device to check the connection.
"""
input CheckDeviceConnectionInput {
  """
  The device id of the device (e.g. B0-11-2E-33-FF-45-C6-78).
  """
  deviceId: String!
}

type OccupyOutputType {
  account: AccountInterface
}

input OccupyInput {
  accountNumber: String!

  propertyId: String!

  quoteCode: String!

  productCode: String!

  """
  The day of the month that payments should be taken from the account. Should be between 1 and 28.
  """
  paymentDay: Int

  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput = null

  users: [AccountUserInput]

  moveInDate: Date
}

input DirectDebitInstructionLocalBankDetailsInput {
  accountNumber: String!

  accountHolder: String!

  sortCode: String!
}

input AccountUserInput {
  givenName: String!

  familyName: String!

  email: String!

  mobile: String!

  optedInForMarketing: Boolean!

  creditScoreData: CreditScoreData = null

  creditScoreFetchedAt: DateTime

  dateOfBirth: Date

  psrData: UpdateSpecialCircumstancesInput = null

  """
  Role codes of the roles to be assigned to the user.
  """
  roles: [String]
}

input CreditScoreData {
  riskBracket: String!

  score: Int!
}

input UpdateSpecialCircumstancesInput {
  """
  Additional presence preferred
  """
  additionalPresencePreferred: Boolean

  """
  Blind
  """
  blind: Boolean

  """
  Careline/telecare system
  """
  carelineTelecareSystem: Boolean

  """
  Chronic/serious illness
  """
  chronicSeriousIllness: Boolean

  """
  Dementia
  """
  dementia: Boolean

  """
  Developmental condition
  """
  developmentalCondition: Boolean

  """
  Pensionable age
  """
  elderly: Boolean

  hearingImpairment: Boolean

  """
  Heart, lung & ventilator
  """
  heartLungMachine: Boolean

  """
  Dialysis, feeding pump and automated medication
  """
  kidneyDialysis: Boolean

  """
  MDE electric showering
  """
  mdeElectricShowering: Boolean

  """
  Medicine refrigeration
  """
  medicineRefrigeration: Boolean

  """
  Mental health
  """
  mentalHealth: Boolean

  """
  Nebuliser and apnoea monitor
  """
  nebuliser: Boolean

  """
  Oxygen concentrator
  """
  oxygenConcentrator: Boolean

  """
  Oxygen Use
  """
  oxygenUse: Boolean

  partialSighted: Boolean

  physicalImpairment: Boolean

  poorSenseOfSmell: Boolean

  restrictedHandMovement: Boolean

  restrictedMovement: Boolean

  speechImpairment: Boolean

  stairLift: Boolean

  waterDependent: Boolean

  familiesWithYoungChildren5OrUnder: Boolean

  familiesWithYoungChildren5OrUnderEndDate: String

  temporaryLifeChanges: Boolean

  temporaryLifeChangesEndDate: String

  temporaryPostHospitalRecovery: Boolean

  temporaryPostHospitalRecoveryEndDate: String

  temporaryYoungAdultHouseholder: Boolean

  temporaryYoungAdultHouseholderEndDate: String

  foreignLanguageSpeaker: Boolean

  """
  Preferred language
  """
  language: String

  """
  Use a unique password to identify our staff and partners
  """
  usePasswordToIdentify: Boolean

  partnerPassword: String

  """
  Consent required to allow priority service request information to be shared. You will only need to provide this once
  """
  userConsent: Boolean
}

"""
The possible errors that can be raised are:

- KT-GB-6624: An error occurred when trying to process this house move.
- KT-GB-6625: An error occurred when trying to process this house move.
- KT-GB-6626: There was an error processing the PSR data.
- KT-GB-6627: There are missing agent appointments.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type PerformMoveOut {
  possibleErrors: [PossibleErrorType]

  account: AccountInterface
}

input MoveOutInput {
  accountNumber: String!

  propertyId: String!

  moveOutDate: Date!

  """
  The property to perform a move in for.
  """
  newProperty: MoveInNewProperty = null

  """
  The details of the next occupant of the property.
  """
  newTenant: MoveOutNewTenant = null
}

input MoveInNewProperty {
  """
  Street address of the new property. Should not contain the postcode.
  """
  address: String!

  """
  Postcode of new property.
  """
  postcode: String!

  """
  Date of moving into the new property.
  """
  moveInDate: String

  """
  MPANs of the electricity meter points at the new property.
  """
  mpans: [String]

  """
  MPRNs of the gas meter points at the new property.
  """
  mprns: [String]

  """
  The product to use when creating agreements for the new property. If not provided, the current product for each meter point is used if available, or else the default SVT product. If provided, quote_code must also be provided.
  """
  productCode: String

  """
  A quote that contains the product provided in product_code. Should be provided only if product_code is also provided.
  """
  quoteCode: String

  """
  If True, this will trigger the move in flow at the new property for the account.
  """
  moveInNewProperty: Boolean
}

input MoveOutNewTenant {
  givenName: String

  familyName: String

  email: String

  mobile: String

  role: String
}

"""
Create a shell account (a billable account with no property/energy supply).
"""
type CreateShellAccountPayload {
  portfolioNumber: String

  givenName: String!

  familyName: String!

  billingName: String

  email: String!

  mobile: String

  landline: String

  brand: String

  dateOfBirth: Date

  billingAddressLine1: String

  billingAddressLine2: String

  billingAddressLine3: String

  billingAddressLine4: String

  billingAddressLine5: String

  billingPostcode: String

  billingRichAddress: String

  """
  For fixed billing accounts only, the length of their billing period. Can be MONTHLY or QUARTERLY.
  """
  billingPeriodLength: String

  """
  For fixed billing accounts only, the number the period length is to be multiplied by to get the total period length, i.e. for billing every second month, select 2 combined with a billing period length MONTHLY. Can't be > 1 for quarterly billing.
  """
  billingPeriodMultiplier: Int

  """
  Day to fixed bill on if billing_period_length set.
  """
  billingPeriodDay: Int

  """
  Month to start billing from if billing_period_length set to QUARTERLY or the multiplier is > 1.
  """
  billingPeriodMonth: Int

  isBusinessAccount: Boolean

  companyName: String

  companyNumber: String

  businessType: String

  password: String

  passwordUpdateToken: String

  urn: String

  errors: [ErrorType]

  account: AccountInterface

  clientMutationId: String
}

input CreateShellAccountInput {
  portfolioNumber: String

  givenName: String!

  familyName: String!

  billingName: String

  email: String!

  mobile: String

  landline: String

  brand: String

  dateOfBirth: Date

  billingAddressLine1: String

  billingAddressLine2: String

  billingAddressLine3: String

  billingAddressLine4: String

  billingAddressLine5: String

  billingPostcode: String

  billingRichAddress: String

  """
  For fixed billing accounts only, the length of their billing period. Can be MONTHLY or QUARTERLY.
  """
  billingPeriodLength: String

  """
  For fixed billing accounts only, the number the period length is to be multiplied by to get the total period length, i.e. for billing every second month, select 2 combined with a billing period length MONTHLY. Can't be > 1 for quarterly billing.
  """
  billingPeriodMultiplier: Int

  """
  Day to fixed bill on if billing_period_length set.
  """
  billingPeriodDay: Int

  """
  Month to start billing from if billing_period_length set to QUARTERLY or the multiplier is > 1.
  """
  billingPeriodMonth: Int

  isBusinessAccount: Boolean

  companyName: String

  companyNumber: String

  businessType: String

  password: String

  passwordUpdateToken: String

  urn: String

  clientMutationId: String
}

"""
Update the comms delivery preference for the input account number to the
received commsDeliveryPreference value.

The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-4136: Cannot set comms preference to email when account has no email.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateCommsDeliveryPreference {
  possibleErrors: [PossibleErrorType]

  account: AccountInterface
}

"""
Input fields for updating comms delivery preferences for an account
"""
input UpdateCommsDeliveryPreferenceInput {
  accountNumber: String!

  commsDeliveryPreference: CommsDeliveryPreference!
}

"""
Update the billing email for the input account number to the
received email value.

The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-4122: Invalid email.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAccountBillingEmail {
  possibleErrors: [PossibleErrorType]

  """
  Account that was changed.
  """
  account: AccountInterface
}

"""
Input fields for updating billing email for an account.
"""
input UpdateAccountBillingEmailInput {
  """
  Account number for account.
  """
  accountNumber: String!

  """
  The billing_email which can be up to 512 characters. Use null to unset billing_email.
  """
  billingEmail: String
}

"""
The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type AddCampaignToAccount {
  possibleErrors: [PossibleErrorType]

  """
  Whether the campaign was successfully added.
  """
  campaignAdded: Boolean
}

input AddCampaignToAccountInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The slug of the campaign we want to assign.
  """
  campaign: String!
}

"""
The possible errors that can be raised are:

- KT-CT-4145: Invalid address.
- KT-CT-7123: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAccountBillingAddress {
  possibleErrors: [PossibleErrorType]

  """
  The updated account.
  """
  account: AccountType
}

input AccountBillingAddressInput {
  """
  The account number of the account to update.
  """
  accountNumber: String

  """
  Billing address details.
  """
  billingAddress: BillingAddressDetailsInput = null
}

input BillingAddressDetailsInput {
  """
  Billing street address.
  """
  streetAddress: String

  """
  Billing structured street address.
  """
  structuredStreetAddress: GenericScalar

  """
  Billing dependent locality.
  """
  dependentLocality: String

  """
  Billing locality.
  """
  locality: String

  """
  Billing postal code.
  """
  postalCode: String

  """
  Billing sorting code.
  """
  sortingCode: String

  """
  Billing delivery point identifier.
  """
  deliveryPointIdentifier: String

  """
  Administrative area.
  """
  administrativeArea: String

  """
  Billing country.
  """
  country: String
}

"""
The possible errors that can be raised are:

- KT-CT-4123: Unauthorized.
- KT-CT-4180: Account note must be a valid string.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateAccountNote {
  possibleErrors: [PossibleErrorType]

  """
  Account, which has the added note.
  """
  account: AccountType
}

input CreateAccountNoteInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The note to add.
  """
  note: String!

  """
  Pin the note to account.
  """
  isPinned: Boolean!
}

"""
Renew agreements for an account.

This mutation calls tariff renewal use-case both
for electricity and gas agreements.

This mutation renews agreements from midnight the day it is invoked in the case of flexible
tariffs and fixed tariffs ending in more than 90 days. For fixed tariffs that end in less
than 90 days, it creates follow on agreements that start when the fixed agreements end (or
minimum of when they end in the case of misaligned agreements).

The possible errors that can be raised are:

- KT-GB-4125: Invalid data.
- KT-GB-4111: Unable to renew agreements for tariff renewal.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RenewAgreements {
  possibleErrors: [PossibleErrorType]

  account: AccountType
}

input RenewAgreementsInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The ID if the quoted product we wish to use to create new agreements. Part of the tariff renewal journey involves re-quoting to ensure this is available.
  """
  quotedProductId: ID!

  """
  The ID of the property that agreements should be renewed for.
  """
  propertyId: ID!

  """
  Where the account's current payment schedule has a debt repayment element, we let the user choose whether to continue making catch-up payments, or to repay the full debt in addition to their next payment.
  """
  makeFullDebtRepayment: Boolean!

  """
  If the customer is currently on a flat rate tariff, persist this into the new agreement.
  """
  persistFlatRate: Boolean

  """
  The date the new agreement takes effect. This can be no more than 90 days in the future.
  """
  changeOn: Date
}

"""
Renew agreement for a given meter point.

The possible errors that can be raised are:

- KT-GB-4112: Unable to renew agreements for meter point at this time. Please try again later.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type RenewAgreementForMeterPoint {
  possibleErrors: [PossibleErrorType]

  electricityAgreement: RestrictedElectricityAgreement

  gasAgreement: RestrictedGasAgreement
}

type RestrictedElectricityAgreement implements Node {
  validFrom: DateTime!

  validTo: DateTime

  """
  The ID of the object
  """
  id: ID!

  tariffCode: String
}

type RestrictedGasAgreement implements Node {
  validFrom: DateTime!

  validTo: DateTime

  """
  The ID of the object
  """
  id: ID!

  tariffCode: String
}

input RenewAgreementForMeterPointInput {
  """
  MPxN to renew the agreement for.
  """
  mpxn: String!

  """
  Tariff code for the new agreement.
  """
  tariffCode: String!

  """
  The start date of the new agreement (inclusive).
  """
  validFromDate: Date!

  """
  The end date of the new agreement (exclusive).
  """
  validToDate: Date

  """
  The date the agreement was agreed from (inclusive, if different to valid_from).
  """
  agreedFromDate: Date

  """
  Bespoke rates overriding those of the associated tariff.
  """
  bespokeTariffRates: BespokeTariffRatesInput = null

  """
  Bespoke rates overriding those of the associated tariff, with payment method.
  """
  bespokePpsTariffRates: [BespokePPSTariffRatesInput] = null

  """
  Information on the commission that's associated with this agreement.
  """
  commission: CommissionInput = null
}

input BespokeTariffRatesInput {
  """
  Bespoke standing charge.
  """
  standingCharge: Decimal

  """
  Gas bespoke unit rate.
  """
  unitRate: Decimal

  """
  Electricity bespoke unit rates with their associated rate type.
  """
  unitRates: [BespokeElectricityUnitRatesInput] = null
}

input BespokeElectricityUnitRatesInput {
  """
  Electricity bespoke unit rate to override the unit rate associated with the tariff.
  """
  unitRate: Decimal!

  """
  Rate type associated with the given unit rate.
  """
  rateType: NonBespokeElectricityRateTypeChoices!
}

"""
An enumeration.
"""
enum NonBespokeElectricityRateTypeChoices {
  STANDARD

  ECO7_DAY

  ECO7_NIGHT

  OFF_PEAK
}

input BespokePPSTariffRatesInput {
  """
  Bespoke standing charge.
  """
  standingCharge: Decimal

  """
  Gas bespoke unit rate.
  """
  unitRate: Decimal

  """
  Electricity bespoke unit rates with their associated rate type.
  """
  unitRates: [BespokeElectricityUnitRatesInput] = null

  """
  Payment method associated with the given unit rate.
  """
  paymentMethod: PaymentMethod!
}

"""
An enumeration.
"""
enum PaymentMethod {
  DIRECT_DEBIT

  NON_DIRECT_DEBIT

  PREPAYMENT
}

input CommissionInput {
  """
  The third-party intermediary who sold this renewal to the customer.
  """
  organizationName: String!

  """
  The amount to add to the unit rate when billing, in pence/kWh, which is paid to the third-party intermediary.
  """
  unitRateUplift: Decimal!

  """
  The fixed comission fee, in pence, which is paid to the third-party intermediary.
  """
  fixedTpiFee: Int

  """
  The subdomain of the affiliate link used to track the commission.
  """
  affiliateLinkSubdomain: String
}

"""
Renew agreements provided for an account.

The possible errors that can be raised are:

- KT-GB-4113: At least one list of agreements to renew is required.
- KT-GB-4126: Electricity and gas agreement input is invalid.
- KT-GB-4114: Unable to renew agreements.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type RenewAgreementsForAccount {
  possibleErrors: [PossibleErrorType]

  account: AccountType
}

input RenewAgreementsForAccountInput {
  """
  Account number
  """
  accountNumber: String!

  """
  A list of electricity agreements and the code of the product they will be renewed to.
  """
  electricityAgreements: [AgreementRenewalProductInput]

  """
  A list of gas agreements and the code of the product they will be renewed to.
  """
  gasAgreements: [AgreementRenewalProductInput]

  """
  The date the new agreement takes effect. This can be no more than 90 days in the future.
  """
  changeOn: Date
}

input AgreementRenewalProductInput {
  """
  The Kraken ID of the agreement to be renewed. The agreement must be currently active.
  """
  agreementId: ID!

  """
  The code of the product the agreement will be renewed to.
  """
  productCode: String!
}

"""
Set stated interest in acquiring a smart meter of an account.

The possible errors that can be raised are:

- KT-GB-4115: Could not create smart meter interest for account.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateAccountSmartMeterInterest {
  possibleErrors: [PossibleErrorType]

  interestUpdated: Boolean

  """
  The interest of an account in procuring smart meters.
  """
  smets2Interest: SmartMeterInterestChoices

  """
  The source category of the smart meter interest update.
  """
  smets2InterestSource: SmartMeterInterestSourceChoices

  """
  The reason why the account holder is not interested in having a smart meter installed.
  """
  smets2RefusalReason: SMETS2InterestReason
}

"""
An enumeration.
"""
enum SmartMeterInterestSourceChoices {
  WEBSITE

  AFFILIATE
}

input UpdateAccountSmartMeterInterestInput {
  accountNumber: String!

  """
  Input field for setting smart meter interest.
  """
  smets2Interest: SmartMeterInterestChoices!

  """
  The source category of the smart meter interest update.
  """
  smets2InterestSource: SmartMeterInterestSourceChoices = WEBSITE

  """
  Input field for setting the reason for why a customer is not interested in a smart meter.
  """
  smets2RefusalReason: SMETS2InterestReason
}

"""
Onboarding for smart tariffs.

This mutation kicks off the smart onboarding for electricity.

The possible errors that can be raised are:

- KT-GB-4102: Unable to start smart onboarding process.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type StartSmartOnboardingProcess {
  possibleErrors: [PossibleErrorType]

  onboardingProcess: SmartOnboardingProcessType

  """
  The product enrolment process created.
  """
  productEnrolment: ProductEnrolmentType
}

type SmartOnboardingProcessType {
  id: ID!

  account: AccountType!

  meterPoint: ElectricityMeterPointType

  product: EnergyProductType!
}

input StartSmartOnboardingProcessInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The MPAN to switch.
  """
  mpan: String

  """
  The MPRN to switch.
  """
  mprn: String

  """
  The product code to switch to.
  """
  productCode: String!

  isNewAccount: Boolean = false

  termsAndConditions: TermsAndConditions = null

  """
  A target start date for the new agreement. Must be today or later. Will be ignored if date is in the past at time of creating the new agreement.
  """
  targetAgreementChangeDate: Date
}

input TermsAndConditions {
  """
  The version of the terms and conditions the user was presented with.
  """
  version: String!

  accepted: Boolean!
}

"""
Onboarding for export tariffs.

This mutation kicks off the export onboarding for electricity.

The possible errors that can be raised are:

- KT-GB-4103: Unable to start export onboarding process.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type StartExportOnboardingProcess {
  possibleErrors: [PossibleErrorType]

  onboardingProcess: SmartOnboardingProcessType

  """
  The product enrolment process created.
  """
  productEnrolment: ProductEnrolmentType
}

input StartExportOnboardingProcessInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The import MPAN.
  """
  importMpan: String

  """
  The export MPAN.
  """
  exportMpan: String

  """
  The export product code.
  """
  productCode: String!

  """
  The export technology type.
  """
  technologyType: ExportTechnologyType!

  """
  The FiT ownership status.
  """
  fitStatus: FITStatus!

  """
  Whether to take over the FiT generation payments.
  """
  includeFitGeneration: Boolean = false

  """
  The FiT ID.
  """
  fitId: String

  """
  The MCS certificate number.
  """
  mcsCertNumber: String @deprecated(reason: "The 'mcsCertNumber' field is deprecated.\n\nPlease use ineligibility_reasons instead.\n\n- Marked as deprecated on 2023-10-20.\n- Will be removed on 2024-01-01.")

  """
  The export certificate object.
  """
  certificate: Certificate = null

  """
  The DNO status.
  """
  dnoStatus: DNOStatus!

  """
  Have the terms and conditions for this product been accepted? To be deprecated.
  """
  termsAndConditionsAccepted: Boolean!

  """
  Version of the terms and conditions that have been accepted.
  """
  acceptedTermsAndConditionsVersion: String
}

"""
The type of generator technology used for export.
"""
enum ExportTechnologyType {
  """
  Hydro
  """
  HYDRO

  """
  Photovoltaic
  """
  SOLAR

  """
  Storage
  """
  STORAGE

  """
  Wind
  """
  WIND

  """
  Photovoltaic and Storage
  """
  SOLAR_AND_STORAGE

  """
  Wind and Storage
  """
  WIND_AND_STORAGE
}

"""
The ownership status of FiT for this property.
"""
enum FITStatus {
  """
  Notified
  """
  OWNER

  """
  Previous owner
  """
  PREVIOUS_OWNER

  """
  Third party owned
  """
  THIRD_PARTY_OWNED

  """
  Unknown
  """
  UNKNOWN

  """
  None
  """
  NONE
}

input Certificate {
  """
  The export certificate number.
  """
  number: String!

  """
  The export certificate type.
  """
  type: CertificateType!
}

"""
The export certificate type.
"""
enum CertificateType {
  MCS

  FLEXI_ORB
}

"""
The status of DNO being notified of this export request.
"""
enum DNOStatus {
  """
  Notified
  """
  NOTIFIED

  """
  Not Notified
  """
  NOT_NOTIFIED

  """
  Unknown
  """
  UNKNOWN
}

"""
Mutation to update the Supply Start Date (SSD) of an account.

The possible errors that can be raised are:

- KT-GB-4101: Unable to update SSD for account.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateSsd {
  possibleErrors: [PossibleErrorType]

  ssdUpdated: Boolean

  estimatedSsd: Date
}

input UpdateSsdInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The desired Supply Start Date (SSD).
  """
  desiredSsd: Date!
}

"""
Create a Siteworks event.

Currently, only events for reporting are enabled.
"""
type CreateSiteworksEvent {
  eventCreated: Boolean
}

input CreateSiteworksEventInput {
  """
  The Siteworks request id.
  """
  siteworksRequestId: String!

  """
  The type of Siteworks event that will be created.
  """
  eventType: SiteworksEventType!

  """
  The content that might be submitted as field servies data.
  """
  fieldServicesData: JSONString

  """
  The references that are related to jobs, appointments etc.
  """
  references: JSONString

  """
  The notes that are associated with the Siteworks event.
  """
  eventNotes: String
}

"""
    Please note: these labels are exposed in the API documentation.
    
"""
enum SiteworksEventType {
  """
  SMICOP compliance report submitted
  """
  SMICOP_COMPLIANCE_REPORT_SUBMITTED
}

"""
Makes it possible to create Sitework events by external third parties.

This mutation uses the external JWT authorization method.

The possible errors that can be raised are:

- KT-GB-4222: The provided 'siteworksRequestId' is not a valid UUID.
- KT-GB-4223: Siteworks request not found. Check the provided 'siteworksRequestId' is correct.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateSiteworksEventExternal {
  possibleErrors: [PossibleErrorType]

  eventCreated: Boolean
}

"""
Create a new job or update the status of an existing one.

The possible errors that can be raised are:

- KT-CT-1112: 'Authorization' header not provided.
- KT-CT-4231: Unauthorized.
- KT-GB-4230: Invalid data.
- KT-GB-4224: Error processing siteworks appointment.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateOrUpdateSiteworksAppointment {
  possibleErrors: [PossibleErrorType]

  result: CreateOrUpdateSiteworksAppointmentOutput
}

type CreateOrUpdateSiteworksAppointmentOutput {
  appointmentCreated: Boolean

  appointmentUpdated: Boolean
}

input CreateOrUpdateSiteworksAppointmentInput {
  """
  The market ID of the agent that carried out the work. This should be an electricity market participant ID or gas market code.
  """
  agentId: String!

  """
  The unique appointment reference of the agent.
  """
  appointmentReference: String!

  """
  The scheduled date of the appointment. Required if the appointment is not already booked.
  """
  appointmentDate: Date!

  """
  The status of the appointment.
  """
  status: AppointmentStatus!

  """
  The type of work the appointment has been booked for.
  """
  workType: String

  """
  The categories of meter the work applies to.
  """
  fuelType: FuelType!

  """
  Required if `fuel_type` is `ELECTRICITY` or `DUAL_FUEL`.
  """
  mpan: String

  """
  Required if `fuel_type` is `GAS` or `DUAL_FUEL`.
  """
  mprn: String

  electricitySupplyType: ElectricitySupplyType = null

  gasSupplyType: GasSupplyType = null

  """
  The start time of the slot during which the engineer is scheduled at the property.
  """
  timeSlotStart: Time!

  """
  The end time of the slot during which the engineer is scheduled at the property.
  """
  timeSlotEnd: Time

  """
  Address of the property where the appointment is taking place.
  """
  address: AddressInput = null

  """
  Boolean flag to indicate an emergency appointment.
  """
  isEmergency: Boolean

  """
  Name of engineer currently assigned to the appointment.
  """
  engineerName: String

  """
  Extra context to a change in status such as abort or cancellation reason.
  """
  statusReason: String

  """
  Free text comments about the appointment.
  """
  jobNotes: String

  """
  If applicable, the category of new meters installed.
  """
  newMeterCategory: NewMeterCategory = null

  """
  A list of electricity meters that the work applies to.
  """
  electricityMeters: [MeterInput] = null

  """
  A list of electricity meters that the work applies to.
  """
  gasMeters: [MeterInput] = null

  """
  The payment mode for the new meters. If not provided it will default to the payment mode for the current meters.
  """
  futurePaymentMode: PaymentMode = null

  """
  Determines which communications will be sent to customers for the appointment. The default is to send all available messages (e.g. appointment confirmed, job completed).
  """
  commsStrategy: CommsStrategy = SEND_ALL
}

"""
An enumeration.
"""
enum AppointmentStatus {
  """
  The appointment has been booked.
  """
  BOOKED

  """
  The appointment was cancelled either by the customer or the agent.
  """
  CANCELLED

  """
  The appointment was aborted. Choose this option for partially completed work (e.g. on a dual fuel meter exchange where one meter was exchanged successfully but the other exchange could not be completed.
  """
  ABORTED

  """
  The appointment has been completed successfully.
  """
  COMPLETED
}

"""
An enumeration.
"""
enum ElectricitySupplyType {
  """
  Single phase meter point.
  """
  SINGLE_PHASE

  """
  Three phase meter point.
  """
  THREE_PHASE
}

"""
An enumeration.
"""
enum GasSupplyType {
  """
  Standard pressure gas supply.
  """
  STANDARD

  """
  Medium pressure gas supply.
  """
  MEDIUM
}

input AddressInput {
  addressLine1: String

  addressLine2: String

  addressLine3: String

  addressLine4: String

  addressLine5: String

  """
  Postcode of the property where the appointment took place.
  """
  postcode: String!
}

"""
An enumeration.
"""
enum NewMeterCategory {
  """
  SMETS1 (first generation smart meter).
  """
  SMETS1

  """
  SMETS2 (second generation smart meter).
  """
  SMETS2

  """
  Traditional meter.
  """
  TRADITIONAL

  """
  Check Meter.
  """
  CHECK_METER
}

input MeterInput {
  """
  Serial number of the meter involved in the appointments
  """
  serialNumber: String!

  """
  Whether the meter details refer to a meter that is currently installed at the site or one that has been removed or replaced.
  """
  status: MeterStatus = null

  """
  The type of meter. This field is not required but should be supplied whenever possible.
  """
  meterType: String
}

"""
An enumeration.
"""
enum MeterStatus {
  """
  The meter was removed.
  """
  REMOVED

  """
  The meter was installed or work was done on an existing meter.
  """
  ON_SITE
}

"""
Determines which communications will be sent for the appointment.
"""
enum CommsStrategy {
  SEND_ALL

  SEND_ONLY_JOB_COMPLETED

  SUPPRESS_ALL
}

"""
Allows account users and organisations to cancel siteworks appointment.
"""
type CancelSiteworksAppointment {
  siteworksAppointment: ActiveAppointmentType
}

input CancelSiteworksAppointmentInput {
  """
  The siteworks appointment Kraken unique ID.
  """
  appointmentId: ID

  """
  The siteworks appointment agent reference code.
  """
  agentReference: String
}

"""
The possible errors that can be raised are:

- KT-GB-4219: Property does not exist.
- KT-GB-4220: No account currently active at property.
- KT-GB-4221: Could not confirm duplicate property.
- KT-GB-4228: Cannot currently book appointments for legacy prepay meters.
- KT-GB-4229: A smart meter exchange appointment for this date already exists.
- KT-GB-4210: Bookings not supported for agent appointed at property.
- KT-GB-4211: Timeslot no longer available.
- KT-GB-4212: Missing or invalid data for account or property.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ConfirmSiteworksAppointmentSlot {
  possibleErrors: [PossibleErrorType]

  siteworksAppointment: ActiveAppointmentType
}

input ConfirmSiteworksAppointmentSlotInput {
  propertyId: ID!

  appointmentDate: Date!

  startTime: Time!

  endTime: Time!

  additionalInformation: String

  agentReference: String

  siteId: String

  slotId: String

  calculationId: String

  promiseId: String

  """
  Determines which communications will be sent to customers for the appointment. The default is to send all available messages (e.g. appointment confirmed, job completed).
  """
  commsStrategy: CommsStrategy = SEND_ALL
}

"""
The possible errors that can be raised are:

- KT-GB-4213: Application not found.
- KT-GB-4231: Invalid data.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type ReportRemovedMeterDetails {
  possibleErrors: [PossibleErrorType]

  result: ReportRemovedMeterDetailsOutput
}

type ReportRemovedMeterDetailsOutput {
  appointment: SiteworksAppointmentType

  electricityMeterPoint: SiteworksBookingElectricityMeterPointType

  gasMeterPoint: SiteworksBookingGasMeterPointType
}

input ReportRemovedMeterDetailsInput {
  """
  The installer/agents own booking reference for the appointment to remove these meters.
  """
  appointmentId: String

  electricityMeterPoint: RemovedElectricityMeterPointInput = null

  gasMeterPoint: RemovedGasMeterPointInput = null
}

input RemovedElectricityMeterPointInput {
  mpan: String

  meters: [RemovedElectricityMeterInput] = null
}

input RemovedElectricityMeterInput {
  serialNumber: String!

  meterType: ElectricityMeterTypes = null

  registers: [RemovedElectricityMeterRegisterInput]!

  readAt: DateTime

  prepayData: RemovedMeterPrepayDataInput = null
}

"""
An enumeration.
"""
enum ElectricityMeterTypes {
  """
  Key.
  """
  K

  """
  Smartcard.
  """
  S

  """
  Token.
  """
  T
}

input RemovedElectricityMeterRegisterInput {
  """
  Identifier string/label for the register.
  """
  id: String!

  finalReading: Float!
}

input RemovedMeterPrepayDataInput {
  """
  The credit balance of the meter in millipence.
  """
  balance: Int

  """
  The total of all debt left on the removed meter in millipence.
  """
  cumulativeDebtBalance: Int

  """
  Amount of emergency credit remaining on the meter in millipence.
  """
  emergencyCreditBalance: Int
}

input RemovedGasMeterPointInput {
  mprn: String

  meters: [RemovedGasMeterInput] = null
}

input RemovedGasMeterInput {
  serialNumber: String!

  meterType: GasMeterTypes = null

  finalReading: Float!

  readAt: DateTime

  prepayData: RemovedMeterPrepayDataInput = null
}

"""
An enumeration.
"""
enum GasMeterTypes {
  """
  Prepayment.
  """
  PP

  """
  Electronic token.
  """
  ET
}

"""
The possible errors that can be raised are:

- KT-GB-5411: Failed to update special circumstance record.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdateSpecialCircumstances {
  possibleErrors: [PossibleErrorType]

  specialCircumstances: SpecialCircumstancesType
}

type DirectDebitPaymentDayUpdate {
  paymentSchedule: PaymentScheduleType

  errors: [ErrorType]
}

input DirectDebitPaymentDayUpdateInput {
  accountNumber: String!

  paymentDay: Int!
}

"""
The possible errors that can be raised are:

- KT-GB-3918: Account not found.
- KT-GB-3910: This feature is not available to business accounts.
- KT-GB-3911: Your payment day cannot be changed at this time.
- KT-GB-3912: Unable to update payment day.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type UpdatePaymentSchedulePaymentDay {
  possibleErrors: [PossibleErrorType]

  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentDayInput {
  accountNumber: String!

  paymentDay: Int!
}

"""
The possible errors that can be raised are:

- KT-GB-3919: Invalid payment schedule amount.
- KT-GB-3920: Cannot update payment schedule amount.
- KT-CT-3923: Unauthorized.
- KT-CT-3941: Invalid data.
- KT-CT-3942: An unexpected error occurred.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type UpdatePaymentSchedulePaymentAmount {
  possibleErrors: [PossibleErrorType]

  paymentSchedule: PaymentScheduleType
}

input UpdatePaymentSchedulePaymentAmountInput {
  accountNumber: String!

  """
  Amount in pence
  """
  amount: Int!
}

"""
The possible errors that can be raised are:

- KT-CT-3940: Invalid data.
- KT-CT-3923: Unauthorized.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type CreateDirectDebitInstruction {
  possibleErrors: [PossibleErrorType]

  directDebitInstruction: DirectDebitInstructionType
}

input CreateDirectDebitInstructionInput {
  accountNumber: String!

  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput!
}

"""
Mutation for creating an Payment Schedule instance using the authenticated user.

The possible errors that can be raised are:

- KT-GB-3917: No statement in last 60 days.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type CreatePaymentSchedule {
  possibleErrors: [PossibleErrorType]

  paymentSchedule: PaymentScheduleType
}

input PaymentScheduleInput {
  """
  Input a customer account number.
  """
  accountNumber: String!

  """
  Payment amount must be inputted as pence.
  """
  paymentAmount: Int!

  """
  Input a direct debit payment day.
  """
  paymentDay: Int!
}

type WarmHomeDiscountApplicationOutputType {
  errors: [SerializerFieldErrorsType]

  id: String
}

input WarmHomeDiscountApplicationInputType {
  """
  A set of criteria under which someone is eligible for the Warm Home Discount. The applicant must meet at least one of these criteria, as well as at least one qualifying component criteria.
  """
  qualifyingCriteria: QualifyingCriteriaOptions = null

  """
  A set of criteria under which someone is eligible for the Warm Home Discount. The applicant must meet at least one of these criteria, as well as at least one qualifying component criteria.
  """
  qualifyingComponent: CurrentQualifyingComponentOptions = null
}

"""
An enumeration.
"""
enum CurrentQualifyingComponentOptions {
  PERSONAL_INDEPENDENCE_PAYMENTS

  DISABILITY_BENEFITS

  INCOME_RELATED_BENEFITS

  MATERNITY_EXEMPTION_CERTIFICATE

  AGE_THRESHOLD

  HAS_DISABILITY

  ADULT_DISABILITY_PAYMENT

  DEPENDENT_CHILD_UNDER_FIVE

  DEPENDENT_CHILD_OVER_FIVE

  LIMITED_CAPABILITY_FOR_WORK
}

type CreateMeterReadingOutputType {
  readingErrors: [SerializerFieldErrorsType]

  id: String @deprecated(reason: "The 'id' field is deprecated.\n\nThe `ID` field is depreciated.\n\n- Marked as deprecated on 2022-10-03.\n- Will be removed on 2024-01-01.")
}

input ReadingInputType {
  registerId: ID

  register: String @deprecated(reason: "The 'register' field is deprecated.\n\nUse register_id instead.\n\n- Marked as deprecated on 2023-02-13.\n- Will be removed on 2023-08-13.")

  reading: Int
}

"""
Amend unbilled electricity reading.
"""
type AmendUnbilledElectricityReading {
  readingAmended: Boolean
}

input AmendUnbilledReadingInput {
  """
  The ID of the reading that will be amended.
  """
  readingId: Int!

  """
  The new value of reading.
  """
  readingValue: Int!

  """
  The new datetime of reading.
  """
  readingDatetime: DateTime!
}

"""
Create a new auto topup config for SPAYG meter.
"""
type CreateAutoTopupConfig {
  """
  The created auto top-up config.
  """
  autoTopupConfig: AutoTopupConfigType!
}

"""
The input type for creating an auto top-up config.
"""
input CreateAutoTopupConfigInput {
  """
  The account number, e.g.: 'A-A1B2C3D4'.
  """
  accountNumber: String!

  """
  Alphanumber code identifying the device, e.g.: 'A1-BC-D2-00-01-23-EF-4G'.
  """
  deviceId: String!

  """
  The amount to top-up. The amount should always be provided in the minor unit of currency, i.e. USA cents / GBP pence / etc. Minimum allowed amount is 1.
  """
  topupAmount: Int!
}

"""
Disable auto topup for SPAYG meter.
"""
type DisableAutoTopup {
  """
  Boolean indicating if the auto top-up was successfully disabled.
  """
  success: Boolean!
}

"""
The input type for disabling auto top-up.
"""
input DisableAutoTopupInput {
  """
  The account number, e.g.: 'A-A1B2C3D4'.
  """
  accountNumber: String!

  """
  Alphanumber code identifying the device, e.g.: 'A1-BC-D2-00-01-23-EF-4G'.
  """
  deviceId: String!
}

type CreateQuoteOutputType {
  errors: [SerializerFieldErrorsType]

  quote: QuoteType
}

input CreateQuoteInput {
  postcode: String!

  electricityMeterPoints: [ElectricityMeterPointConsumptionInput]

  gasMeterPoints: [GasMeterPointConsumptionInput]

  """
  Used to verify the position that field sales agents generate quotes from
  """
  position: PositionInput

  gspGroupId: String = ""

  affiliateSessionId: String = ""

  """
  The affiliate organisation ID. Used with restrict_to_affiliate_products.
  """
  affiliateOrganisationId: String = ""

  """
  Whether to restrict the products (tariffs) to quote from to only show affiliate products. Requires affiliate_organisation_id.
  """
  restrictToAffiliateProducts: Boolean = false

  brandCode: String!

  """
  Optional address information about the customer
  """
  address: QuoteAddressInput

  isBusiness: Boolean = false

  """
  Whether the user has consented to their energy consumption estimates being retrieved from the industry vendors. This currently applies to business accounts only.
  """
  hasConsentedToIndustryDataSearch: Boolean = false

  """
  Optional parameter to select the payment method for the quote, default is direct debit.
  """
  paymentMethod: QuotePaymentMethodChoices = DIRECTDEBIT
}

input PositionInput {
  latitude: Float

  longitude: Float
}

input QuoteAddressInput {
  addressLine1: String = ""

  addressLine2: String = ""

  addressLine3: String = ""
}

"""
An enumeration.
"""
enum QuotePaymentMethodChoices {
  DIRECTDEBIT

  CREDITCARD

  ONRECEIPT

  PREPAYMENT
}

"""
The possible errors that can be raised are:

- KT-GB-4612: Unable to refresh quote - quote not found.
- KT-GB-4613: Error generating quote.
- KT-CT-1113: Disabled GraphQL field requested.
"""
type RefreshQuote {
  possibleErrors: [PossibleErrorType]

  quote: QuoteType
}

input RefreshQuoteInput {
  code: String!
}

type Requote {
  quote: QuoteType
}

input RequoteInput {
  accountNumber: String!

  propertyId: ID!

  productAvailableAt: DateTime

  includeHiddenProducts: Boolean

  persistFlatRate: Boolean

  """
  Optional parameter to select the payment method for the quote, default is direct debit.
  """
  paymentMethod: QuotePaymentMethodChoices = DIRECTDEBIT
}

"""
Bill an account with a smart meter to the most recent midnight snapshot reading.
"""
type BillToLatestSmartMeterSnapshot {
  """
  The date that has been billed up to.
  """
  billedToDate: Date

  """
  The balance after attempting to bill.
  """
  currentBalance: Decimal
}

input BillToLatestSmartMeterSnapshotInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The mpan number.
  """
  mpan: String!
}

"""
Switch the provided meter points to the specified product.

The possible errors that can be raised are:

- KT-GB-4116: Invalid data.
- KT-GB-4617: Quoted product not found.
- KT-CT-4623: Unauthorized.
- KT-GB-4117: Unable to process product switch.
- KT-GB-4119: Meter point already on another account.
- KT-GB-4120: MPxN has no active agreement.
- KT-CT-1113: Disabled GraphQL field requested.
- KT-CT-1111: Unauthorized.
- KT-CT-1112: 'Authorization' header not provided.
"""
type SwitchMeterPointProducts {
  possibleErrors: [PossibleErrorType]

  """
  The account associated with the meter points whose products were switched.
  """
  account: AccountType
}

input SwitchMeterPointProductsInput {
  """
  Account number.
  """
  accountNumber: String!

  """
  The information required to switch each meter point onto the specified product.
  """
  meterPointSwitchContexts: [MeterPointSwitchContext!]!

  """
  Runs payment adequacy and checks if the amount - the customer is paying each month - should be updated.
  """
  updatePaymentAmount: Boolean
}

input MeterPointSwitchContext {
  """
  The MPxN of the meter point.
  """
  mpxn: String!

  """
  The ID of the selected quoted product.
  """
  quotedProductId: ID!

  """
  The date the product switch should take effect. Defaults to the current agreement end date, or tomorrow if the agreement is open-ended.
  """
  changeOn: Date

  """
  Information on the commission that's associated with this agreement.
  """
  commission: CommissionInput = null

  """
  Should the meter point be on a flat rate.
  """
  flatRate: Boolean
}

"""
Create an Electric Juice charge and associated line items.
"""
type CreateElectricJuiceCharge {
  accountCharge: AccountChargeType
}

type AccountChargeType {
  """
  The ID of the account charge.
  """
  id: ID

  """
  The net amount of the charge.
  """
  netAmount: BigInt

  """
  The gross amount of the charge.
  """
  grossAmount: BigInt

  """
  The sales tax amount of the charge.
  """
  salesTaxAmount: BigInt

  """
  The climate change levy amount of the charge.
  """
  cclAmount: BigInt

  """
  The reason for the charge.
  """
  reason: String

  """
  The note for the charge.
  """
  note: String

  """
  The display note for the charge.
  """
  displayNote: String

  metadata: AccountChargeMetadataType
}

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

type AccountChargeMetadataType {
  """
  A JSON object containing unstructured data about the account charge.
  """
  data: JSONString

  """
  The date and time the metadata was last updated.
  """
  updatedAt: DateTime
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The input type for adding a charge for Electric Juice.
"""
input CreateElectricJuiceChargeInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The UID of the Electric Juice charge card to associate with this charge.
  """
  chargeCardUid: String

  """
  The start time of the charge period.
  """
  periodStartAt: DateTime!

  """
  The end time of the charge period.
  """
  periodEndAt: DateTime!

  """
  The amount to be charged (excl. tax).
  """
  netAmount: Int!

  """
  The currency of the charge.
  """
  currency: CurrencyOptions = null @deprecated(reason: "The 'currency' field is deprecated.\n\n\nThis field is no longer used. \"\nAll currency amounts must be in smallest units.\n\n\n- Marked as deprecated on 2022-02-15.\n- Will be removed on 2024-01-01.")

  """
  The provider that originated this charge.
  """
  chargeProvider: String!

  """
  The location of the charging point this charge is associated with.
  """
  postcode: String!

  """
  The amount of energy consumed in kWh.
  """
  kwhUsed: Decimal!

  """
  The price per kWh.
  """
  pricePerKwh: Decimal!

  """
  The price of additional (non-consumption) fees on this charge.
  """
  additionalFees: Int!
}

enum CurrencyOptions {
  UK_PENCE
}

"""
The `Decimal` scalar type represents a python Decimal.
"""
scalar Decimal

"""
Add a credit to an Electric Juice Network ledger.
"""
type CreateElectricJuiceCredit {
  accountCredit: AccountCreditType
}

type AccountCreditType {
  id: ID!

  grossAmount: BigInt!

  netAmount: BigInt!

  salesTaxAmount: BigInt!

  note: String!

  reason: String!

  metadata: AccountCreditMetadataType
}

type AccountCreditMetadataType {
  data: JSONString!

  updatedAt: DateTime!
}

"""
The input type for an Electric Juice ledger credit.
"""
input CreateElectricJuiceCreditInput {
  """
  The account number.
  """
  accountNumber: String!

  """
  The net amount of the credit to be created.
  """
  netAmount: Int!

  """
  The gross amount of the credit to be created.
  """
  grossAmount: Int!

  """
  The tax amount of the credit to be created.
  """
  taxAmount: Int!

  """
  Optional short note about account credit.
  """
  note: String

  """
  The reason why the credit is added to the account.
  """
  reason: AccountCreditReasonType!
}

"""
    Please note: these labels are exposed in the API documentation.
    
"""
enum AccountCreditReasonType {
  """
  External referral credit
  """
  EXTERNAL_REFERRAL_CREDIT
}

"""
A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.
"""
type __Schema {
  description: String

  """
  A list of all types supported by this server.
  """
  types: [__Type!]!

  """
  The type that query operations will be rooted at.
  """
  queryType: __Type!

  """
  If this server supports mutation, the type that mutation operations will be rooted at.
  """
  mutationType: __Type

  """
  If this server support subscription, the type that subscription operations will be rooted at.
  """
  subscriptionType: __Type

  """
  A list of all directives supported by this server.
  """
  directives: [__Directive!]!
}

"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.

Depending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.
"""
type __Type {
  kind: __TypeKind!

  name: String

  description: String

  specifiedByURL: String

  fields(includeDeprecated: Boolean = false): [__Field!]

  interfaces: [__Type!]

  possibleTypes: [__Type!]

  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]

  inputFields(includeDeprecated: Boolean = false): [__InputValue!]

  ofType: __Type
}

"""
An enum describing what kind of type a given `__Type` is.
"""
enum __TypeKind {
  """
  Indicates this type is a scalar.
  """
  SCALAR

  """
  Indicates this type is an object. `fields` and `interfaces` are valid fields.
  """
  OBJECT

  """
  Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.
  """
  INTERFACE

  """
  Indicates this type is a union. `possibleTypes` is a valid field.
  """
  UNION

  """
  Indicates this type is an enum. `enumValues` is a valid field.
  """
  ENUM

  """
  Indicates this type is an input object. `inputFields` is a valid field.
  """
  INPUT_OBJECT

  """
  Indicates this type is a list. `ofType` is a valid field.
  """
  LIST

  """
  Indicates this type is a non-null. `ofType` is a valid field.
  """
  NON_NULL
}

"""
Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.
"""
type __Field {
  name: String!

  description: String

  args(includeDeprecated: Boolean = false): [__InputValue!]!

  type: __Type!

  isDeprecated: Boolean!

  deprecationReason: String
}

"""
Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.
"""
type __InputValue {
  name: String!

  description: String

  type: __Type!

  """
  A GraphQL-formatted string representing the default value for this input value.
  """
  defaultValue: String

  isDeprecated: Boolean!

  deprecationReason: String
}

"""
One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.
"""
type __EnumValue {
  name: String!

  description: String

  isDeprecated: Boolean!

  deprecationReason: String
}

"""
A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.
"""
type __Directive {
  name: String!

  description: String

  isRepeatable: Boolean!

  locations: [__DirectiveLocation!]!

  args(includeDeprecated: Boolean = false): [__InputValue!]!
}

"""
A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.
"""
enum __DirectiveLocation {
  """
  Location adjacent to a query operation.
  """
  QUERY

  """
  Location adjacent to a mutation operation.
  """
  MUTATION

  """
  Location adjacent to a subscription operation.
  """
  SUBSCRIPTION

  """
  Location adjacent to a field.
  """
  FIELD

  """
  Location adjacent to a fragment definition.
  """
  FRAGMENT_DEFINITION

  """
  Location adjacent to a fragment spread.
  """
  FRAGMENT_SPREAD

  """
  Location adjacent to an inline fragment.
  """
  INLINE_FRAGMENT

  """
  Location adjacent to a variable definition.
  """
  VARIABLE_DEFINITION

  """
  Location adjacent to a schema definition.
  """
  SCHEMA

  """
  Location adjacent to a scalar definition.
  """
  SCALAR

  """
  Location adjacent to an object type definition.
  """
  OBJECT

  """
  Location adjacent to a field definition.
  """
  FIELD_DEFINITION

  """
  Location adjacent to an argument definition.
  """
  ARGUMENT_DEFINITION

  """
  Location adjacent to an interface definition.
  """
  INTERFACE

  """
  Location adjacent to a union definition.
  """
  UNION

  """
  Location adjacent to an enum definition.
  """
  ENUM

  """
  Location adjacent to an enum value definition.
  """
  ENUM_VALUE

  """
  Location adjacent to an input object type definition.
  """
  INPUT_OBJECT

  """
  Location adjacent to an input object field definition.
  """
  INPUT_FIELD_DEFINITION
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include ("Included when true." if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip ("Skipped when true." if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
Marks an element of a GraphQL schema as no longer supported.
"""
directive @deprecated ("Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https:\/\/commonmark.org\/)." reason: String = "No longer supported") on FIELD_DEFINITION|ARGUMENT_DEFINITION|INPUT_FIELD_DEFINITION|ENUM_VALUE

"""
Exposes a URL that specifies the behaviour of this scalar.
"""
directive @specifiedBy ("The URL that specifies the behaviour of this scalar." url: String!) on SCALAR

schema {
  query: Query
  mutation: Mutation
}
